<!DOCTYPE html>
<html lang="de-CH">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>N!NA-Rebu v2.4 - Regiebuch mit KI N!NA-Rebu v2.4 - Regiebuch mit KI, Cloud & NINA-Exchange v2.0 NINA-Exchange v2.0 (Stand-alone)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
  <!-- Supabase entfernt f√ºr Stand-alone Version -->
  <script>
    // PDF.js Worker konfigurieren
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    
    :root {
      --nina-primary: #3b82f6;
      --nina-primary-dark: #1e3a5f;
      --nina-success: #10b981;
      --nina-warning: #f97316;
      --nina-danger: #ef4444;
      --nina-purple: #8b5cf6;
      --nina-blue: #4169b2;
    }
    
    /* ============================================ */
    /* KI-ASSISTENT PANEL                         */
    /* ============================================ */
    .ki-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 400px;
      height: 100vh;
      background: white;
      box-shadow: -4px 0 20px rgba(0,0,0,0.15);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
    }
    .ki-panel.open { right: 0; }
    
    .ki-panel-header {
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      padding: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .ki-panel-header h3 { margin: 0; font-size: 1.1rem; display: flex; align-items: center; gap: 0.5rem; }
    .ki-panel-header button { background: rgba(255,255,255,0.2); border: none; color: white; width: 28px; height: 28px; border-radius: 4px; cursor: pointer; }
    .ki-panel-header button:hover { background: rgba(255,255,255,0.3); }
    
    .ki-messages {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .ki-message {
      padding: 0.75rem 1rem;
      border-radius: 12px;
      max-width: 90%;
      line-height: 1.5;
      font-size: 0.9rem;
    }
    .ki-message.user {
      background: #3b82f6;
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .ki-message.assistant {
      background: #f3f4f6;
      color: #1f2937;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .ki-message.assistant strong { color: #3b82f6; }
    .ki-message.loading {
      background: #f3f4f6;
      color: #9ca3af;
    }
    .ki-message p { margin: 0.25rem 0; }
    .ki-message p:first-child { margin-top: 0; }
    .ki-message p:last-child { margin-bottom: 0; }
    
    .ki-input-area {
      padding: 1rem;
      border-top: 1px solid #e5e7eb;
      background: #f9fafb;
    }
    .ki-input-area textarea {
      width: 100%;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      padding: 0.75rem;
      font-size: 0.9rem;
      resize: none;
      min-height: 60px;
    }
    .ki-input-area textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.15); }
    .ki-input-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .ki-toggle-btn {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(59,130,246,0.4);
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .ki-toggle-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(59,130,246,0.5);
    }
    .ki-toggle-btn.has-key { background: linear-gradient(135deg, #10b981, #3b82f6); }
    .ki-toggle-btn.panel-open { opacity: 0; pointer-events: none; }
    
    .typing-indicator {
      display: inline-block;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }
    
    /* API Key Status */
    .api-key-row { display: flex; gap: 0.5rem; align-items: center; }
    .api-test-btn { padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; cursor: pointer; border: 1px solid #d1d5db; background: white; transition: all 0.15s; }
    .api-test-btn:hover { border-color: #3b82f6; color: #3b82f6; }
    .api-test-btn.testing { background: #fef3c7; border-color: #f59e0b; color: #92400e; }
    .api-test-btn.success { background: #d1fae5; border-color: #10b981; color: #065f46; }
    .api-test-btn.error { background: #fee2e2; border-color: #ef4444; color: #991b1b; }
    .api-status { padding: 0.5rem; border-radius: 0.375rem; font-size: 0.875rem; margin-top: 0.5rem; }
    .api-status.success { background: #d1fae5; color: #065f46; }
    .api-status.error { background: #fee2e2; color: #991b1b; }
    .api-status.neutral { background: #f3f4f6; color: #6b7280; }

    /* Sidebar */
    .sidebar { background: linear-gradient(180deg, #1e3a5f 0%, #0f172a 100%); }
    .nav-section { color: #60a5fa; font-size: 0.65rem; font-weight: 700; letter-spacing: 0.1em; text-transform: uppercase; }
    .nav-item { transition: all 0.15s; border-left: 3px solid transparent; cursor: pointer; }
    .nav-item:hover { background: rgba(255,255,255,0.1); }
    .nav-item.active { background: rgba(59, 130, 246, 0.3); border-left-color: #3b82f6; }
    
    /* Buttons */
    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.15s; border: none; }
    .btn-primary { background: #3b82f6; color: white; }
    .btn-primary:hover { background: #2563eb; }
    .btn-success { background: #10b981; color: white; }
    .btn-success:hover { background: #059669; }
    .btn-danger { background: #ef4444; color: white; }
    .btn-danger:hover { background: #dc2626; }
    .btn-orange { background: #f97316; color: white; }
    .btn-orange:hover { background: #ea580c; }
    .btn-purple { background: #8b5cf6; color: white; }
    .btn-purple:hover { background: #7c3aed; }
    .btn-outline { background: white; border: 1px solid #d1d5db; color: #374151; }
    .btn-outline:hover { background: #f3f4f6; border-color: #3b82f6; color: #3b82f6; }
    .btn-outline-light { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #93c5fd; }
    .btn-outline-light:hover { background: rgba(255,255,255,0.1); }
    .btn-sm { padding: 0.375rem 0.75rem; font-size: 0.75rem; }
    .btn-xs { padding: 0.25rem 0.5rem; font-size: 0.65rem; }
    
    /* Form Elements */
    input, select, textarea { padding: 0.5rem 0.75rem; border: 1px solid #d1d5db; border-radius: 0.5rem; font-size: 0.875rem; transition: all 0.15s; width: 100%; background: white; }
    input:focus, select:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.15); }
    
    /* Cards */
    .card { background: white; border-radius: 0.75rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border: 1px solid #e5e7eb; }
    
    /* ============================================ */
    /* SCHREIBFL√ÑCHE - Word-√§hnlicher Editor       */
    /* ============================================ */
    .editor-container { 
      background: white; 
      border: 1px solid #e5e7eb; 
      border-radius: 0.5rem; 
      min-height: 500px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    
    .editor-content {
      padding: 2.5rem 3rem;
      min-height: 500px;
      outline: none;
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 12pt;
      line-height: 1.6;
      color: #1f2937;
    }
    
    /* WICHTIG: Alle importierten Styles √ºberschreiben! */
    .editor-content * {
      font-family: inherit !important;
      font-size: inherit !important;
      line-height: inherit !important;
      background: transparent !important;
    }
    
    /* Farbe nur f√ºr Elemente ohne Format-Klasse */
    .editor-content *:not([class*="format-"]):not(.figur-name):not(.dialog-text):not(.cue-marker):not(.cue-badge) {
      color: inherit !important;
    }
    
    /* Nur explizite Formatklassen d√ºrfen Styles √§ndern */
    .editor-content strong, 
    .editor-content b { font-weight: bold !important; }
    .editor-content em, 
    .editor-content i { font-style: italic !important; }
    .editor-content u { text-decoration: underline !important; }
    .editor-content s, 
    .editor-content .gestrichen { text-decoration: line-through !important; }
    
    .editor-content:empty:before {
      content: 'Hier schreiben oder Text einf√ºgen...';
      color: #9ca3af;
      font-style: italic;
    }
    
    /* ============================================ */
    /* FORMATVORLAGEN                              */
    /* ============================================ */
    
    /* Standard */
    .format-standard {
      margin: 0.25rem 0;
      text-indent: 0;
    }
    
    /* Dialog: FIGURENNAME: Text - mit Tab-Einr√ºckung (v1.2) */
    .format-dialog {
      margin: 0.3rem 0;
      display: grid;
      grid-template-columns: 7rem 1fr;
      gap: 0.75rem;
      align-items: baseline;
    }
    
    .format-dialog .figur-name {
      font-weight: bold;
      justify-self: start;
      white-space: nowrap;
    }
    
    .format-dialog .dialog-text {
      font-weight: normal;
    }
    
    /* Regieanweisung: (kursiv, einger√ºckt) */
    .format-regieanweisung {
      font-style: italic !important;
      color: #4b5563 !important;
      margin: 0.5rem 0;
      margin-left: 9.5rem;
    }
    
    /* Szenen-Titel: fett, gr√∂sser, mit Linie */
    .format-szene-titel {
      font-weight: bold !important;
      font-size: 14pt !important;
      margin-top: 2rem;
      margin-bottom: 1rem;
      padding-bottom: 0.25rem;
      border-bottom: 2px solid #d1d5db;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
    }
    
    /* Lied: kursiv, stark einger√ºckt, blau */
    .format-lied {
      font-style: italic !important;
      margin: 0.15rem 0;
      margin-left: 4rem;
      color: #1e40af !important;
    }
    
    /* Versma√ü: Monospace, einger√ºckt */
    .format-vers {
      margin: 0.15rem 0;
      margin-left: 3rem;
      font-family: 'Courier New', Courier, monospace !important;
      white-space: pre-wrap;
    }
    
    /* Akt-/Struktur-Titel (v1.4) */
    .format-akt-titel {
      font-size: 1.5rem !important;
      font-weight: bold;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      margin: 2rem 0 1.5rem;
      padding: 1rem 0;
      border-top: 2px solid #374151;
      border-bottom: 2px solid #374151;
      color: #1f2937;
    }
    
    /* Pause-Markierung (v1.4) */
    .format-pause {
      font-size: 1.1rem;
      font-weight: bold;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.3em;
      margin: 2rem 0;
      padding: 0.75rem 0;
      color: #6b7280;
      background: #f3f4f6;
      border-radius: 4px;
    }
    
    /* Gestrichen (v1.2) */
    .format-gestrichen {
      text-decoration: line-through;
      color: #9ca3af;
      background: #fef2f2;
    }
    
    /* NEU: Erg√§nzung (v1.4) */
    .format-ergaenzung {
      background: #dbeafe;
      color: #1e40af;
      border-bottom: 2px solid #3b82f6;
    }
    
    /* Musik-Einsatz (v1.5) üéº */
    .format-musik {
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 12pt;
      font-style: italic !important;
      margin: 0.5rem 0;
      margin-left: 9.5rem;
      padding: 6pt 10pt;
      line-height: 1.4;
      color: #7c3aed !important;
      border-left: 3px solid #7c3aed;
      background: #f5f3ff !important;
    }
    
    /* Sound-Effekt (v1.5) üîä */
    .format-sound {
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 12pt;
      font-style: italic !important;
      margin: 0.5rem 0;
      margin-left: 9.5rem;
      padding: 6pt 10pt;
      line-height: 1.4;
      color: #059669 !important;
      border-left: 3px solid #059669;
      background: #ecfdf5 !important;
    }
    
    /* Regie-Notiz (v1.5) üìù - wird NICHT gedruckt */
    .format-notiz {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
      font-size: 10pt !important;
      font-style: italic !important;
      color: #92400e !important;
      background: #fef3c7 !important;
      padding: 8pt 12pt;
      border-left: 3px solid #fbbf24;
      margin: 0.75rem 0;
      border-radius: 0 4px 4px 0;
    }
    @media print {
      .format-notiz { display: none !important; }
    }
    
    /* Nebentext (v1.5) üìÑ */
    .format-nebentext {
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 10pt !important;
      font-style: italic !important;
      margin: 0.5rem 0;
      line-height: 1.5;
      color: #6b7280 !important;
    }
    
    /* Ansicht: Streichungen ausblenden */
    .hide-streichungen .format-gestrichen {
      display: none;
    }
    
    /* Ansicht: √Ñnderungsmarkierungen ausblenden (f√ºr Schauspieler-Ansicht) */
    .hide-aenderungen .format-gestrichen {
      display: none;
    }
    .hide-aenderungen .format-ergaenzung {
      background: transparent;
      color: inherit;
      border-bottom: none;
    }
    
    /* Ansicht: Cues ausblenden (f√ºr Schauspieler-Ansicht) */
    .hide-cues .cue-inline-marker {
      display: none;
    }
    
    /* Inline Cue-Marker im Text */
    .cue-inline-marker {
      display: inline-flex;
      align-items: center;
      gap: 2px;
      padding: 1px 6px;
      margin: 0 2px;
      border-radius: 3px;
      font-size: 0.7rem;
      font-weight: 600;
      vertical-align: middle;
      cursor: pointer;
    }
    .cue-inline-marker.cue-lx { background: #fef3c7; color: #92400e; border: 1px solid #f59e0b; }
    .cue-inline-marker.cue-q { background: #dbeafe; color: #1e40af; border: 1px solid #3b82f6; }
    .cue-inline-marker.cue-v { background: #ede9fe; color: #5b21b6; border: 1px solid #8b5cf6; }
    .cue-inline-marker:hover { transform: scale(1.05); }
    
    /* ============================================ */
    /* TOOLBAR                                      */
    /* ============================================ */
    .toolbar { 
      background: #f8fafc; 
      border-bottom: 1px solid #e5e7eb; 
      padding: 0.5rem 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: nowrap;
      align-items: center;
      overflow-x: auto;
    }
    
    .toolbar-group {
      display: flex;
      gap: 0.25rem;
      align-items: center;
    }
    
    .toolbar-btn {
      padding: 0.375rem 0.625rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background: white;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.15s;
      min-width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .toolbar-btn:hover {
      background: #e5e7eb;
      border-color: #9ca3af;
    }
    
    /* Icon-only buttons with label on hover */
    .toolbar-btn.toolbar-icon-only {
      position: relative;
    }
    .toolbar-btn.toolbar-icon-only .toolbar-label {
      display: none;
      margin-left: 0.25rem;
    }
    .toolbar-btn.toolbar-icon-only:hover .toolbar-label {
      display: inline;
    }
    
    .toolbar-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    
    .toolbar-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .toolbar-divider {
      width: 1px;
      height: 24px;
      background: #d1d5db;
      margin: 0 0.5rem;
    }
    
    .format-select {
      padding: 0.375rem 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background: white;
      font-size: 0.8rem;
      width: 150px;
      cursor: pointer;
    }
    
    .format-select:hover {
      border-color: #3b82f6;
    }
    
    /* ============================================ */
    /* SZENEN-LISTE                                 */
    /* ============================================ */
    .szene-item {
      padding: 0.6rem 0.75rem;
      border-radius: 0.375rem;
      cursor: pointer;
      transition: all 0.15s;
      border-left: 3px solid transparent;
      margin-bottom: 0.25rem;
    }
    
    .szene-item:hover {
      background: #f3f4f6;
    }
    
    .szene-item.active {
      background: #dbeafe;
      border-left-color: #3b82f6;
    }
    
    /* ============================================ */
    /* CUE-BADGES                                   */
    /* ============================================ */
    .cue-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.125rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    
    .cue-lx { background: #fef3c7; color: #92400e; }
    .cue-q { background: #d1fae5; color: #065f46; }
    .cue-v { background: #e0e7ff; color: #3730a3; }
    .cue-r { background: #fce7f3; color: #9d174d; }
    .cue-u { background: #fed7aa; color: #9a3412; }
    
    /* ============================================ */
    /* MODAL                                        */
    /* ============================================ */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .modal-content {
      background: white;
      border-radius: 0.75rem;
      max-width: 600px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
    }
    
    .modal-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      background: white;
      z-index: 10;
    }
    
    .modal-body {
      padding: 1.5rem;
    }
    
    /* ============================================ */
    /* DETAILS PANEL                                */
    /* ============================================ */
    .details-panel {
      border-left: 1px solid #e5e7eb;
      background: #fafafa;
    }
    
    .detail-section {
      border-bottom: 1px solid #e5e7eb;
      padding: 1rem;
    }
    
    .detail-section:last-child {
      border-bottom: none;
    }
    
    .detail-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #6b7280;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }
    
    /* Format-Indikator */
    .format-item {
      color: #6b7280;
      transition: all 0.15s ease;
    }
    .format-item.active {
      background: #1e40af;
      color: white;
      font-weight: 600;
    }
    .format-item.active span {
      color: #93c5fd;
    }
    
    /* ============================================ */
    /* FIGUREN BADGES                               */
    /* ============================================ */
    .figur-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.25rem 0.5rem;
      background: #eff6ff;
      border: 1px solid #bfdbfe;
      border-radius: 9999px;
      font-size: 0.75rem;
      color: #1e40af;
    }
    
    .figur-avatar {
      width: 1.5rem;
      height: 1.5rem;
      border-radius: 9999px;
      background: #3b82f6;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: 600;
    }
    
    /* Checkbox */
    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.375rem 0;
      cursor: pointer;
    }
    
    .checkbox-item:hover {
      background: #f3f4f6;
      margin: 0 -0.5rem;
      padding-left: 0.5rem;
      padding-right: 0.5rem;
      border-radius: 0.25rem;
    }
    
    .checkbox-item input[type="checkbox"] {
      width: auto;
      margin: 0;
    }
    
    /* Quick Insert Bar */
    .quick-insert-bar {
      background: linear-gradient(to right, #f0f9ff, #eff6ff);
      border-bottom: 1px solid #bfdbfe;
      padding: 0.5rem 1rem;
      display: flex;
      gap: 0.375rem;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .quick-insert-btn {
      padding: 0.25rem 0.5rem;
      background: white;
      border: 1px solid #bfdbfe;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 500;
      color: #1e40af;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .quick-insert-btn:hover {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    
    /* Kost√ºme Cards */
    .kostuem-card {
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      overflow: hidden;
      background: white;
    }
    
    .kostuem-card:hover {
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }
    
    /* Text-Clamp f√ºr Zusammenfassungen */
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    /* Lightbox */
    .lightbox-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: zoom-out;
    }
    
    .lightbox-content {
      max-width: 90vw;
      max-height: 90vh;
      object-fit: contain;
    }
    
    .lightbox-close {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      font-size: 2rem;
      cursor: pointer;
      z-index: 1001;
    }
    
    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      color: white;
      font-size: 3rem;
      cursor: pointer;
      padding: 20px;
      user-select: none;
    }
    
    .lightbox-nav.prev { left: 10px; }
    .lightbox-nav.next { right: 10px; }
    
    .lightbox-counter {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 0.875rem;
    }
    
    /* Thumbnail Grid */
    .image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 8px;
    }
    
    .image-thumb {
      aspect-ratio: 1;
      object-fit: cover;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    .image-thumb:hover {
      transform: scale(1.05);
    }
    
    .add-image-btn {
      aspect-ratio: 1;
      border: 2px dashed #d1d5db;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #9ca3af;
      font-size: 1.5rem;
    }
    
    .add-image-btn:hover {
      border-color: #9333ea;
      color: #9333ea;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="app"></div>

  <script>
    // ============================================
    // N!NA STORAGE KEYS
    // ============================================
    const STORAGE_PREFIX = 'nina_';
    const KEYS = {
      projekte: STORAGE_PREFIX + 'projekte',
      aktuellesProjekt: STORAGE_PREFIX + 'aktuelles_projekt',
      textbuch: (id) => `${STORAGE_PREFIX}textbuch_${id}`,
      fassungen: (id) => `${STORAGE_PREFIX}fassungen_${id}`,
      cues: (id) => `${STORAGE_PREFIX}cues_${id}`,
      requisiten: (id) => `${STORAGE_PREFIX}requisiten_${id}`,
      kostueme: (id) => `${STORAGE_PREFIX}kostueme_${id}`,
      medien: (id) => `${STORAGE_PREFIX}medien_${id}`,
      figuren: (id) => `${STORAGE_PREFIX}figuren_${id}`,
      szenen: (id) => `${STORAGE_PREFIX}szenen_${id}`,
      buehne: (id) => `${STORAGE_PREFIX}buehne_${id}`,
      projektMeta: (id) => `${STORAGE_PREFIX}projekt_meta_${id}`,
    };

    // ============================================
    // SUPABASE CLOUD - DEAKTIVIERT (Stand-alone Version)
    // ============================================
    const SUPABASE_URL = '';
    const SUPABASE_ANON_KEY = '';
    // Dummy-DB f√ºr Stand-alone Version
    const db = { 
      from: () => ({ 
        select: () => ({ eq: () => ({ single: () => Promise.resolve({ data: null, error: null }), order: () => Promise.resolve({ data: [], error: null }) }), order: () => Promise.resolve({ data: [], error: null }) }),
        insert: () => Promise.resolve({ data: null, error: null }), 
        upsert: () => Promise.resolve({ data: null, error: null }), 
        update: () => ({ eq: () => Promise.resolve({ error: null }) }), 
        delete: () => ({ eq: () => Promise.resolve({ error: null }) })
      }), 
      auth: { 
        getSession: () => Promise.resolve({ data: { session: null } }),
        getUser: () => Promise.resolve({ data: { user: null }, error: null }), 
        signInWithPassword: () => Promise.resolve({ error: { message: 'Cloud deaktiviert in Stand-alone Version' } }), 
        signUp: () => Promise.resolve({ error: { message: 'Cloud deaktiviert' } }), 
        signOut: () => Promise.resolve({}) 
      } 
    };
    
    let cloudUser = null;
    let cloudProjects = [];
    let currentCloudProjectId = null;
    let isCloudMode = false;

    // ============================================
    // UTILITIES
    // ============================================
    const save = (key, data) => localStorage.setItem(key, JSON.stringify(data));
    const load = (key, def = null) => { try { return JSON.parse(localStorage.getItem(key)) || def; } catch { return def; } };
    const genId = () => 'id_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    // HTML-Zeichen escapen f√ºr sichere Anzeige in Attributen
    const escapeHtml = (str) => {
      if (!str) return '';
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    };
    
    // v1.2: Datum MIT Uhrzeit formatieren
    const formatDate = (d) => {
      const date = new Date(d);
      return date.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit', year: 'numeric' });
    };
    
    const formatDateTime = (d) => {
      const date = new Date(d);
      const datePart = date.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit', year: 'numeric' });
      const timePart = date.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
      return `${datePart}, ${timePart}`;
    };

    // ============================================
    // INDEXEDDB F√úR MEDIEN-SPEICHERUNG (v1.3)
    // ============================================
    let mediaBD = null;
    const MEDIA_DB_NAME = 'NinaRebuMediaDB';
    const AUDIO_STORE_NAME = 'audioFiles';
    const IMAGE_STORE_NAME = 'imageFiles';
    
    // IndexedDB initialisieren
    function initAudioDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(MEDIA_DB_NAME, 2); // Version 2 f√ºr Images
        
        request.onerror = () => {
          console.error('IndexedDB Fehler:', request.error);
          reject(request.error);
        };
        
        request.onsuccess = () => {
          mediaBD = request.result;
          console.log('‚úÖ Medien-Datenbank bereit');
          resolve(mediaBD);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(AUDIO_STORE_NAME)) {
            db.createObjectStore(AUDIO_STORE_NAME, { keyPath: 'id' });
            console.log('‚úÖ Audio-Speicher erstellt');
          }
          if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
            db.createObjectStore(IMAGE_STORE_NAME, { keyPath: 'id' });
            console.log('‚úÖ Bild-Speicher erstellt');
          }
        };
      });
    }
    
    // Audio-Datei speichern
    async function saveAudioToDB(mediumId, file) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const transaction = mediaBD.transaction([AUDIO_STORE_NAME], 'readwrite');
          const store = transaction.objectStore(AUDIO_STORE_NAME);
          
          const audioData = {
            id: mediumId,
            data: reader.result, // ArrayBuffer
            type: file.type,
            name: file.name,
            size: file.size,
            savedAt: new Date().toISOString()
          };
          
          const request = store.put(audioData);
          request.onsuccess = () => {
            console.log('‚úÖ Audio gespeichert:', file.name, '(' + (file.size / 1024 / 1024).toFixed(2) + ' MB)');
            resolve(audioData);
          };
          request.onerror = () => reject(request.error);
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsArrayBuffer(file);
      });
    }
    
    // Audio-Datei laden
    async function loadAudioFromDB(mediumId) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const transaction = mediaBD.transaction([AUDIO_STORE_NAME], 'readonly');
        const store = transaction.objectStore(AUDIO_STORE_NAME);
        const request = store.get(mediumId);
        
        request.onsuccess = () => {
          if (request.result) {
            const blob = new Blob([request.result.data], { type: request.result.type });
            const url = URL.createObjectURL(blob);
            resolve({ url, data: request.result });
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Audio-Datei l√∂schen
    async function deleteAudioFromDB(mediumId) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const transaction = mediaBD.transaction([AUDIO_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(AUDIO_STORE_NAME);
        const request = store.delete(mediumId);
        
        request.onsuccess = () => {
          console.log('‚úÖ Audio gel√∂scht:', mediumId);
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Alle Audio-URLs beim Start wiederherstellen
    async function restoreAudioUrls() {
      if (!mediaBD) await initAudioDB();
      
      for (const medium of state.medien) {
        if (medium.type === 'audio' && medium.source === 'local') {
          try {
            const result = await loadAudioFromDB(medium.id);
            if (result) {
              medium.localFileUrl = result.url;
              medium.audioStored = true;
              console.log('‚úÖ Audio wiederhergestellt:', medium.name);
            }
          } catch (e) {
            console.warn('Audio nicht gefunden:', medium.name);
          }
        }
      }
    }
    
    // Speicherplatz-Info
    async function getAudioStorageInfo() {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve) => {
        const transaction = mediaBD.transaction([AUDIO_STORE_NAME], 'readonly');
        const store = transaction.objectStore(AUDIO_STORE_NAME);
        const request = store.getAll();
        
        request.onsuccess = () => {
          const files = request.result || [];
          const totalSize = files.reduce((sum, f) => sum + (f.size || 0), 0);
          resolve({
            count: files.length,
            totalSize: totalSize,
            totalSizeMB: (totalSize / 1024 / 1024).toFixed(1)
          });
        };
        request.onerror = () => resolve({ count: 0, totalSize: 0, totalSizeMB: '0' });
      });
    }
    
    // ============================================
    // BILD-SPEICHERUNG (f√ºr Kost√ºme/Masken)
    // ============================================
    
    // Bild in IndexedDB speichern
    async function saveImageToDB(imageId, file) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const transaction = mediaBD.transaction([IMAGE_STORE_NAME], 'readwrite');
          const store = transaction.objectStore(IMAGE_STORE_NAME);
          
          const imageData = {
            id: imageId,
            data: reader.result, // ArrayBuffer
            type: file.type,
            name: file.name,
            size: file.size,
            savedAt: new Date().toISOString()
          };
          
          const request = store.put(imageData);
          request.onsuccess = () => {
            console.log('‚úÖ Bild gespeichert:', file.name, '(' + (file.size / 1024).toFixed(0) + ' KB)');
            resolve(imageData);
          };
          request.onerror = () => reject(request.error);
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsArrayBuffer(file);
      });
    }
    
    // Bild aus IndexedDB laden
    async function loadImageFromDB(imageId) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const transaction = mediaBD.transaction([IMAGE_STORE_NAME], 'readonly');
        const store = transaction.objectStore(IMAGE_STORE_NAME);
        const request = store.get(imageId);
        
        request.onsuccess = () => {
          if (request.result) {
            const blob = new Blob([request.result.data], { type: request.result.type });
            const url = URL.createObjectURL(blob);
            resolve({ url, data: request.result });
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Bild aus IndexedDB l√∂schen
    async function deleteImageFromDB(imageId) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const transaction = mediaBD.transaction([IMAGE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(IMAGE_STORE_NAME);
        const request = store.delete(imageId);
        
        request.onsuccess = () => {
          console.log('‚úÖ Bild gel√∂scht:', imageId);
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Tempor√§rer Cache f√ºr geladene Bild-URLs
    const imageUrlCache = {};
    
    // Bild-URL aus Cache oder DB laden
    async function getImageUrl(imageId) {
      if (!imageId) return null;
      if (imageUrlCache[imageId]) return imageUrlCache[imageId];
      
      try {
        const result = await loadImageFromDB(imageId);
        if (result) {
          imageUrlCache[imageId] = result.url;
          return result.url;
        }
      } catch (e) {
        console.warn('Bild nicht gefunden:', imageId);
      }
      return null;
    }

    // ============================================
    // FORMATVORLAGEN DEFINITION
    // ============================================
    const FORMATVORLAGEN = {
      standard: { 
        name: 'Standard', 
        class: 'format-standard', 
        description: 'Normaler Text',
        icon: '¬∂'
      },
      dialog: { 
        name: 'Dialog', 
        class: 'format-dialog', 
        description: 'FIGUR: Sprechtext',
        icon: 'üí¨'
      },
      regieanweisung: { 
        name: 'Regieanweisung', 
        class: 'format-regieanweisung', 
        description: '(Handlungsanweisung)',
        icon: 'üé¨'
      },
      szeneTitel: { 
        name: 'Szenen-Titel', 
        class: 'format-szene-titel', 
        description: '1.1 √úberschrift',
        icon: 'üîç'
      },
      lied: { 
        name: 'Lied', 
        class: 'format-lied', 
        description: 'Gesungener Text',
        icon: 'üéµ'
      },
      vers: { 
        name: 'Versma√ü', 
        class: 'format-vers', 
        description: 'Gebundene Sprache',
        icon: 'üìú'
      },
      aktTitel: { 
        name: 'Akt-/Struktur-Titel', 
        class: 'format-akt-titel', 
        description: 'ERSTER AKT',
        icon: 'üèõÔ∏è'
      },
      pause: { 
        name: 'Pause', 
        class: 'format-pause', 
        description: '‚Äî PAUSE ‚Äî',
        icon: '‚è∏Ô∏è'
      },
      musik: { 
        name: 'Musik', 
        class: 'format-musik', 
        description: 'Musik-Einsatz',
        icon: 'üéº'
      },
      sound: { 
        name: 'Sound', 
        class: 'format-sound', 
        description: 'Sound-Effekt',
        icon: 'üîä'
      },
      notiz: { 
        name: 'Notiz', 
        class: 'format-notiz', 
        description: 'Regie-Notiz (nicht drucken)',
        icon: 'üìù'
      },
      nebentext: { 
        name: 'Nebentext', 
        class: 'format-nebentext', 
        description: 'Erl√§uternder Text',
        icon: 'üìÑ'
      },
    };

    // ============================================
    // CUE-TYPEN DEFINITION
    // ============================================
    const CUE_TYPEN = {
      lx: { name: 'Licht', prefix: 'LX', class: 'cue-lx', icon: 'üí°' },
      q: { name: 'Ton', prefix: 'Q', class: 'cue-q', icon: 'üîä' },
      v: { name: 'Video', prefix: 'V', class: 'cue-v', icon: 'üì∫' },
      r: { name: 'Requisite', prefix: 'R', class: 'cue-r', icon: 'üé≠' },
      u: { name: 'Umbau', prefix: 'U', class: 'cue-u', icon: 'üîÑ' },
    };
    
    // STRUKTUR-TYPEN DEFINITION
    // v2.0: Struktur-Vorlagen (nur Anregungen, keine Vorgaben!)
    const STRUKTUR_VORLAGEN = {
      akte: { 
        name: 'Klassisch (Akte)', 
        beschreibung: 'Klassische Akt-Struktur (1-5 Akte)',
        vorgeschlageneGruppen: ['Prolog', 'Erster Akt', 'Zweiter Akt', 'Dritter Akt', 'Vierter Akt', 'F√ºnfter Akt', 'Epilog']
      },
      drei_akte: { 
        name: 'Drei-Akt-Struktur', 
        beschreibung: 'Setup - Konfrontation - Aufl√∂sung',
        vorgeschlageneGruppen: ['Exposition', 'Konfrontation', 'Aufl√∂sung']
      },
      heldenreise: { 
        name: 'Heldenreise (Campbell)', 
        beschreibung: '12 Stationen der mythologischen Reise',
        vorgeschlageneGruppen: ['Gewohnte Welt', 'Ruf des Abenteuers', 'Weigerung', 'Mentor', '√úberschreiten der Schwelle', 'Pr√ºfungen & Verb√ºndete', 'Vordringen zur tiefsten H√∂hle', 'Entscheidende Pr√ºfung', 'Belohnung', 'R√ºckweg', 'Auferstehung', 'R√ºckkehr mit dem Elixier']
      },
      episch: { 
        name: 'Episches Theater (Brecht)', 
        beschreibung: 'Episodisch, mit Songs und Kommentaren',
        vorgeschlageneGruppen: ['Prolog', 'Episode 1', 'Song', 'Episode 2', 'Kommentar', 'Episode 3', 'Epilog']
      },
      episodisch: { 
        name: 'Episodisch/Bilder', 
        beschreibung: 'Lose verbundene Szenen/Bilder',
        vorgeschlageneGruppen: ['Bild 1', 'Bild 2', 'Bild 3', 'Bild 4', 'Bild 5']
      },
      offen: { 
        name: 'Offene Form', 
        beschreibung: 'Keine vorgegebene Struktur',
        vorgeschlageneGruppen: ['Teil 1']
      },
      sequenzen: { 
        name: 'Sequenzen (8er)', 
        beschreibung: '8 Sequenzen √† 15 Minuten',
        vorgeschlageneGruppen: ['Sequenz 1', 'Sequenz 2', 'Sequenz 3', 'Sequenz 4', 'Sequenz 5', 'Sequenz 6', 'Sequenz 7', 'Sequenz 8']
      },
      musical: { 
        name: 'Musical', 
        beschreibung: 'Mit Nummern und Szenen',
        vorgeschlageneGruppen: ['Ouvert√ºre', 'Erster Akt', 'Pause', 'Zweiter Akt', 'Finale']
      }
    };
    
    // Aktive Gruppen des Projekts (frei editierbar)
    // Diese werden im projektMeta gespeichert als projektMeta.eigeneGruppen = ['Prolog', 'Erster Akt', ...]
    
    // Kompatibilit√§t: STRUKTUR_TYPEN f√ºr Legacy-Code
    const STRUKTUR_TYPEN = {
      akte: { name: 'Akte & Szenen', gruppenLabel: 'Akt', gruppen: ['1','2','3','4','5'], gruppenNamen: {} },
      sequenzen: { name: 'Sequenzen', gruppenLabel: 'Sequenz', gruppen: ['1','2','3','4','5','6','7','8'], gruppenNamen: {} },
      drei_akte: { name: 'Drei-Akt', gruppenLabel: 'Teil', gruppen: ['anfang','mitte','ende'], gruppenNamen: {} },
      episodisch: { name: 'Episodisch', gruppenLabel: 'Bild', gruppen: ['1','2','3','4','5'], gruppenNamen: {} }
    };

    // ============================================
    // APP STATE
    // ============================================
    let state = {
      currentView: 'textbuch',
      projektId: null,
      projektMeta: {
        titel: 'Neues Projekt',
        untertitel: '',
        autor: '',
        tagline: '',
        logline: '',
        copyright: '',
        titelbild: '',
        fassung: 'Arbeitsfassung',
        fassungsDatum: new Date().toISOString(),
        // v2.0: Flexibles Struktur-System
        strukturVorlage: 'akte', // Nur als Referenz, keine Einschr√§nkung
        eigeneGruppen: ['Erster Akt'], // Frei editierbare Liste der Gruppen/Akte
        premiere: '',
        spielort: ''
      },
      figuren: [],
      szenen: [],
      aktiveSzene: null,
      textbuch: {},
      cues: [],
      fassungen: [],
      requisiten: [],
      kostueme: [],
      medien: [],
      buehne: [], // v1.3: B√ºhnenbilder/Pl√§ne
      showGestrichenes: true,
      selectedFormat: 'dialog',
      // v1.4: Textansicht (schauspieler, technik, aenderungen)
      textAnsicht: 'technik',
      // v1.2: Undo-History
      undoStack: [],
      redoStack: [],
      // Modals
      showImportModal: false,
      showExportModal: false,
      showFassungModal: false,
      showFigurModal: false,
      showCueModal: false,
      showSzeneModal: false,
      showKostuemModal: false,
      showMediumModal: false,
      showRequisitenModal: false,
      showBuehneModal: false,
      showLightbox: false,
      showProjektModal: false,
      showProjektListeModal: false,
      editingFigur: null,
      editingCue: null,
      editingSzene: null,
      editingKostuem: null,
      editingMedium: null,
      editingRequisit: null,
      editingBuehne: null,
      // Lightbox
      lightboxImages: [],
      lightboxIndex: 0,
      // v1.3: Medien-Player State
      currentlyPlaying: null,
      playbackRate: 1.0,
      // v1.7: KI-Assistent
      kiPanelOpen: false,
      kiMessages: [],
      kiInput: '',
      kiLoading: false,
      // v2.0: Cloud
      showCloudModal: false,
    };
    
    // KI State (au√üerhalb von state wegen localStorage)
    let apiKeyStatus = 'idle'; // 'idle', 'testing', 'success', 'error'
    let apiKeyError = '';

    // ============================================
    // CLOUD FUNKTIONEN
    // ============================================
    
    // URL-Parameter auslesen (f√ºr Dashboard-Integration)
    function getUrlProjectId() {
      const params = new URLSearchParams(window.location.search);
      return params.get('project');
    }
    
    async function checkCloudAuth() {
      const { data: { session } } = await db.auth.getSession();
      if (session?.user) {
        cloudUser = session.user;
        isCloudMode = true;
        await loadCloudProjects();
        
        // Automatisch Projekt √∂ffnen wenn in URL angegeben
        const urlProjectId = getUrlProjectId();
        if (urlProjectId) {
          const cloudProject = cloudProjects.find(p => p.id === urlProjectId);
          if (cloudProject) {
            console.log('Auto-opening project from URL:', urlProjectId);
            await selectCloudProject(urlProjectId);
          }
        }
      }
      render();
    }
    
    async function cloudLogin(email, password) {
      const { data, error } = await db.auth.signInWithPassword({ email, password });
      if (error) { alert('Login fehlgeschlagen: ' + error.message); return; }
      cloudUser = data.user;
      isCloudMode = true;
      await loadCloudProjects();
      render();
    }
    
    async function cloudRegister(email, password, name) {
      const { data, error } = await db.auth.signUp({ 
        email, 
        password,
        options: { data: { full_name: name } }
      });
      if (error) { alert('Registrierung fehlgeschlagen: ' + error.message); return; }
      alert('Registrierung erfolgreich! Bitte E-Mail best√§tigen.');
    }
    
    async function cloudLogout() {
      await db.auth.signOut();
      cloudUser = null;
      cloudProjects = [];
      currentCloudProjectId = null;
      isCloudMode = false;
      render();
    }
    
    async function loadCloudProjects() {
      const { data, error } = await db.from('projects')
        .select('*')
        .or('app_type.eq.rebu,app_type.is.null')
        .order('updated_at', { ascending: false });
      if (!error && data) {
        cloudProjects = data.map(p => ({
          id: p.id,
          name: p.name,
          subtitle: p.subtitle,
          author: p.author,
          premiere: p.premiere_date,
          venue: p.venue
        }));
      }
    }
    
    async function selectCloudProject(cloudId) {
      currentCloudProjectId = cloudId;
      const cloudProject = cloudProjects.find(p => p.id === cloudId);
      if (!cloudProject) return;
      
      const localId = 'cloud_' + cloudId;
      let projekte = load(KEYS.projekte, []);
      let existingIdx = projekte.findIndex(p => p.id === localId);
      
      const projektData = { id: localId, cloudId: cloudId, name: cloudProject.name };
      
      // Pr√ºfe ob lokale Daten bereits existieren
      const existingMeta = load(KEYS.projektMeta(localId), null);
      const existingSzenen = load(KEYS.szenen(localId), null);
      const hasLocalData = existingMeta !== null || (existingSzenen !== null && existingSzenen.length > 0);
      
      if (existingIdx >= 0) {
        projekte[existingIdx] = projektData;
      } else {
        projekte.push(projektData);
      }
      save(KEYS.projekte, projekte);
      
      state.projektId = localId;
      save(KEYS.aktuellesProjekt, localId);
      
      // Nur beim ERSTEN Mal von Cloud syncen (wenn keine lokalen Daten)
      if (!hasLocalData) {
        console.log('Erstes Mal: Sync von Cloud...');
        await syncFromCloud(cloudId, localId);
      } else {
        console.log('Lokale Daten vorhanden, kein Sync n√∂tig');
        // IMMER den Projektnamen aus der Cloud √ºbernehmen
        const meta = load(KEYS.projektMeta(localId), {});
        meta.titel = cloudProject.name || meta.titel || 'Unbenannt';
        save(KEYS.projektMeta(localId), meta);
      }
      
      loadProjektDaten();
      render();
    }
    
    async function syncFromCloud(cloudId, localId) {
      console.log('syncFromCloud', cloudId, localId);
      
      // Projekt-Meta laden
      const { data: project, error: projectError } = await db.from('projects').select('*').eq('id', cloudId).single();
      if (project && !projectError) {
        const meta = {
          titel: project.name || 'Unbenannt',
          untertitel: project.subtitle || '',
          autor: project.author || '',
          tagline: project.tagline || '',
          logline: project.logline || '',
          copyright: project.copyright || '',
          titelbild: project.cover_image || '',
          fassung: project.version_name || 'Arbeitsfassung',
          fassungsDatum: project.version_date || new Date().toISOString(),
          strukturTyp: project.structure_type || 'akte',
          premiere: project.premiere_date || '',
          spielort: project.venue || ''
        };
        save(KEYS.projektMeta(localId), meta);
      }
      
      // Figuren laden
      const { data: figures, error: figuresError } = await db.from('figures').select('*').eq('project_id', cloudId).order('sort_order');
      if (!figuresError) {
        save(KEYS.figuren(localId), (figures || []).map(f => ({
          id: f.id, name: f.name || '', kuerzel: f.abbreviation || '',
          beschreibung: f.description || '', want: f.want || '', need: f.need || ''
        })));
      }
      
      // Szenen laden
      const { data: scenes, error: scenesError } = await db.from('scenes').select('*').eq('project_id', cloudId).order('sort_order');
      if (!scenesError) {
        const szenen = (scenes || []).map(s => ({
          id: s.id, nummer: s.number || '', titel: s.title || s.name || '',
          ort: s.location || '', zeit: s.time_of_day || '',
          gruppe: s.scene_group || '', zusammenfassung: s.summary || '',
          figuren: []
        }));
        
        // Scene-Figures laden (optional - bei Fehler ignorieren)
        const { data: sceneFigures } = await db.from('scene_figures').select('*').eq('project_id', cloudId);
        if (sceneFigures) {
          sceneFigures.forEach(sf => {
            const szene = szenen.find(s => s.id === sf.scene_id);
            if (szene && sf.figure_id) {
              if (!szene.figuren) szene.figuren = [];
              szene.figuren.push(sf.figure_id);
            }
          });
        }
        save(KEYS.szenen(localId), szenen);
      }
      
      // Textbuch laden (optional)
      const { data: sceneTexts } = await db.from('scene_texts').select('*').eq('project_id', cloudId);
      if (sceneTexts && sceneTexts.length > 0) {
        const textbuch = {};
        sceneTexts.forEach(st => { textbuch[st.scene_id] = st.content || ''; });
        save(KEYS.textbuch(localId), textbuch);
      }
      
      // Cues laden (optional - bei Fehler ignorieren)
      const { data: cues, error: cuesError } = await db.from('cues').select('*').eq('project_id', cloudId).order('cue_number');
      if (!cuesError && cues) {
        save(KEYS.cues(localId), cues.map(c => ({
          id: c.id, typ: c.cue_type || 'lx', nummer: c.cue_number || 0,
          szeneId: c.scene_id, beschreibung: c.description || '',
          dauer: c.duration || '', ankerText: c.anchor_text || ''
        })));
      }
      
      // Kost√ºme laden (optional)
      const { data: costumes } = await db.from('costumes').select('*').eq('project_id', cloudId);
      if (costumes) {
        const { data: costumeScenes } = await db.from('costume_scenes').select('*');
        save(KEYS.kostueme(localId), costumes.map(k => ({
          id: k.id, name: k.name || '', figur: k.figure_id,
          beschreibung: k.description || '', notizen: k.notes || '',
          szenen: (costumeScenes || []).filter(cs => cs.costume_id === k.id).map(cs => cs.scene_id)
        })));
      }
      
      // Requisiten laden (optional)
      const { data: props } = await db.from('props').select('*').eq('project_id', cloudId);
      if (props) {
        const { data: propScenes } = await db.from('prop_scenes').select('*');
        save(KEYS.requisiten(localId), props.map(r => ({
          id: r.id, name: r.name || '', beschreibung: r.description || '',
          szenen: (propScenes || []).filter(ps => ps.prop_id === r.id).map(ps => ps.scene_id)
        })));
      }
      
      // Medien laden (optional)
      const { data: media } = await db.from('media').select('*').eq('project_id', cloudId);
      if (media) {
        save(KEYS.medien(localId), media.map(m => ({
          id: m.id, name: m.name || '', typ: m.media_type || '',
          url: m.url || '', beschreibung: m.description || ''
        })));
      }
      
      // B√ºhnenbilder laden (optional)
      const { data: stageDesigns } = await db.from('stage_designs').select('*').eq('project_id', cloudId);
      if (stageDesigns) {
        save(KEYS.buehne(localId), stageDesigns.map(b => ({
          id: b.id, name: b.name || '', bild: b.image_url || '', beschreibung: b.description || ''
        })));
      }
      
      // Fassungen laden (optional)
      const { data: versions } = await db.from('script_versions').select('*').eq('project_id', cloudId).order('created_at', { ascending: false });
      if (versions) {
        save(KEYS.fassungen(localId), versions.map(v => ({
          id: v.id, name: v.name || '', datum: v.version_date || v.created_at,
          textbuch: v.content || {}
        })));
      }
    }
    
    async function createCloudProject() {
      const name = document.getElementById('cloud_projekt_name')?.value?.trim();
      if (!name) return alert('Projektname erforderlich!');
      if (!cloudUser) return alert('Bitte zuerst einloggen!');
      
      const { data: projectData, error } = await db.from('projects').insert({
        name: name,
        app_type: 'rebu',
        created_by: cloudUser.id,
        status: 'active'
      }).select().single();
      
      if (error) { alert('Fehler: ' + error.message); return; }
      
      await db.from('project_members').insert({
        project_id: projectData.id,
        user_id: cloudUser.id,
        role: 'owner'
      });
      
      await loadCloudProjects();
      await selectCloudProject(projectData.id);
    }
    
    async function uploadProjectToCloud() {
      if (!cloudUser) return alert('Bitte zuerst einloggen!');
      if (!state.projektId) return alert('Kein Projekt ausgew√§hlt!');
      
      const meta = state.projektMeta;
      const localId = state.projektId;
      
      // Projekt erstellen
      const { data: projectData, error } = await db.from('projects').insert({
        name: meta.titel || 'Unbenannt',
        subtitle: meta.untertitel || '',
        author: meta.autor || '',
        tagline: meta.tagline || '',
        logline: meta.logline || '',
        copyright: meta.copyright || '',
        cover_image: meta.titelbild || '',
        version_name: meta.fassung || 'Arbeitsfassung',
        version_date: meta.fassungsDatum || new Date().toISOString(),
        structure_type: meta.strukturTyp || 'akte',
        premiere_date: meta.premiere || null,
        venue: meta.spielort || '',
        app_type: 'rebu',
        created_by: cloudUser.id,
        status: 'active'
      }).select().single();
      
      if (error) { alert('Fehler: ' + error.message); return; }
      
      const cloudId = projectData.id;
      
      await db.from('project_members').insert({
        project_id: cloudId,
        user_id: cloudUser.id,
        role: 'owner'
      });
      
      // Figuren hochladen
      const figuren = load(KEYS.figuren(localId), []);
      console.log('Uploading', figuren.length, 'figures');
      for (let i = 0; i < figuren.length; i++) {
        const f = figuren[i];
        const { error } = await db.from('figures').insert({
          project_id: cloudId, name: f.name || '', abbreviation: f.kuerzel || '',
          description: f.beschreibung || '', want: f.want || '', need: f.need || '',
          sort_order: i, color: '#3b82f6'
        });
        if (error) console.error('Figure upload error:', error);
      }
      
      // Szenen hochladen
      const szenen = load(KEYS.szenen(localId), []);
      console.log('Uploading', szenen.length, 'scenes');
      for (let i = 0; i < szenen.length; i++) {
        const s = szenen[i];
        const { error } = await db.from('scenes').insert({
          project_id: cloudId, name: s.titel || '', number: s.nummer || '',
          title: s.titel || '', location: s.ort || '', time_of_day: s.zeit || '',
          scene_group: s.gruppe || '', summary: s.zusammenfassung || '',
          sort_order: i
        });
        if (error) console.error('Scene upload error:', error);
      }
      
      // Scene-Figures hochladen
      const { data: cloudScenes } = await db.from('scenes').select('id, number').eq('project_id', cloudId);
      const { data: cloudFigures } = await db.from('figures').select('id, name').eq('project_id', cloudId);
      
      for (const s of szenen) {
        const cloudScene = cloudScenes?.find(cs => cs.number === s.nummer);
        if (cloudScene && s.figuren) {
          for (const figurId of s.figuren) {
            const localFigur = figuren.find(f => f.id === figurId);
            const cloudFigur = cloudFigures?.find(cf => cf.name === localFigur?.name);
            if (cloudFigur) {
              await db.from('scene_figures').insert({
                project_id: cloudId, scene_id: cloudScene.id, figure_id: cloudFigur.id
              });
            }
          }
        }
      }
      
      // Textbuch hochladen
      const textbuch = load(KEYS.textbuch(localId), {});
      console.log('Uploading textbuch for', Object.keys(textbuch).length, 'scenes');
      for (const [szeneId, content] of Object.entries(textbuch)) {
        const localSzene = szenen.find(s => s.id === szeneId);
        const cloudScene = cloudScenes?.find(cs => cs.number === localSzene?.nummer);
        if (cloudScene) {
          const { error } = await db.from('scene_texts').insert({
            project_id: cloudId, scene_id: cloudScene.id, content: content
          });
          if (error) console.error('Textbuch upload error:', error);
        }
      }
      
      // Cues hochladen
      const cues = load(KEYS.cues(localId), []);
      console.log('Uploading', cues.length, 'cues');
      for (const c of cues) {
        const localSzene = szenen.find(s => s.id === c.szeneId);
        const cloudScene = cloudScenes?.find(cs => cs.number === localSzene?.nummer);
        const { error } = await db.from('cues').insert({
          project_id: cloudId, scene_id: cloudScene?.id || null,
          cue_type: c.typ || 'lx', cue_number: c.nummer || 0,
          description: c.beschreibung || '', duration: c.dauer || '',
          anchor_text: c.ankerText || ''
        });
        if (error) console.error('Cue upload error:', error);
      }
      
      // Kost√ºme hochladen
      const kostueme = load(KEYS.kostueme(localId), []);
      console.log('Uploading', kostueme.length, 'costumes');
      for (const k of kostueme) {
        const localFigur = figuren.find(f => f.id === k.figur);
        const cloudFigur = cloudFigures?.find(cf => cf.name === localFigur?.name);
        const { data: costumeData, error } = await db.from('costumes').insert({
          project_id: cloudId, figure_id: cloudFigur?.id || null,
          name: k.name || '', description: k.beschreibung || '', notes: k.notizen || ''
        }).select().single();
        if (error) console.error('Costume upload error:', error);
        
        // Costume-Scenes
        if (costumeData && k.szenen) {
          for (const szeneId of k.szenen) {
            const localSzene = szenen.find(s => s.id === szeneId);
            const cloudScene = cloudScenes?.find(cs => cs.number === localSzene?.nummer);
            if (cloudScene) {
              await db.from('costume_scenes').insert({
                costume_id: costumeData.id, scene_id: cloudScene.id
              });
            }
          }
        }
      }
      
      // Requisiten hochladen
      const requisiten = load(KEYS.requisiten(localId), []);
      console.log('Uploading', requisiten.length, 'props');
      for (const r of requisiten) {
        const { data: propData, error } = await db.from('props').insert({
          project_id: cloudId, name: r.name || '', description: r.beschreibung || ''
        }).select().single();
        if (error) console.error('Prop upload error:', error);
        
        if (propData && r.szenen) {
          for (const szeneId of r.szenen) {
            const localSzene = szenen.find(s => s.id === szeneId);
            const cloudScene = cloudScenes?.find(cs => cs.number === localSzene?.nummer);
            if (cloudScene) {
              await db.from('prop_scenes').insert({
                prop_id: propData.id, scene_id: cloudScene.id
              });
            }
          }
        }
      }
      
      // Medien hochladen
      const medien = load(KEYS.medien(localId), []);
      console.log('Uploading', medien.length, 'media');
      for (const m of medien) {
        const { error } = await db.from('media').insert({
          project_id: cloudId, name: m.name || '', media_type: m.typ || '',
          url: m.url || '', description: m.beschreibung || ''
        });
        if (error) console.error('Media upload error:', error);
      }
      
      // B√ºhnenbilder hochladen
      const buehne = load(KEYS.buehne(localId), []);
      console.log('Uploading', buehne.length, 'stage designs');
      for (const b of buehne) {
        const { error } = await db.from('stage_designs').insert({
          project_id: cloudId, name: b.name || '', image_url: b.bild || '',
          description: b.beschreibung || ''
        });
        if (error) console.error('Stage design upload error:', error);
      }
      
      // Fassungen hochladen
      const fassungen = load(KEYS.fassungen(localId), []);
      console.log('Uploading', fassungen.length, 'script versions');
      for (const f of fassungen) {
        const { error } = await db.from('script_versions').insert({
          project_id: cloudId, name: f.name || '', version_date: f.datum,
          content: f.textbuch || {}
        });
        if (error) console.error('Version upload error:', error);
      }
      
      // Lokales Projekt mit Cloud verkn√ºpfen
      let projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === localId);
      if (idx >= 0) {
        projekte[idx].cloudId = cloudId;
        save(KEYS.projekte, projekte);
      }
      
      currentCloudProjectId = cloudId;
      await loadCloudProjects();
      
      alert('‚úÖ Projekt in Cloud hochgeladen!');
      render();
    }
    
    // v2.2: √Ñnderungen zur Cloud synchronisieren (f√ºr bestehende Cloud-Projekte)
    let syncDebounceTimer = null;
    async function syncToCloud() {
      if (!cloudUser || !currentCloudProjectId || !isCloudMode) return;
      
      const cloudId = currentCloudProjectId;
      const meta = state.projektMeta;
      
      console.log('Syncing to cloud:', cloudId);
      
      // 1. Projekt-Meta updaten
      await db.from('projects').update({
        name: meta.titel || 'Unbenannt',
        subtitle: meta.untertitel || '',
        author: meta.autor || '',
        version_name: meta.fassung || 'Arbeitsfassung',
        structure_type: meta.strukturTyp || 'akte',
        premiere_date: meta.premiere || null,
        venue: meta.spielort || '',
        updated_at: new Date().toISOString()
      }).eq('id', cloudId);
      
      // 2. Figuren synchronisieren
      const localFiguren = state.figuren || [];
      const { data: cloudFigures } = await db.from('figures').select('*').eq('project_id', cloudId);
      
      // Neue Figuren hinzuf√ºgen
      for (let i = 0; i < localFiguren.length; i++) {
        const f = localFiguren[i];
        const existing = cloudFigures?.find(cf => cf.name === f.name);
        if (!existing) {
          await db.from('figures').insert({
            project_id: cloudId,
            name: f.name || '',
            abbreviation: f.kuerzel || '',
            description: f.beschreibung || '',
            want: f.want || '',
            need: f.need || '',
            sort_order: i,
            color: '#3b82f6'
          });
        } else {
          // Existierende Figur updaten
          await db.from('figures').update({
            abbreviation: f.kuerzel || '',
            description: f.beschreibung || '',
            want: f.want || '',
            need: f.need || '',
            sort_order: i
          }).eq('id', existing.id);
        }
      }
      
      // Gel√∂schte Figuren entfernen
      const localNames = localFiguren.map(f => f.name);
      for (const cf of (cloudFigures || [])) {
        if (!localNames.includes(cf.name)) {
          await db.from('figures').delete().eq('id', cf.id);
        }
      }
      
      // 3. Szenen synchronisieren
      const localSzenen = state.szenen || [];
      const { data: cloudScenes } = await db.from('scenes').select('*').eq('project_id', cloudId);
      
      // Neue Szenen hinzuf√ºgen
      for (let i = 0; i < localSzenen.length; i++) {
        const s = localSzenen[i];
        const existing = cloudScenes?.find(cs => cs.number === s.nummer);
        if (!existing) {
          await db.from('scenes').insert({
            project_id: cloudId,
            name: s.titel || '',
            number: s.nummer || '',
            title: s.titel || '',
            location: s.ort || '',
            time_of_day: s.zeit || '',
            scene_group: s.gruppe || '',
            summary: s.zusammenfassung || '',
            sort_order: i
          });
        } else {
          // Existierende Szene updaten
          await db.from('scenes').update({
            name: s.titel || '',
            title: s.titel || '',
            location: s.ort || '',
            time_of_day: s.zeit || '',
            scene_group: s.gruppe || '',
            summary: s.zusammenfassung || '',
            sort_order: i
          }).eq('id', existing.id);
        }
      }
      
      // Gel√∂schte Szenen entfernen
      const localNumbers = localSzenen.map(s => s.nummer);
      for (const cs of (cloudScenes || [])) {
        if (!localNumbers.includes(cs.number)) {
          await db.from('scenes').delete().eq('id', cs.id);
        }
      }
      
      console.log('Cloud sync completed');
    }
    
    // Debounced sync (wartet 2 Sekunden nach letzter √Ñnderung)
    function scheduleSyncToCloud() {
      if (syncDebounceTimer) clearTimeout(syncDebounceTimer);
      syncDebounceTimer = setTimeout(() => {
        syncToCloud();
      }, 2000);
    }
    
    // v2.0: Einfaches Cloud-Projekt erstellen (mit Prompt)
    async function createCloudProjectSimple() {
      if (!cloudUser) {
        state.showCloudModal = true;
        render();
        return alert('Bitte zuerst einloggen!');
      }
      
      const name = prompt('Name f√ºr neues Cloud-Projekt:');
      if (!name || !name.trim()) return;
      
      const { data: projectData, error } = await db.from('projects').insert({
        name: name.trim(),
        app_type: 'rebu',
        created_by: cloudUser.id,
        status: 'active'
      }).select().single();
      
      if (error) { alert('Fehler: ' + error.message); return; }
      
      await db.from('project_members').insert({
        project_id: projectData.id,
        user_id: cloudUser.id,
        role: 'owner'
      });
      
      await loadCloudProjects();
      await selectCloudProject(projectData.id);
      
      alert('‚òÅÔ∏è Cloud-Projekt "' + name.trim() + '" erstellt!');
    }
    
    // v2.0: Explizit von Cloud neu laden (√ºberschreibt lokale Daten)
    async function forceCloudSync() {
      if (!currentCloudProjectId) return alert('Kein Cloud-Projekt aktiv!');
      
      const confirm_msg = 'üîÑ Von Cloud neu laden?\n\nAlle lokalen √Ñnderungen werden mit den Cloud-Daten √ºberschrieben!';
      if (!confirm(confirm_msg)) return;
      
      const localId = state.projektId;
      await syncFromCloud(currentCloudProjectId, localId);
      loadProjektDaten();
      render();
      
      alert('‚úÖ Daten von Cloud geladen!');
    }
    
    // v2.0: Wrapper f√ºr uploadProjectToCloud
    async function uploadToCloud() {
      if (!cloudUser) {
        state.showCloudModal = true;
        render();
        return alert('Bitte zuerst einloggen!');
      }
      
      const projektName = state.projektMeta?.titel || 'Unbenannt';
      const confirm_msg = `‚¨ÜÔ∏è Projekt "${projektName}" in Cloud hochladen?\n\nDas Projekt wird mit der Cloud synchronisiert und auf allen Ger√§ten verf√ºgbar.`;
      if (!confirm(confirm_msg)) return;
      
      await uploadProjectToCloud();
    }
    
    async function deleteCloudProject(cloudId) {
      if (!confirm('Cloud-Projekt wirklich l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) return;
      
      const { error } = await db.from('projects').delete().eq('id', cloudId);
      if (error) { alert('Fehler: ' + error.message); return; }
      
      await loadCloudProjects();
      render();
    }

    // ============================================
    // PROJEKT MANAGEMENT
    // ============================================
    function initProjekt() {
      const projekte = load(KEYS.projekte, []);
      let projektId = load(KEYS.aktuellesProjekt);
      
      if (!projektId || projekte.length === 0) {
        projektId = genId();
        const neuProjekt = { id: projektId, name: 'Demo-Projekt', erstellt: new Date().toISOString() };
        save(KEYS.projekte, [neuProjekt]);
        save(KEYS.aktuellesProjekt, projektId);
        
        // Demo-Figuren
        const demoFiguren = [
          { id: genId(), name: 'MARTHE', kuerzel: 'MA', beschreibung: 'Die Marketenderin', want: '√úberleben', need: 'Liebe' },
          { id: genId(), name: 'MELK', kuerzel: 'ME', beschreibung: 'Ein K√∂hlerjunge', want: 'Das Geheimnis finden', need: 'Zugeh√∂rigkeit' },
          { id: genId(), name: 'GRIT', kuerzel: 'GR', beschreibung: 'Magd im Gasthaus', want: 'Freiheit', need: 'Anerkennung' },
        ];
        save(KEYS.figuren(projektId), demoFiguren);
        
        // Demo-Szenen
        const demoSzenen = [
          { id: genId(), nummer: '1.1', titel: 'Prolog', ort: 'Marktplatz', zeit: 'Morgen', figuren: [demoFiguren[0].id], gruppe: '1', zusammenfassung: 'Marthe beginnt ihren Tag. Wir ahnen, dass etwas nicht stimmt.' },
          { id: genId(), nummer: '1.2', titel: 'Die Ankunft', ort: 'Dorfplatz', zeit: 'Mittag', figuren: [demoFiguren[0].id, demoFiguren[1].id], gruppe: '1', zusammenfassung: 'Melk kommt an. Marthe scheint ihn erwartet zu haben.' },
          { id: genId(), nummer: '2.1', titel: 'Im Gasthaus', ort: 'Gasthaus zum Sternen', zeit: 'Abend', figuren: [demoFiguren[1].id, demoFiguren[2].id], gruppe: '2', zusammenfassung: 'Melk trifft auf Grit. Ein Geheimnis wird angedeutet.' },
        ];
        save(KEYS.szenen(projektId), demoSzenen);
        
        // v1.2: Demo-Textbuch mit neuem Dialog-Format (Grid)
        const demoTextbuch = {};
        demoTextbuch[demoSzenen[0].id] = `<p class="format-szene-titel">1.1 Prolog</p>
<p class="format-regieanweisung">(Der Marktplatz bei Sonnenaufgang. Nebel h√§ngt √ºber dem Dorf. MARTHE tritt langsam auf, einen Korb tragend.)</p>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">So fr√ºh schon wach, und doch zu sp√§t. Die Welt dreht sich, ob ich will oder nicht.</span></div>
<p class="format-regieanweisung">(Sie stellt den Korb ab und blickt zum Himmel.)</p>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">Was bringt der Tag? Nichts Gutes, f√ºrcht ich. Nichts Gutes seit langem.</span></div>
<p class="format-lied">üéµ Der Morgen graut, die Nacht vergeht,
und niemand weiss, wie's weitergeht.
Was gestern war, ist l√§ngst vorbei,
was morgen kommt ‚Äì wer ist dabei?</p>
<p class="format-regieanweisung">(MARTHE nimmt den Korb wieder auf und geht langsam ab.)</p>`;

        demoTextbuch[demoSzenen[1].id] = `<p class="format-szene-titel">1.2 Die Ankunft</p>
<p class="format-regieanweisung">(Dorfplatz. MARTHE wartet. MELK kommt von rechts, verstaubt und ersch√∂pft.)</p>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">Da bist du ja. Ich hab dich erwartet.</span></div>
<div class="format-dialog"><span class="figur-name">MELK:</span><span class="dialog-text">Mich? Woher wusstest du‚Äî</span></div>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">Ich weiss <span class="format-gestrichen">einiges</span><span class="format-ergaenzung">vieles</span>. Mehr als mir lieb ist.</span></div>
<p class="format-regieanweisung">(Sie mustert ihn von Kopf bis Fuss.)</p>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">Du siehst aus wie einer, der etwas sucht. Etwas, das er besser nicht finden sollte.</span></div>`;

        save(KEYS.textbuch(projektId), demoTextbuch);
        
        // Demo-Cues (mit Ankertexten)
        const demoCues = [
          { id: genId(), typ: 'lx', nummer: 1, szeneId: demoSzenen[0].id, beschreibung: 'Morgend√§mmerung - langsamer Fade up', dauer: '10s', ankerText: '(Der Marktplatz bei Sonnenaufgang. Nebel h√§ngt √ºber dem Dorf. MARTHE tritt langsam auf, einen Korb tragend.)' },
          { id: genId(), typ: 'q', nummer: 1, szeneId: demoSzenen[0].id, beschreibung: 'Vogelgezwitscher, leise', dauer: 'Loop', ankerText: '(Sie stellt den Korb ab und blickt zum Himmel.)' },
          { id: genId(), typ: 'lx', nummer: 2, szeneId: demoSzenen[1].id, beschreibung: 'Tageslicht - heller', dauer: '3s', ankerText: '(Dorfplatz. MARTHE wartet. MELK kommt von rechts, verstaubt und ersch√∂pft.)' },
        ];
        save(KEYS.cues(projektId), demoCues);
        
        // Demo-Kost√ºme
        const demoKostueme = [
          { id: genId(), name: 'Marthe - Grundkost√ºm', figur: demoFiguren[0].id, beschreibung: 'Einfaches Leinenkleid, Sch√ºrze, Kopftuch', szenen: [demoSzenen[0].id, demoSzenen[1].id], notizen: '' },
          { id: genId(), name: 'Melk - Wanderkleidung', figur: demoFiguren[1].id, beschreibung: 'Zerrissene Hose, Lederwams, Hut', szenen: [demoSzenen[1].id, demoSzenen[2].id], notizen: 'Muss verstaubt aussehen' },
        ];
        save(KEYS.kostueme(projektId), demoKostueme);
        
        // Projekt-Meta
        const meta = {
          titel: 'Brandboden',
          untertitel: 'oder Wie Melk die Kohle aus dem Feuer holt',
          autor: 'Ueli Blum',
          tagline: 'Ein sagenhaftes Wandertheater',
          logline: 'Ein K√∂hlerjunge sucht nach dem Geheimnis des kalten Herzens.',
          fassung: 'Arbeitsfassung',
          fassungsDatum: new Date().toISOString()
        };
        save(KEYS.projektMeta(projektId), meta);
      }
      
      state.projektId = projektId || projekte[0]?.id;
      loadProjektDaten();
    }

    function loadProjektDaten() {
      if (!state.projektId) return;
      
      // Cloud-ID setzen wenn das Projekt mit Cloud verkn√ºpft ist
      const projekte = load(KEYS.projekte, []);
      const projekt = projekte.find(p => p.id === state.projektId);
      if (projekt?.cloudId) {
        currentCloudProjectId = projekt.cloudId;
      } else if (state.projektId && state.projektId.startsWith && state.projektId.startsWith('cloud_')) {
        currentCloudProjectId = state.projektId.replace('cloud_', '');
      } else {
        currentCloudProjectId = null;
      }
      
      // Default-Werte f√ºr neues Projekt
      const defaultMeta = {
        titel: 'Neues Projekt',
        untertitel: '',
        autor: '',
        tagline: '',
        logline: '',
        copyright: '',
        titelbild: '',
        fassung: 'Arbeitsfassung',
        fassungsDatum: new Date().toISOString(),
        eigeneGruppen: ['Erster Akt'],
        premiere: '',
        spielort: ''
      };
      
      state.projektMeta = load(KEYS.projektMeta(state.projektId), defaultMeta);
      state.figuren = load(KEYS.figuren(state.projektId), []);
      state.szenen = load(KEYS.szenen(state.projektId), []);
      state.textbuch = load(KEYS.textbuch(state.projektId), {});
      state.cues = load(KEYS.cues(state.projektId), []);
      state.fassungen = load(KEYS.fassungen(state.projektId), []);
      state.requisiten = load(KEYS.requisiten(state.projektId), []);
      state.kostueme = load(KEYS.kostueme(state.projektId), []);
      state.medien = load(KEYS.medien(state.projektId), []);
      state.buehne = load(KEYS.buehne(state.projektId), []);
      
      if (state.szenen.length > 0 && !state.aktiveSzene) {
        state.aktiveSzene = state.szenen[0].id;
      }
      
      // v2.0: Migration von altem strukturTyp zu neuem System
      if (state.projektMeta.strukturTyp && !state.projektMeta.eigeneGruppen) {
        const altVorlage = state.projektMeta.strukturTyp;
        state.projektMeta.strukturVorlage = altVorlage;
        // Extrahiere existierende Gruppen aus Szenen
        const existierendeGruppen = [...new Set(state.szenen.map(s => s.gruppe).filter(Boolean))];
        if (existierendeGruppen.length > 0) {
          state.projektMeta.eigeneGruppen = existierendeGruppen;
        } else {
          state.projektMeta.eigeneGruppen = STRUKTUR_VORLAGEN[altVorlage]?.vorgeschlageneGruppen?.slice(0, 3) || ['Teil 1'];
        }
        delete state.projektMeta.strukturTyp;
        saveProjektDaten();
      }
      
      // Sicherstellen dass eigeneGruppen existiert
      if (!state.projektMeta.eigeneGruppen) {
        state.projektMeta.eigeneGruppen = ['Erster Akt'];
      }
    }
    
    // v2.0: Aktuelle Gruppen des Projekts holen (eigene + aus Szenen extrahierte)
    function getAktuelleGruppen() {
      const eigene = state.projektMeta.eigeneGruppen || [];
      // Auch Gruppen aus Szenen extrahieren die evtl. noch nicht in eigeneGruppen sind
      const ausszenen = [...new Set(state.szenen.map(s => s.gruppe).filter(Boolean))];
      const alle = [...new Set([...eigene, ...ausszenen])];
      return alle.length > 0 ? alle : ['Teil 1'];
    }
    
    // v2.0: Neue Gruppe hinzuf√ºgen
    function addGruppe(name) {
      if (!name || name.trim() === '') return;
      if (!state.projektMeta.eigeneGruppen) state.projektMeta.eigeneGruppen = [];
      if (!state.projektMeta.eigeneGruppen.includes(name.trim())) {
        state.projektMeta.eigeneGruppen.push(name.trim());
        saveProjektDaten();
        render();
      }
    }
    
    // v2.0: Gruppe umbenennen
    function renameGruppe(altName, neuName) {
      if (!neuName || neuName.trim() === '') return;
      const idx = state.projektMeta.eigeneGruppen?.indexOf(altName);
      if (idx !== -1) {
        state.projektMeta.eigeneGruppen[idx] = neuName.trim();
        // Auch alle Szenen mit dieser Gruppe aktualisieren
        state.szenen.forEach(s => {
          if (s.gruppe === altName) s.gruppe = neuName.trim();
        });
        saveProjektDaten();
        render();
      }
    }
    
    // v2.0: Gruppe l√∂schen (Szenen bleiben, bekommen 'Ohne Zuordnung')
    function deleteGruppe(name) {
      const idx = state.projektMeta.eigeneGruppen?.indexOf(name);
      if (idx !== -1) {
        state.projektMeta.eigeneGruppen.splice(idx, 1);
        saveProjektDaten();
        render();
      }
    }
    
    // v2.0: Struktur-Vorlage anwenden (√ºberschreibt eigeneGruppen)
    function applyStrukturVorlage(vorlageKey) {
      const vorlage = STRUKTUR_VORLAGEN[vorlageKey];
      if (vorlage) {
        state.projektMeta.strukturVorlage = vorlageKey;
        state.projektMeta.eigeneGruppen = [...vorlage.vorgeschlageneGruppen];
        saveProjektDaten();
        render();
      }
    }
    
    // v2.0: Gruppe nach oben/unten verschieben
    function moveGruppe(name, direction) {
      const gruppen = state.projektMeta.eigeneGruppen || [];
      const idx = gruppen.indexOf(name);
      if (idx === -1) return;
      
      const newIdx = idx + direction;
      if (newIdx < 0 || newIdx >= gruppen.length) return;
      
      // Tauschen
      const temp = gruppen[idx];
      gruppen[idx] = gruppen[newIdx];
      gruppen[newIdx] = temp;
      
      saveProjektDaten();
      render();
    }
    
    // Szenen nach Gruppe und Nummer sortieren
    function sortSzenen() {
      state.szenen.sort((a, b) => {
        // Erst nach Gruppe sortieren
        const gruppeA = parseInt(a.gruppe) || 1;
        const gruppeB = parseInt(b.gruppe) || 1;
        if (gruppeA !== gruppeB) return gruppeA - gruppeB;
        
        // Dann nach Nummer sortieren
        const nummerA = parseFloat(a.nummer) || 0;
        const nummerB = parseFloat(b.nummer) || 0;
        return nummerA - nummerB;
      });
    }

    function saveProjektDaten() {
      if (!state.projektId) return;
      
      save(KEYS.projektMeta(state.projektId), state.projektMeta);
      save(KEYS.figuren(state.projektId), state.figuren);
      save(KEYS.szenen(state.projektId), state.szenen);
      save(KEYS.textbuch(state.projektId), state.textbuch);
      save(KEYS.cues(state.projektId), state.cues);
      save(KEYS.fassungen(state.projektId), state.fassungen);
      save(KEYS.requisiten(state.projektId), state.requisiten);
      save(KEYS.kostueme(state.projektId), state.kostueme);
      save(KEYS.medien(state.projektId), state.medien);
      save(KEYS.buehne(state.projektId), state.buehne);
      
      // v2.2: Auto-Sync zur Cloud (wenn Cloud-Projekt)
      scheduleSyncToCloud();
    }
    
    // ============================================
    // PROJEKT-VERWALTUNG (NEU v1.4)
    // ============================================
    let editingProjekt = null;
    
    function wechsleProjekt(projektId) {
      if (projektId === state.projektId) return;
      
      // Aktuelles Projekt speichern
      saveProjektDaten();
      
      // Neues Projekt laden
      save(KEYS.aktuellesProjekt, projektId);
      state.projektId = projektId;
      state.aktiveSzene = null;
      loadProjektDaten();
      
      render();
    }
    
    function openProjektModal(projektId = null) {
      if (projektId) {
        // Bestehendes Projekt bearbeiten
        const projekte = load(KEYS.projekte, []);
        const projekt = projekte.find(p => p.id === projektId);
        editingProjekt = projekt ? { ...projekt, ...state.projektMeta } : null;
      } else {
        // Neues Projekt - Warnung anzeigen wenn aktuelles Projekt Daten hat
        const hatDaten = state.szenen.length > 0 || state.figuren.length > 0 || state.cues.length > 0;
        const istCloudProjekt = !!currentCloudProjectId;
        
        if (hatDaten) {
          let warnung;
          if (istCloudProjekt) {
            // Cloud-Projekt: Daten sind sicher
            warnung = `üìù Neues Projekt erstellen\n\n` +
              `Das aktuelle Projekt "${state.projektMeta.titel || 'Unbenannt'}" enth√§lt:\n` +
              `‚Ä¢ ${state.szenen.length} Szenen\n` +
              `‚Ä¢ ${state.figuren.length} Figuren\n` +
              `‚Ä¢ ${state.cues.length} Cues\n\n` +
              `‚òÅÔ∏è Das Projekt ist in der Cloud gespeichert und bleibt erhalten.\n\n` +
              `Neues Projekt erstellen?`;
          } else {
            // Nur lokal: Warnung anzeigen
            warnung = `‚ö†Ô∏è ACHTUNG: Neues Projekt erstellen\n\n` +
              `Das aktuelle Projekt "${state.projektMeta.titel || 'Unbenannt'}" enth√§lt:\n` +
              `‚Ä¢ ${state.szenen.length} Szenen\n` +
              `‚Ä¢ ${state.figuren.length} Figuren\n` +
              `‚Ä¢ ${state.cues.length} Cues\n\n` +
              `Diese Daten werden nur lokal im Browser gespeichert.\n` +
              `Wenn der Browser-Cache gel√∂scht wird, sind sie WEG!\n\n` +
              `üì• Empfehlung: Erst EXPORTIEREN (Projekt-Backup),\n` +
              `dann neues Projekt erstellen.\n\n` +
              `Trotzdem fortfahren?`;
          }
          
          if (!confirm(warnung)) {
            return;
          }
        }
        
        // Neues Projekt
        editingProjekt = {
          id: null,
          name: '',
          titel: '',
          untertitel: '',
          autor: '',
          fassung: 'Arbeitsfassung',
          strukturTyp: 'akte'
        };
      }
      state.showProjektModal = true;
      render();
    }
    
    function renderProjektModal() {
      const p = editingProjekt || {};
      const isEdit = !!p.id;
      const apiKey = localStorage.getItem('nina_rebu_api_key') || '';
      
      return `
        <div class="modal-overlay" onclick="closeModal('showProjektModal')">
          <div class="modal-content" style="max-width: 650px; max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚öôÔ∏è¬è Projekt-Einstellungen' : 'üìÅ Neues Projekt'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showProjektModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <!-- Basis-Info -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Projektname *</label>
                <input type="text" id="projekt-name" value="${p.name || p.titel || ''}" placeholder="Mein Theaterst√ºck">
                <p class="text-xs text-gray-400 mt-1">Wird in der Projektliste angezeigt</p>
              </div>
              
              <!-- Titelblatt-Bereich -->
              <div class="border rounded-lg p-4 mb-4 bg-gray-50">
                <h3 class="text-sm font-semibold text-gray-600 mb-3">üìÑ Titelblatt</h3>
                
                <div class="grid grid-cols-2 gap-4 mb-3">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">St√ºcktitel</label>
                    <input type="text" id="projekt-titel" value="${p.titel || ''}" placeholder="Romeo und Julia">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Untertitel</label>
                    <input type="text" id="projekt-untertitel" value="${p.untertitel || ''}" placeholder="Eine Trag√∂die in f√ºnf Akten">
                  </div>
                </div>
                
                <div class="grid grid-cols-2 gap-4 mb-3">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Autor:in</label>
                    <input type="text" id="projekt-autor" value="${p.autor || ''}" placeholder="William Shakespeare">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Copyright</label>
                    <input type="text" id="projekt-copyright" value="${p.copyright || ''}" placeholder="¬© 2024 Theater XY">
                  </div>
                </div>
                
                <div class="mb-3">
                  <label class="block text-xs font-medium text-gray-700 mb-1">Tagline</label>
                  <input type="text" id="projekt-tagline" value="${p.tagline || ''}" placeholder="Kurzer Werbespruch (1 Zeile)">
                </div>
                
                <div class="mb-3">
                  <label class="block text-xs font-medium text-gray-700 mb-1">Logline</label>
                  <textarea id="projekt-logline" rows="2" placeholder="Kurze Zusammenfassung der Handlung (2-3 S√§tze)">${p.logline || ''}</textarea>
                </div>
                
                <div>
                  <label class="block text-xs font-medium text-gray-700 mb-1">Titelbild</label>
                  <div class="flex gap-2 items-center">
                    ${p.titelbild ? `
                      <img src="${p.titelbild}" class="w-16 h-16 object-cover rounded border" id="titelbild-preview">
                      <button class="btn btn-xs btn-outline" onclick="removeTitelbild()">√ó</button>
                    ` : `<div id="titelbild-preview-container"></div>`}
                    <input type="file" id="projekt-titelbild" accept="image/*" class="text-xs flex-1"
                           onchange="handleTitelbildUpload(this)">
                  </div>
                </div>
              </div>
              
              <!-- Produktion -->
              <div class="border rounded-lg p-4 mb-4 bg-gray-50">
                <h3 class="text-sm font-semibold text-gray-600 mb-3">üé≠ Produktion</h3>
                
                <div class="grid grid-cols-3 gap-4 mb-3">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Fassung</label>
                    <input type="text" id="projekt-fassung" value="${p.fassung || 'Arbeitsfassung'}" placeholder="Arbeitsfassung">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Premiere</label>
                    <input type="date" id="projekt-premiere" value="${p.premiere || ''}">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Spielort</label>
                    <input type="text" id="projekt-spielort" value="${p.spielort || ''}" placeholder="Stadttheater">
                  </div>
                </div>
                
                <!-- v2.0: Flexibles Struktur-System -->
                <div class="border rounded-lg p-4 mb-4 bg-purple-50">
                  <h3 class="text-sm font-semibold text-gray-600 mb-3">üé≠ St√ºckstruktur</h3>
                  
                  <!-- Vorlage w√§hlen -->
                  <div class="mb-3">
                    <label class="block text-xs font-medium text-gray-700 mb-1">Vorlage anwenden (optional)</label>
                    <div class="flex gap-2">
                      <select id="projekt-struktur-vorlage" class="flex-1 text-sm">
                        <option value="">-- Vorlage w√§hlen --</option>
                        ${Object.entries(STRUKTUR_VORLAGEN).map(([key, val]) => `
                          <option value="${key}">${val.name}</option>
                        `).join('')}
                      </select>
                      <button type="button" class="btn btn-sm btn-outline" onclick="
                        const vorlage = document.getElementById('projekt-struktur-vorlage').value;
                        if (vorlage && confirm('Soll die Vorlage angewendet werden? Deine aktuellen Gruppen werden ersetzt.')) {
                          applyStrukturVorlage(vorlage);
                          document.getElementById('projekt-struktur-vorlage').value = '';
                        }
                      ">Anwenden</button>
                    </div>
                    <p class="text-xs text-gray-400 mt-1">Vorlagen sind nur Anregungen - du kannst alles frei √§ndern!</p>
                  </div>
                  
                  <!-- Eigene Gruppen/Akte -->
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Deine Akte/Teile/Gruppen</label>
                    <div id="eigene-gruppen-liste" class="space-y-1 mb-2 max-h-40 overflow-y-auto">
                      ${(state.projektMeta.eigeneGruppen || ['Erster Akt']).map((g, idx) => `
                        <div class="flex items-center gap-1 bg-white rounded px-2 py-1 text-sm">
                          <span class="text-gray-400 text-xs w-4">${idx + 1}.</span>
                          <input type="text" value="${g}" class="flex-1 border-0 bg-transparent text-sm p-0"
                                 onchange="renameGruppe('${g}', this.value)">
                          <button type="button" class="text-gray-400 hover:text-blue-600" onclick="moveGruppe('${g}', -1)" title="Nach oben">‚ñ≤</button>
                          <button type="button" class="text-gray-400 hover:text-blue-600" onclick="moveGruppe('${g}', 1)" title="Nach unten">‚ñº</button>
                          <button type="button" class="text-gray-400 hover:text-red-600" onclick="if(confirm('Gruppe l√∂schen?')) deleteGruppe('${g}')" title="L√∂schen">‚úï</button>
                        </div>
                      `).join('')}
                    </div>
                    <div class="flex gap-2">
                      <input type="text" id="neue-gruppe-input" class="flex-1 text-sm" placeholder="Neue Gruppe hinzuf√ºgen...">
                      <button type="button" class="btn btn-sm btn-primary" onclick="
                        const input = document.getElementById('neue-gruppe-input');
                        if (input.value.trim()) {
                          addGruppe(input.value.trim());
                          input.value = '';
                        }
                      ">+ Hinzuf√ºgen</button>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- KI-Einstellungen -->
              <div class="border rounded-lg p-4 mb-4 bg-blue-50">
                <h3 class="text-sm font-semibold text-gray-600 mb-3">ü§ñ KI-Assistent</h3>
                <div>
                  <label class="block text-xs font-medium text-gray-700 mb-1">Anthropic API Key</label>
                  <div class="api-key-row">
                    <input type="password" id="projekt-apikey" value="${apiKey}" 
                           placeholder="sk-ant-api03-..." class="font-mono text-xs flex-1"
                           onchange="localStorage.setItem('nina_rebu_api_key', this.value); apiKeyStatus = 'idle'; render();">
                    <button class="api-test-btn ${apiKeyStatus}" 
                            onclick="testApiKey()"
                            ${!apiKey || apiKeyStatus === 'testing' ? 'disabled' : ''}>
                      ${apiKeyStatus === 'testing' ? '‚è≥' : apiKeyStatus === 'success' ? '‚úì OK' : 'üîç Testen'}
                    </button>
                  </div>
                  ${apiKeyStatus === 'success' ? `
                    <div class="api-status success">‚úì API-Key funktioniert!</div>
                  ` : ''}
                  ${apiKeyStatus === 'error' ? `
                    <div class="api-status error">‚úó ${apiKeyError || 'Key ung√ºltig'}</div>
                  ` : ''}
                  ${apiKey && apiKeyStatus === 'idle' ? `
                    <div class="api-status neutral">Key eingegeben ‚Äì klicke "Testen" zur Pr√ºfung</div>
                  ` : ''}
                  <p class="text-xs text-gray-400 mt-2">
                    üîí Der Key wird nur lokal im Browser gespeichert, nie √ºbertragen.
                    <br><a href="https://console.anthropic.com/settings/keys" target="_blank" rel="noopener" class="text-blue-500 hover:underline">‚Üí API-Key erstellen</a>
                  </p>
                </div>
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `
                  <button class="btn btn-danger" onclick="deleteProjekt('${p.id}')">üóëÔ∏è¬è L√∂schen</button>
                ` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showProjektModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveProjekt()">üíæ ${isEdit ? 'Speichern' : 'Erstellen'}</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Titelbild-Handling
    let pendingTitelbild = null;
    
    function handleTitelbildUpload(input) {
      const file = input.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        pendingTitelbild = e.target.result;
        // Preview zeigen
        let preview = document.getElementById('titelbild-preview');
        if (!preview) {
          const container = document.getElementById('titelbild-preview-container');
          if (container) {
            container.innerHTML = '<img id="titelbild-preview" class="w-16 h-16 object-cover rounded border">';
            preview = document.getElementById('titelbild-preview');
          }
        }
        if (preview) preview.src = pendingTitelbild;
      };
      reader.readAsDataURL(file);
    }
    
    function removeTitelbild() {
      pendingTitelbild = '';
      if (editingProjekt) editingProjekt.titelbild = '';
      render();
    }
    
    function saveProjekt() {
      const name = document.getElementById('projekt-name').value.trim();
      if (!name) {
        alert('Bitte einen Projektnamen eingeben.');
        return;
      }
      
      // API-Key wird jetzt direkt im onchange gespeichert
      // Hier nur noch sicherstellen, dass er aktuell ist
      const apiKeyInput = document.getElementById('projekt-apikey');
      if (apiKeyInput) {
        const apiKey = apiKeyInput.value.trim();
        if (apiKey) {
          localStorage.setItem('nina_rebu_api_key', apiKey);
        }
      }
      
      const projektDaten = {
        titel: document.getElementById('projekt-titel').value.trim() || name,
        untertitel: document.getElementById('projekt-untertitel').value.trim(),
        autor: document.getElementById('projekt-autor').value.trim(),
        copyright: document.getElementById('projekt-copyright')?.value.trim() || '',
        tagline: document.getElementById('projekt-tagline')?.value.trim() || '',
        logline: document.getElementById('projekt-logline')?.value.trim() || '',
        titelbild: pendingTitelbild !== null ? pendingTitelbild : (editingProjekt?.titelbild || ''),
        fassung: document.getElementById('projekt-fassung').value.trim() || 'Arbeitsfassung',
        premiere: document.getElementById('projekt-premiere').value,
        spielort: document.getElementById('projekt-spielort').value.trim(),
        // v2.0: eigeneGruppen werden direkt √ºber addGruppe/renameGruppe/deleteGruppe ge√§ndert
        fassungsDatum: new Date().toISOString()
      };
      
      const projekte = load(KEYS.projekte, []);
      
      if (editingProjekt?.id) {
        // Bestehendes Projekt aktualisieren
        const idx = projekte.findIndex(p => p.id === editingProjekt.id);
        if (idx !== -1) {
          projekte[idx].name = name;
        }
        save(KEYS.projekte, projekte);
        
        // Meta-Daten aktualisieren
        state.projektMeta = { ...state.projektMeta, ...projektDaten };
        saveProjektDaten();
      } else {
        // Neues Projekt erstellen
        const neueId = genId();
        projekte.push({
          id: neueId,
          name: name,
          erstellt: new Date().toISOString()
        });
        save(KEYS.projekte, projekte);
        
        // Standard-Szene f√ºr neues Projekt erstellen
        const startSzeneId = genId();
        // v2.0: Erste Gruppe aus eigeneGruppen verwenden (falls vorhanden)
        const ersteGruppe = state.projektMeta.eigeneGruppen?.[0] || 'Erster Akt';
        const startSzene = {
          id: startSzeneId,
          nummer: '1.1',
          titel: 'Start',
          gruppe: ersteGruppe,
          ort: '',
          zeit: '',
          zusammenfassung: '',
          figuren: []
        };
        
        // v2.0: eigeneGruppen initialisieren falls noch nicht vorhanden
        if (!projektDaten.eigeneGruppen) {
          projektDaten.eigeneGruppen = ['Erster Akt'];
        }
        
        // Daten f√ºr neues Projekt speichern
        save(KEYS.projektMeta(neueId), projektDaten);
        save(KEYS.figuren(neueId), []);
        save(KEYS.szenen(neueId), [startSzene]);  // Mit Start-Szene!
        save(KEYS.textbuch(neueId), { [startSzeneId]: '<p class="format-standard"><br></p>' });
        save(KEYS.cues(neueId), []);
        save(KEYS.fassungen(neueId), []);
        save(KEYS.requisiten(neueId), []);
        save(KEYS.kostueme(neueId), []);
        save(KEYS.medien(neueId), []);
        save(KEYS.buehne(neueId), []);
        
        // Zum neuen Projekt wechseln
        wechsleProjekt(neueId);
      }
      
      closeModal('showProjektModal');
      pendingTitelbild = null;
    }
    
    function deleteProjekt(projektId) {
      const projekte = load(KEYS.projekte, []);
      
      if (projekte.length <= 1) {
        alert('Das letzte Projekt kann nicht gel√∂scht werden.');
        return;
      }
      
      const projekt = projekte.find(p => p.id === projektId);
      if (!confirm(`Projekt "${projekt?.name}" wirklich l√∂schen?\n\nAlle Daten (Szenen, Figuren, Cues, etc.) werden unwiderruflich gel√∂scht!`)) {
        return;
      }
      
      // Projekt aus Liste entfernen
      const neueProjekte = projekte.filter(p => p.id !== projektId);
      save(KEYS.projekte, neueProjekte);
      
      // Projekt-Daten l√∂schen (optional, localStorage Keys bleiben, aber sind verwaist)
      localStorage.removeItem(KEYS.projektMeta(projektId));
      localStorage.removeItem(KEYS.figuren(projektId));
      localStorage.removeItem(KEYS.szenen(projektId));
      localStorage.removeItem(KEYS.textbuch(projektId));
      localStorage.removeItem(KEYS.cues(projektId));
      localStorage.removeItem(KEYS.fassungen(projektId));
      localStorage.removeItem(KEYS.requisiten(projektId));
      localStorage.removeItem(KEYS.kostueme(projektId));
      localStorage.removeItem(KEYS.medien(projektId));
      localStorage.removeItem(KEYS.buehne(projektId));
      
      // Zu anderem Projekt wechseln (defensiv: nur wenn neueProjekte nicht leer)
      if (state.projektId === projektId && neueProjekte.length) {
        wechsleProjekt(neueProjekte[0].id);
      }
      
      closeModal('showProjektModal');
    }

    // ============================================
    // DRAMERA IMPORT/EXPORT
    // ============================================
    function importFromDramera(jsonData) {
      try {
        const dramera = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
        
        if (dramera.data) {
          const d = dramera.data;
          state.projektMeta.titel = d.projektName || state.projektMeta.titel;
          
          if (d.autor) {
            state.projektMeta.autor = d.autor.name || '';
          }
          
          if (d.fundament?.titel) {
            const t = d.fundament.titel;
            if (typeof t === 'object') {
              state.projektMeta.titel = t.titel || state.projektMeta.titel;
              state.projektMeta.untertitel = t.untertitel || '';
              state.projektMeta.tagline = t.tagline || '';
            }
          }
          
          if (d.fundament?.logline) {
            state.projektMeta.logline = typeof d.fundament.logline === 'object' 
              ? d.fundament.logline.text 
              : d.fundament.logline;
          }
          
          // Figuren
          if (d.figuren && d.figuren.length > 0) {
            state.figuren = d.figuren.map(f => ({
              id: f.id || genId(),
              name: (f.name || 'Unbenannt').toUpperCase(),
              kuerzel: f.kuerzel || f.name?.substring(0, 2).toUpperCase() || 'XX',
              beschreibung: f.beschreibung || f.wesen || '',
              want: f.want || f.wantExternal || '',
              need: f.need || f.needInternal || '',
              wunde: f.wunde || '',
              geheimnis: f.geheimnisse || '',
            }));
          }
          
          // Szenen
          if (d.felder && d.felder.length > 0) {
            state.szenen = d.felder.map((f, idx) => ({
              id: f.id || genId(),
              nummer: `${Math.floor(idx / 5) + 1}.${(idx % 5) + 1}`,
              titel: f.titel || `Szene ${idx + 1}`,
              ort: f.ort || '',
              zeit: f.zeit || '',
              figuren: f.figuren || [],
              zusammenfassung: f.zusammenfassung || '',
            }));
            
            d.felder.forEach(f => {
              if (f.inhalt) {
                state.textbuch[f.id] = f.inhalt;
              }
            });
            
            if (state.szenen.length > 0) {
              state.aktiveSzene = state.szenen[0].id;
            }
          }
          
          // Recherche als Medien
          if (d.recherche && d.recherche.length > 0) {
            state.medien = d.recherche.map(r => ({
              id: r.id || genId(),
              typ: r.typ || 'text',
              titel: r.titel || 'Material',
              inhalt: r.inhalt || r.text || '',
              url: r.url || '',
            }));
          }
        }
        
        saveProjektDaten();
        render();
        alert('‚úÖ Import aus Backup erfolgreich!\n\n' + 
              `${state.figuren.length} Figuren\n` +
              `${state.szenen.length} Szenen\n` +
              `${state.medien.length} Medien`);
        
      } catch (e) {
        console.error('Import-Fehler:', e);
        alert('‚ùå Import fehlgeschlagen: ' + e.message);
      }
    }

    function exportToDramera() {
      return {
        version: '4.17',
        exportDate: new Date().toISOString(),
        source: 'NINA-Rebu v1.4',
        data: {
          projektName: state.projektMeta.titel,
          autor: {
            name: state.projektMeta.autor,
            email: '',
            adresse: '',
            copyright: `¬© ${new Date().getFullYear()} ${state.projektMeta.autor}`
          },
          fundament: {
            titel: {
              titel: state.projektMeta.titel,
              untertitel: state.projektMeta.untertitel,
              tagline: state.projektMeta.tagline
            },
            logline: state.projektMeta.logline
          },
          figuren: state.figuren.map(f => ({
            id: f.id,
            name: f.name,
            kuerzel: f.kuerzel,
            beschreibung: f.beschreibung,
            want: f.want,
            need: f.need,
            wunde: f.wunde,
            geheimnisse: f.geheimnis
          })),
          felder: state.szenen.map(s => ({
            id: s.id,
            titel: s.titel,
            position: state.szenen.indexOf(s),
            figuren: s.figuren,
            zusammenfassung: s.zusammenfassung,
            inhalt: state.textbuch[s.id] || ''
          })),
          recherche: state.medien.map(m => ({
            id: m.id,
            typ: m.typ,
            titel: m.titel,
            inhalt: m.inhalt,
            url: m.url
          }))
        }
      };
    }

    // ============================================
    // FASSUNGS-VERWALTUNG (v1.2: mit Uhrzeit)
    // ============================================
    function neueFassungSpeichern(name) {
      const now = new Date();
      const fassung = {
        id: genId(),
        name: name || `Fassung vom ${formatDateTime(now)}`,
        datum: now.toISOString(),
        textbuch: JSON.parse(JSON.stringify(state.textbuch)),
        szenen: JSON.parse(JSON.stringify(state.szenen)),
        cues: JSON.parse(JSON.stringify(state.cues)),
      };
      
      state.fassungen.push(fassung);
      state.projektMeta.fassung = fassung.name;
      state.projektMeta.fassungsDatum = fassung.datum;
      saveProjektDaten();
      render();
    }

    function fassungLaden(fassungId) {
      const fassung = state.fassungen.find(f => f.id === fassungId);
      if (fassung) {
        if (!confirm(`Aktuelle √Ñnderungen werden √ºberschrieben.\n\nFassung "${fassung.name}" laden?`)) return;
        
        state.textbuch = JSON.parse(JSON.stringify(fassung.textbuch));
        state.szenen = JSON.parse(JSON.stringify(fassung.szenen));
        if (fassung.cues) state.cues = JSON.parse(JSON.stringify(fassung.cues));
        state.projektMeta.fassung = fassung.name;
        saveProjektDaten();
        render();
      }
    }

    // ============================================
    // UNDO/REDO SYSTEM (v1.2)
    // ============================================
    // Hilfsfunktion: Cue-Marker aus HTML entfernen
    function stripCueMarkers(html) {
      return html.replace(/<span class="cue-inline-marker[^"]*"[^>]*>[^<]*<\/span>/g, '');
    }
    
    function pushUndo() {
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) return;
      
      // Ohne Cue-Marker speichern
      const cleanContent = stripCueMarkers(editor.innerHTML);
      
      state.undoStack.push({
        szeneId: state.aktiveSzene,
        content: cleanContent
      });
      
      // Max 50 Eintr√§ge
      if (state.undoStack.length > 50) {
        state.undoStack.shift();
      }
      
      // Redo l√∂schen bei neuer Aktion
      state.redoStack = [];
      updateUndoButtons();
    }
    
    function undo() {
      if (state.undoStack.length === 0) return;
      
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Aktuelle Version (ohne Marker) in Redo
      state.redoStack.push({
        szeneId: state.aktiveSzene,
        content: stripCueMarkers(editor.innerHTML)
      });
      
      // Letzte Version zur√ºckholen
      const lastState = state.undoStack.pop();
      if (lastState.szeneId === state.aktiveSzene) {
        state.textbuch[state.aktiveSzene] = lastState.content;
        
        // In Technik-Ansicht: Cue-Marker hinzuf√ºgen
        const szeneCues = state.cues.filter(c => c.szeneId === state.aktiveSzene);
        const displayContent = state.textAnsicht === 'technik' 
          ? enrichTextWithCueMarkers(lastState.content, szeneCues) 
          : lastState.content;
        
        editor.innerHTML = displayContent;
        saveProjektDaten();
      }
      
      updateUndoButtons();
    }
    
    function redo() {
      if (state.redoStack.length === 0) return;
      
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Aktuelle Version (ohne Marker) in Undo
      state.undoStack.push({
        szeneId: state.aktiveSzene,
        content: stripCueMarkers(editor.innerHTML)
      });
      
      // Redo-Version wiederherstellen
      const redoState = state.redoStack.pop();
      if (redoState.szeneId === state.aktiveSzene) {
        state.textbuch[state.aktiveSzene] = redoState.content;
        
        // In Technik-Ansicht: Cue-Marker hinzuf√ºgen
        const szeneCues = state.cues.filter(c => c.szeneId === state.aktiveSzene);
        const displayContent = state.textAnsicht === 'technik' 
          ? enrichTextWithCueMarkers(redoState.content, szeneCues) 
          : redoState.content;
        
        editor.innerHTML = displayContent;
        saveProjektDaten();
      }
      
      updateUndoButtons();
    }
    
    function updateUndoButtons() {
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');
      if (undoBtn) undoBtn.disabled = state.undoStack.length === 0;
      if (redoBtn) redoBtn.disabled = state.redoStack.length === 0;
    }

    // ============================================
    // EDITOR FUNKTIONEN (v1.2: verbessert)
    // ============================================
    function applyFormat(format) {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const selectedText = range.toString().trim();
      
      // WICHTIG: Wenn keine Auswahl, formatiere die ganze Zeile/Absatz
      if (!selectedText) {
        // Finde den aktuellen Absatz (p, div) wo der Cursor steht
        let node = selection.anchorNode;
        while (node && node !== editor) {
          if (node.nodeType === 1 && (node.tagName === 'P' || node.tagName === 'DIV')) {
            break;
          }
          node = node.parentNode;
        }
        
        if (node && node !== editor && node.nodeType === 1) {
          // Undo speichern
          pushUndo();
          
          // Text des Absatzes holen (alle Whitespace normalisieren)
          const text = node.textContent.replace(/\s+/g, ' ').trim();
          if (!text) return;
          
          // Neues formatiertes Element erstellen
          const vorlage = FORMATVORLAGEN[format];
          let newElement;
          
          switch (format) {
            case 'dialog':
              newElement = document.createElement('div');
              newElement.className = vorlage.class;
              // Regex: Name (mit Umlauten, Leerzeichen, Zahlen, Punkten) gefolgt von Doppelpunkt
              const dMatch = text.match(/^([A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\d\.]*?):\s*(.*)$/);
              if (dMatch) {
                const figurName = dMatch[1].trim().toUpperCase();
                const dialogText = dMatch[2] || '';
                newElement.innerHTML = `<span class="figur-name">${figurName}:</span><span class="dialog-text">${dialogText}</span>`;
              } else {
                // Kein Doppelpunkt gefunden - ganzer Text wird Dialog
                newElement.innerHTML = `<span class="figur-name">FIGUR:</span><span class="dialog-text">${text}</span>`;
              }
              break;
              
            case 'regieanweisung':
              newElement = document.createElement('p');
              newElement.className = vorlage.class;
              let regiText = text;
              if (!regiText.startsWith('(')) regiText = '(' + regiText;
              if (!regiText.endsWith(')')) regiText = regiText + ')';
              newElement.textContent = regiText;
              break;
            
            case 'szeneTitel':
              newElement = document.createElement('p');
              newElement.className = vorlage.class;
              newElement.textContent = text;
              // Neue Szene erstellen
              setTimeout(() => createSceneFromTitle(text, node), 100);
              break;
            
            case 'aktTitel':
              newElement = document.createElement('p');
              newElement.className = vorlage.class;
              newElement.textContent = text;
              // Neuen Akt erstellen
              setTimeout(() => createActFromTitle(text, node), 100);
              break;
              
            default:
              newElement = document.createElement('p');
              newElement.className = vorlage.class;
              newElement.textContent = text;
          }
          
          // Element ersetzen
          node.parentNode.replaceChild(newElement, node);
          
          // Cursor ans Ende des neuen Elements setzen
          const newRange = document.createRange();
          newRange.selectNodeContents(newElement);
          newRange.collapse(false);
          selection.removeAllRanges();
          selection.addRange(newRange);
          
          saveCurrentText();
        }
        return;
      }
      
      // Mit Auswahl: Original-Verhalten
      // Undo speichern
      pushUndo();
      
      const vorlage = FORMATVORLAGEN[format];
      let newHtml = '';
      
      switch (format) {
        case 'dialog':
          // v1.4: Dialog-Format - erkennt NAME: Text
          const selMatch = selectedText.replace(/\s+/g, ' ').match(/^([A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\d\.]*?):\s*(.*)$/);
          if (selMatch) {
            const fName = selMatch[1].trim().toUpperCase();
            newHtml = `<div class="${vorlage.class}"><span class="figur-name">${fName}:</span><span class="dialog-text">${selMatch[2]}</span></div>`;
          } else {
            newHtml = `<div class="${vorlage.class}"><span class="figur-name">FIGUR:</span><span class="dialog-text">${selectedText}</span></div>`;
          }
          break;
          
        case 'regieanweisung':
          let text = selectedText;
          if (!text.startsWith('(')) text = '(' + text;
          if (!text.endsWith(')')) text = text + ')';
          newHtml = `<p class="${vorlage.class}">${text}</p>`;
          break;
          
        case 'szeneTitel':
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
          // Neue Szene erstellen wenn gew√ºnscht
          setTimeout(() => createSceneFromTitle(selectedText, null), 100);
          break;
        
        case 'aktTitel':
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
          // Neuen Akt erstellen
          setTimeout(() => createActFromTitle(selectedText, null), 100);
          break;
          
        case 'lied':
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
          break;
          
        case 'vers':
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
          break;
          
        default:
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
      }
      
      range.deleteContents();
      const temp = document.createElement('div');
      temp.innerHTML = newHtml;
      const frag = document.createDocumentFragment();
      while (temp.firstChild) {
        frag.appendChild(temp.firstChild);
      }
      range.insertNode(frag);
      
      selection.removeAllRanges();
      saveCurrentText();
    }

    function insertNewParagraph(format) {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Undo speichern
      pushUndo();
      
      editor.focus();
      const vorlage = FORMATVORLAGEN[format];
      let html = '';
      
      switch (format) {
        case 'dialog':
          // v1.2: Neues Dialog-Format
          html = `<div class="${vorlage.class}"><span class="figur-name">FIGUR:</span><span class="dialog-text">&nbsp;</span></div>`;
          break;
        case 'regieanweisung':
          html = `<p class="${vorlage.class}">()</p>`;
          break;
        case 'szeneTitel':
          const szene = state.szenen.find(s => s.id === state.aktiveSzene);
          html = `<p class="${vorlage.class}">${szene ? szene.nummer + ' ' + szene.titel : 'Neue Szene'}</p>`;
          break;
        case 'aktTitel':
          const strukturTyp = state.projektMeta?.strukturTyp || 'akte';
          const struktur = STRUKTUR_TYPEN[strukturTyp];
          html = `<p class="${vorlage.class}">${struktur.gruppenNamen['1'] || 'ERSTER AKT'}</p>`;
          break;
        case 'pause':
          html = `<p class="${vorlage.class}">‚Äî PAUSE ‚Äî</p>`;
          break;
        case 'lied':
          html = `<p class="${vorlage.class}">üéµ </p>`;
          break;
        default:
          html = `<p class="${vorlage.class}"><br></p>`;
      }
      
      document.execCommand('insertHTML', false, html);
      saveCurrentText();
    }

    function insertFigurDialog(figurName) {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Undo speichern
      pushUndo();
      
      editor.focus();
      // v1.2: Neues Dialog-Format
      const html = `<div class="format-dialog"><span class="figur-name">${figurName.toUpperCase()}:</span><span class="dialog-text">&nbsp;</span></div>`;
      document.execCommand('insertHTML', false, html);
      saveCurrentText();
      
      // Cursor ans Ende setzen
      const selection = window.getSelection();
      const range = document.createRange();
      range.selectNodeContents(editor);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // v1.2: Text als gestrichen markieren
    function toggleGestrichen() {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const selectedText = range.toString().trim();
      if (!selectedText) return;
      
      // Undo speichern
      pushUndo();
      
      // Pr√ºfen ob bereits gestrichen
      const parentEl = range.commonAncestorContainer.parentElement;
      if (parentEl && parentEl.classList.contains('format-gestrichen')) {
        // Streichung entfernen
        const text = parentEl.textContent;
        parentEl.replaceWith(document.createTextNode(text));
      } else {
        // Streichung hinzuf√ºgen
        const span = document.createElement('span');
        span.className = 'format-gestrichen';
        span.textContent = selectedText;
        range.deleteContents();
        range.insertNode(span);
      }
      
      selection.removeAllRanges();
      saveCurrentText();
    }
    
    // NEU: Erg√§nzung markieren
    function toggleErgaenzung() {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const selectedText = range.toString().trim();
      if (!selectedText) return;
      
      // Undo speichern
      pushUndo();
      
      // Pr√ºfen ob bereits Erg√§nzung
      const parentEl = range.commonAncestorContainer.parentElement;
      if (parentEl && parentEl.classList.contains('format-ergaenzung')) {
        // Erg√§nzung entfernen
        const text = parentEl.textContent;
        parentEl.replaceWith(document.createTextNode(text));
      } else {
        // Erg√§nzung hinzuf√ºgen
        const span = document.createElement('span');
        span.className = 'format-ergaenzung';
        span.textContent = selectedText;
        range.deleteContents();
        range.insertNode(span);
      }
      
      selection.removeAllRanges();
      saveCurrentText();
    }
    
    // NEU: Ansicht wechseln
    function setTextAnsicht(ansicht) {
      state.textAnsicht = ansicht;
      render();
    }
    
    // NEU: Editor-Klassen basierend auf Ansicht
    function getEditorClasses() {
      const classes = ['editor-content'];
      
      switch (state.textAnsicht) {
        case 'schauspieler':
          // Keine Cues, keine √Ñnderungsmarkierungen
          classes.push('hide-cues', 'hide-aenderungen');
          break;
        case 'technik':
          // Cues sichtbar, Streichungen sichtbar
          break;
        case 'aenderungen':
          // Keine Cues, aber Streichungen und Erg√§nzungen sichtbar
          classes.push('hide-cues');
          break;
      }
      
      return classes.join(' ');
    }

    function execCommand(cmd, value = null) {
      // Undo speichern vor √Ñnderung
      pushUndo();
      document.execCommand(cmd, false, value);
      saveCurrentText();
    }
    
    // NEU: Text mit Cue-Markern anreichern (nur f√ºr Anzeige)
    function enrichTextWithCueMarkers(text, cues) {
      if (!cues || cues.length === 0) return text;
      
      let enrichedText = text;
      
      // Cues mit Ankertext sortieren nach L√§nge (l√§ngste zuerst, um √úberlappungen zu vermeiden)
      const cuesWithAnker = cues
        .filter(c => c.ankerText)
        .sort((a, b) => b.ankerText.length - a.ankerText.length);
      
      cuesWithAnker.forEach(cue => {
        const anker = cue.ankerText;
        const marker = `<span class="cue-inline-marker ${CUE_TYPEN[cue.typ]?.class || 'cue-lx'}" contenteditable="false" data-cue-id="${cue.id}" onclick="editCue('${cue.id}')">${CUE_TYPEN[cue.typ]?.prefix || ''}${cue.nummer}</span>`;
        
        // Ankertext im Text finden und Marker dahinter einf√ºgen
        // Nur das erste Vorkommen markieren
        const index = enrichedText.indexOf(anker);
        if (index !== -1) {
          const endIndex = index + anker.length;
          enrichedText = enrichedText.substring(0, endIndex) + marker + enrichedText.substring(endIndex);
        }
      });
      
      return enrichedText;
    }

    function saveCurrentText() {
      const editor = document.getElementById('text-editor');
      if (editor && state.aktiveSzene) {
        // Cue-Marker entfernen vor dem Speichern
        const content = stripCueMarkers(editor.innerHTML);
        state.textbuch[state.aktiveSzene] = content;
        saveProjektDaten();
      }
    }
    
    // NEU: Pr√ºft ob Cue-Anker noch im Text existieren
    function checkCueAnkers(szeneId) {
      const textContent = state.textbuch[szeneId] || '';
      // HTML-Tags entfernen f√ºr die Suche
      const plainText = textContent.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');
      
      const cuesInSzene = state.cues.filter(c => c.szeneId === szeneId && c.ankerText);
      const orphanedCues = [];
      
      cuesInSzene.forEach(cue => {
        // Ankertext normalisieren (Whitespace vereinheitlichen)
        const ankerNormalized = cue.ankerText.replace(/\s+/g, ' ').trim();
        if (!plainText.includes(ankerNormalized)) {
          orphanedCues.push(cue);
        }
      });
      
      return orphanedCues;
    }
    
    // NEU: Warnung anzeigen wenn Anker fehlen
    function showOrphanedCuesWarning(orphanedCues) {
      if (orphanedCues.length === 0) return;
      
      const cueList = orphanedCues.map(c => 
        `‚Ä¢ ${CUE_TYPEN[c.typ]?.prefix || ''}${c.nummer}: "${c.ankerText.substring(0, 50)}${c.ankerText.length > 50 ? '...' : ''}"`
      ).join('\n');
      
      const action = confirm(
        `‚ö†Ô∏è¬è Folgende Cues haben ihren Ankertext verloren:\n\n${cueList}\n\n` +
        `Der Text, an dem diese Cues positioniert waren, wurde ge√§ndert oder gel√∂scht.\n\n` +
        `Klicke OK, um die Cues zu bearbeiten und neu zu positionieren.\n` +
        `Klicke Abbrechen, um sp√§ter zu entscheiden.`
      );
      
      if (action && orphanedCues.length > 0) {
        // Ersten verwaisten Cue √∂ffnen
        editCue(orphanedCues[0].id);
      }
    }
    
    // NEU: Beim Szene-Wechsel pr√ºfen
    function selectSzeneWithCheck(szeneId) {
      // Erst alte Szene pr√ºfen
      if (state.aktiveSzene) {
        const orphaned = checkCueAnkers(state.aktiveSzene);
        if (orphaned.length > 0) {
          showOrphanedCuesWarning(orphaned);
        }
      }
      
      // Dann wechseln
      selectSzene(szeneId);
    }
    
    // NEU: Aktuelle Szene pr√ºfen (vom Button)
    function checkCurrentSzeneAnkers() {
      if (!state.aktiveSzene) {
        alert('Keine Szene ausgew√§hlt.');
        return;
      }
      
      const orphaned = checkCueAnkers(state.aktiveSzene);
      
      if (orphaned.length === 0) {
        const cuesWithAnker = state.cues.filter(c => c.szeneId === state.aktiveSzene && c.ankerText).length;
        if (cuesWithAnker === 0) {
          alert('‚úÖ Keine Cues mit Ankertexten in dieser Szene.\n\nTipp: Markiere Text und klicke üí°üîäüì∫ um Cues mit Textposition zu erstellen.');
        } else {
          alert(`‚úÖ Alle ${cuesWithAnker} Cue-Anker in dieser Szene sind g√ºltig!`);
        }
      } else {
        showOrphanedCuesWarning(orphaned);
      }
    }

    // ============================================
    // RENDER MAIN
    // ============================================
    // ============================================
    // KI-ASSISTENT FUNKTIONEN (v1.7)
    // ============================================
    
    // API-Key aus localStorage holen
    function getApiKey() {
      return localStorage.getItem('nina_rebu_api_key') || '';
    }
    
    // API-Key testen
    async function testApiKey() {
      const apiKey = getApiKey();
      if (!apiKey || !apiKey.trim()) {
        apiKeyError = 'Bitte zuerst einen Key eingeben';
        apiKeyStatus = 'error';
        render();
        return;
      }
      
      apiKeyStatus = 'testing';
      apiKeyError = '';
      render();
      
      try {
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 10,
            messages: [{ role: 'user', content: 'Antworte nur mit: OK' }]
          })
        });
        
        if (response.ok) {
          apiKeyStatus = 'success';
        } else {
          const err = await response.json();
          apiKeyStatus = 'error';
          if (response.status === 401) {
            apiKeyError = 'Ung√ºltiger API-Key';
          } else if (response.status === 403) {
            apiKeyError = 'Keine Berechtigung (Key gesperrt?)';
          } else if (err.error?.message) {
            apiKeyError = err.error.message;
          } else {
            apiKeyError = `Fehler ${response.status}`;
          }
        }
      } catch (err) {
        apiKeyStatus = 'error';
        apiKeyError = 'Netzwerkfehler ‚Äì bitte Verbindung pr√ºfen';
      }
      
      render();
    }
    
    // KI-Panel √∂ffnen/schliessen
    // v2.0: Projekt-Men√º Funktionen
    function toggleProjektMenu() {
      const menu = document.getElementById('projekt-menu');
      if (menu) {
        menu.classList.toggle('hidden');
        // Click au√üerhalb schlie√üt Men√º
        if (!menu.classList.contains('hidden')) {
          setTimeout(() => {
            document.addEventListener('click', closeProjektMenuOnClickOutside, { once: true });
          }, 10);
        }
      }
    }
    
    function closeProjektMenu() {
      const menu = document.getElementById('projekt-menu');
      if (menu) menu.classList.add('hidden');
    }
    
    function closeProjektMenuOnClickOutside(e) {
      const menu = document.getElementById('projekt-menu');
      if (menu && !menu.contains(e.target) && !e.target.closest('button[onclick*="toggleProjektMenu"]')) {
        menu.classList.add('hidden');
      }
    }
    
    // v2.0: Projekt-Liste anzeigen (Modal)
    function showProjektListe() {
      state.showProjektListeModal = true;
      render();
    }
    
    // v2.0: Handler f√ºr Cloud-Speichern Button
    function handleCloudSave() {
      closeProjektMenu();
      const istCloudProjekt = !!(currentCloudProjectId && isCloudMode);
      if (!cloudUser) {
        state.showCloudModal = true;
        render();
      } else if (istCloudProjekt) {
        alert('‚òÅÔ∏è Bereits in Cloud gespeichert!');
      } else {
        uploadToCloud();
      }
    }
    
    // v2.0: Handler f√ºr Cloud-Reload Button
    function handleCloudReload() {
      closeProjektMenu();
      const istCloudProjekt = !!(currentCloudProjectId && isCloudMode);
      if (istCloudProjekt) {
        forceCloudSync();
      }
    }
    
    // v2.0: Warnung beim Schlie√üen (nur f√ºr lokale Projekte)
    window.addEventListener('beforeunload', function(e) {
      const istCloudProjekt = !!(currentCloudProjectId && isCloudMode);
      const hatDaten = state.szenen?.length > 0 || state.figuren?.length > 0;
      
      // Nur warnen wenn: lokales Projekt UND Daten vorhanden
      if (!istCloudProjekt && hatDaten) {
        const message = 'Deine Daten sind nur lokal im Browser gespeichert! Vor dem Schlie√üen exportieren?';
        e.preventDefault();
        e.returnValue = message;
        return message;
      }
    });

    function toggleKiPanel() {
      const apiKey = getApiKey();
      if (!apiKey) {
        alert('Bitte zuerst einen API-Key in den Projekt-Einstellungen hinterlegen.\n\n‚Üí Klicke auf "‚öôÔ∏è Einst." in der linken Sidebar.');
        return;
      }
      
      state.kiPanelOpen = !state.kiPanelOpen;
      
      // Bei erstem √ñffnen: Begr√ºssung hinzuf√ºgen
      if (state.kiPanelOpen && state.kiMessages.length === 0) {
        state.kiMessages.push({
          role: 'assistant',
          content: `üëã Hallo! Ich bin dein KI-Assistent f√ºr das Regiebuch.

Ich kann dir helfen mit:
‚Ä¢ **Szenen analysieren** ‚Äì "Was ist das Ziel dieser Szene?"
‚Ä¢ **Figuren entwickeln** ‚Äì "Welche Motivation hat diese Figur?"
‚Ä¢ **Dialoge verbessern** ‚Äì "Wie k√∂nnte dieser Dialog nat√ºrlicher klingen?"
‚Ä¢ **Regieanweisungen** ‚Äì "Schlage Regieanweisungen f√ºr diese Szene vor"
‚Ä¢ **Fragen beantworten** ‚Äì Alles rund um Theater und Dramaturgie

Was m√∂chtest du tun?`
        });
      }
      
      render();
    }
    
    // Kontext f√ºr KI zusammenstellen
    function buildKiContext() {
      let context = `Du bist ein erfahrener Dramaturg und Theaterassistent. Du hilfst beim Erstellen eines Regiebuchs.

PROJEKT: "${state.projektMeta?.titel || 'Unbenannt'}"
${state.projektMeta?.untertitel ? `Untertitel: ${state.projektMeta.untertitel}` : ''}
${state.projektMeta?.autor ? `Autor: ${state.projektMeta.autor}` : ''}
${state.projektMeta?.logline ? `Logline: ${state.projektMeta.logline}` : ''}

`;
      
      // Figuren
      if (state.figuren.length > 0) {
        context += `FIGUREN (${state.figuren.length}):\n`;
        state.figuren.forEach(f => {
          context += `- ${f.name}${f.kuerzel ? ` (${f.kuerzel})` : ''}: ${f.beschreibung || 'Keine Beschreibung'}`;
          if (f.want) context += ` | Will: ${f.want}`;
          if (f.need) context += ` | Braucht: ${f.need}`;
          context += '\n';
        });
        context += '\n';
      }
      
      // Aktuelle Szene
      if (state.aktiveSzene) {
        const szene = state.szenen.find(s => s.id === state.aktiveSzene);
        if (szene) {
          context += `AKTUELLE SZENE: ${szene.nummer} "${szene.titel}"
Ort: ${szene.ort || '-'} | Zeit: ${szene.zeit || '-'}
${szene.zusammenfassung ? `Zusammenfassung: ${szene.zusammenfassung}` : ''}
`;
          
          // Figuren der Szene
          const figurenNamen = szene.figuren?.map(fId => {
            const f = state.figuren.find(fig => fig.id === fId);
            return f?.name;
          }).filter(Boolean).join(', ');
          if (figurenNamen) context += `Figuren in Szene: ${figurenNamen}\n`;
          
          // Text der Szene (gek√ºrzt)
          const szenenText = state.textbuch[state.aktiveSzene];
          if (szenenText) {
            // HTML zu Text konvertieren
            const tmp = document.createElement('div');
            tmp.innerHTML = szenenText;
            let plainText = tmp.textContent || tmp.innerText || '';
            // Auf max 2000 Zeichen k√ºrzen
            if (plainText.length > 2000) {
              plainText = plainText.substring(0, 2000) + '... [gek√ºrzt]';
            }
            context += `\nSZENEN-TEXT:\n${plainText}\n`;
          }
        }
      }
      
      // Alle Szenen (√úbersicht)
      if (state.szenen.length > 0) {
        context += `\nALLE SZENEN (${state.szenen.length}):\n`;
        state.szenen.forEach(s => {
          context += `- ${s.nummer} "${s.titel}"${s.ort ? ` @ ${s.ort}` : ''}\n`;
        });
      }
      
      return context;
    }
    
    // Nachricht an KI senden
    async function sendKiMessage(userMessage) {
      if (!userMessage?.trim()) return;
      
      const apiKey = getApiKey();
      if (!apiKey) {
        alert('Bitte zuerst einen API-Key in den Einstellungen hinterlegen.');
        return;
      }
      
      // User-Nachricht hinzuf√ºgen
      state.kiMessages.push({ role: 'user', content: userMessage.trim() });
      state.kiInput = '';
      state.kiLoading = true;
      render();
      
      // Scroll nach unten
      setTimeout(() => {
        const messagesDiv = document.getElementById('ki-messages');
        if (messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }, 50);
      
      try {
        // Kontext aufbauen
        const systemPrompt = buildKiContext() + `

WICHTIGE REGELN:
- Antworte auf Deutsch
- Sei hilfreich, pr√§zise und kreativ
- Bei Szenen-Analysen: Gehe auf dramaturgische Aspekte ein (Ziel, Konflikt, Wendepunkte)
- Bei Dialog-Verbesserungen: Biete konkrete Alternativen an
- Formatiere mit **fett** f√ºr wichtige Begriffe
- Halte Antworten kompakt (max. 300 W√∂rter), ausser bei kreativen Aufgaben`;
        
        // Nachrichten f√ºr API vorbereiten (ohne lokale Begr√ºssung)
        const apiMessages = state.kiMessages
          .filter(m => !m.isLocal)
          .map(m => ({ role: m.role, content: m.content }));
        
        // API-Aufruf
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 2000,
            system: systemPrompt,
            messages: apiMessages
          })
        });
        
        if (!response.ok) {
          const errText = await response.text();
          let errMsg = 'API-Fehler';
          try {
            const errJson = JSON.parse(errText);
            errMsg = errJson.error?.message || errMsg;
            if (errMsg.includes('invalid x-api-key') || errMsg.includes('invalid_api_key')) {
              errMsg = 'Ung√ºltiger API-Key. Bitte √ºberpr√ºfe den Key in den Einstellungen.';
            } else if (errMsg.includes('rate_limit')) {
              errMsg = 'Zu viele Anfragen. Bitte warte kurz und versuche es erneut.';
            } else if (errMsg.includes('credit') || errMsg.includes('billing')) {
              errMsg = 'Kein API-Guthaben mehr. Bitte pr√ºfe dein Anthropic-Konto.';
            }
          } catch (e) {
            errMsg = errText.substring(0, 200);
          }
          throw new Error(errMsg);
        }
        
        const result = await response.json();
        
        // Antwort extrahieren
        let fullText = '';
        for (const block of result.content) {
          if (block.type === 'text') {
            fullText += block.text;
          }
        }
        
        // Antwort hinzuf√ºgen
        state.kiMessages.push({ role: 'assistant', content: fullText.trim() });
        
      } catch (err) {
        console.error('KI-Fehler:', err);
        state.kiMessages.push({ 
          role: 'assistant', 
          content: `‚ùå Fehler: ${err.message}\n\nüí° Bitte pr√ºfe deinen API-Key in den Projekt-Einstellungen.`
        });
      } finally {
        state.kiLoading = false;
        render();
        
        // Scroll nach unten
        setTimeout(() => {
          const messagesDiv = document.getElementById('ki-messages');
          if (messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }, 50);
      }
    }
    
    // KI-Panel rendern
    function renderKiPanel() {
      const hasApiKey = !!getApiKey();
      
      return `
        <!-- KI Toggle Button -->
        <button class="ki-toggle-btn ${hasApiKey ? 'has-key' : ''} ${state.kiPanelOpen ? 'panel-open' : ''}" 
                onclick="toggleKiPanel()" 
                title="${hasApiKey ? 'KI-Assistent √∂ffnen' : 'API-Key ben√∂tigt'}">
          ü§ñ
        </button>
        
        <!-- KI Panel -->
        <div class="ki-panel ${state.kiPanelOpen ? 'open' : ''}">
          <div class="ki-panel-header">
            <h3>ü§ñ KI-Assistent</h3>
            <div style="display: flex; gap: 0.5rem;">
              <button onclick="state.kiMessages = []; toggleKiPanel(); toggleKiPanel();" title="Chat leeren">üóëÔ∏è</button>
              <button onclick="toggleKiPanel()" title="Schliessen">‚úï</button>
            </div>
          </div>
          
          <div class="ki-messages" id="ki-messages">
            ${state.kiMessages.length === 0 && !state.kiLoading ? `
              <div style="text-align: center; color: #9ca3af; padding: 2rem;">
                <div style="font-size: 2rem; margin-bottom: 0.5rem;">üé≠</div>
                <p>Starte eine Unterhaltung mit dem KI-Assistenten.</p>
              </div>
            ` : ''}
            
            ${state.kiMessages.map((msg, i) => `
              <div class="ki-message ${msg.role}">
                ${msg.content.split('\n').map(line => {
                  // Markdown-√§hnliche Formatierung
                  const formatted = line.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                  return `<p>${formatted}</p>`;
                }).join('')}
              </div>
            `).join('')}
            
            ${state.kiLoading ? `
              <div class="ki-message assistant loading">
                <span class="typing-indicator">‚óè‚óè‚óè</span>
              </div>
            ` : ''}
          </div>
          
          <div class="ki-input-area">
            <textarea 
              id="ki-input"
              placeholder="Frage stellen... (Enter zum Senden)"
              rows="2"
              onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendKiMessage(this.value); }"
              ${state.kiLoading ? 'disabled' : ''}
            >${state.kiInput}</textarea>
            <div class="ki-input-actions">
              <button class="btn btn-sm btn-outline flex-1" 
                      onclick="state.kiMessages = []; render();"
                      ${state.kiLoading || state.kiMessages.length === 0 ? 'disabled' : ''}>
                üóëÔ∏è Leeren
              </button>
              <button class="btn btn-sm btn-primary flex-1" 
                      onclick="sendKiMessage(document.getElementById('ki-input').value)"
                      ${state.kiLoading ? 'disabled' : ''}>
                Senden
              </button>
            </div>
          </div>
        </div>
      `;
    }

    // ============================================
    // CLOUD MODAL
    // ============================================
    // v2.0: Projekt-Liste Modal (√ñffnen...)
    function renderProjektListeModal() {
      const alleProjekte = load(KEYS.projekte, []);
      
      // Cloud-Projekte hinzuf√ºgen die noch nicht lokal sind
      if (cloudUser && cloudProjects.length > 0) {
        cloudProjects.forEach(cp => {
          const localId = 'cloud_' + cp.id;
          if (!alleProjekte.find(p => p.id === localId || p.cloudId === cp.id)) {
            alleProjekte.push({ id: localId, cloudId: cp.id, name: cp.name, isCloudOnly: true });
          }
        });
      }
      
      // Projekte mit Cloud-Status markieren
      const projekteAngereichert = alleProjekte.map(p => ({
        ...p,
        istCloud: !!(p.cloudId || p.id?.startsWith('cloud_')),
      }));
      
      return `
        <div class="modal-overlay" onclick="state.showProjektListeModal = false; render()">
          <div class="modal-content" style="max-width: 500px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h3>üìÇ Projekt √∂ffnen</h3>
              <button class="modal-close" onclick="state.showProjektListeModal = false; render()">√ó</button>
            </div>
            <div class="p-4">
              ${projekteAngereichert.length === 0 ? `
                <div class="text-center py-8 text-gray-500">
                  <div class="text-4xl mb-2">üìÅ</div>
                  <p>Keine Projekte vorhanden</p>
                  <button class="btn btn-primary mt-4" onclick="state.showProjektListeModal = false; openProjektModal()">
                    + Neues Projekt erstellen
                  </button>
                </div>
              ` : `
                <div class="space-y-2 max-h-96 overflow-y-auto">
                  ${projekteAngereichert.map(p => `
                    <div class="flex items-center justify-between p-3 rounded-lg border ${p.id === state.projektId ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:bg-gray-50'} cursor-pointer"
                         onclick="${p.isCloudOnly ? `selectCloudProject('${p.cloudId}')` : `wechsleProjekt('${p.id}')`}; state.showProjektListeModal = false; render()">
                      <div class="flex items-center gap-3">
                        <span class="text-xl" title="${p.istCloud ? 'Cloud-Projekt (sicher)' : 'Lokales Projekt (nur Browser)'}">
                          ${p.istCloud ? '‚òÅÔ∏è' : 'üíæ'}
                        </span>
                        <div>
                          <div class="font-medium">${p.name || 'Unbenannt'}</div>
                          <div class="text-xs text-gray-500">${p.istCloud ? 'In Cloud gespeichert' : 'Nur lokal'}</div>
                        </div>
                      </div>
                      ${p.id === state.projektId ? '<span class="text-xs text-blue-600">Aktiv</span>' : ''}
                    </div>
                  `).join('')}
                </div>
                
                <div class="mt-4 pt-4 border-t flex gap-2">
                  <button class="btn btn-outline flex-1" onclick="state.showProjektListeModal = false; openProjektModal()">
                    + Neues Projekt
                  </button>
                  ${cloudUser ? `
                    <button class="btn btn-primary flex-1" onclick="state.showProjektListeModal = false; createCloudProjectSimple()">
                      ‚òÅÔ∏è Neues Cloud-Projekt
                    </button>
                  ` : `
                    <button class="btn btn-outline flex-1" onclick="state.showProjektListeModal = false; state.showCloudModal = true; render()">
                      ‚òÅÔ∏è Cloud-Login
                    </button>
                  `}
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }
    
    function renderCloudModal() {
      const lokaleProj = load(KEYS.projekte, []).filter(p => !p.id?.startsWith('cloud_'));
      const aktuellesProjekt = lokaleProj.find(p => p.id === state.projektId);
      const hatCloudId = aktuellesProjekt?.cloudId;
      
      return `
        <div class="modal-overlay" onclick="state.showCloudModal = false; render()">
          <div class="modal-content" style="max-width: 600px; max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h3>‚òÅÔ∏è Cloud-Synchronisation</h3>
              <button class="modal-close" onclick="state.showCloudModal = false; render()">√ó</button>
            </div>
            <div class="p-4">
              ${cloudUser ? `
                <!-- Eingeloggt -->
                <div class="bg-green-50 border border-green-200 rounded-lg p-3 mb-4">
                  <div class="flex items-center justify-between">
                    <div>
                      <div class="text-green-700 font-medium">‚úì Eingeloggt</div>
                      <div class="text-green-600 text-sm">${cloudUser.email}</div>
                    </div>
                    <button class="btn btn-sm btn-outline" onclick="cloudLogout()">Ausloggen</button>
                  </div>
                </div>
                
                <!-- Cloud-Projekte -->
                <div class="mb-4">
                  <h4 class="font-semibold mb-2">‚òÅÔ∏è Cloud-Projekte (${cloudProjects.length})</h4>
                  ${cloudProjects.length === 0 ? `
                    <div class="text-gray-500 text-sm py-4 text-center">Keine Cloud-Projekte vorhanden</div>
                  ` : `
                    <div class="space-y-2 max-h-48 overflow-y-auto">
                      ${cloudProjects.map(p => `
                        <div class="flex items-center justify-between p-2 bg-gray-50 rounded ${currentCloudProjectId === p.id ? 'ring-2 ring-blue-500' : ''}">
                          <div>
                            <div class="font-medium">${escapeHtml(p.name)}</div>
                            ${p.author ? `<div class="text-xs text-gray-500">${escapeHtml(p.author)}</div>` : ''}
                          </div>
                          <div class="flex gap-1">
                            <button class="btn btn-xs btn-primary" onclick="selectCloudProject('${p.id}'); state.showCloudModal = false; render()">
                              √ñffnen
                            </button>
                            <button class="btn btn-xs btn-outline text-red-500" onclick="deleteCloudProject('${p.id}')">
                              üóëÔ∏è
                            </button>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  `}
                </div>
                
                <!-- Neues Cloud-Projekt -->
                <div class="mb-4 p-3 bg-blue-50 rounded-lg">
                  <h4 class="font-semibold mb-2">+ Neues Cloud-Projekt</h4>
                  <div class="flex gap-2">
                    <input type="text" id="cloud_projekt_name" placeholder="Projektname" 
                           class="flex-1 px-3 py-2 border rounded text-sm">
                    <button class="btn btn-primary" onclick="createCloudProject()">
                      Erstellen
                    </button>
                  </div>
                </div>
                
                <!-- Lokales Projekt hochladen -->
                ${state.projektId && typeof state.projektId === 'string' && !state.projektId.startsWith('cloud_') ? `
                  <div class="p-3 bg-yellow-50 rounded-lg">
                    <h4 class="font-semibold mb-2">‚¨ÜÔ∏è Aktuelles Projekt hochladen</h4>
                    <p class="text-sm text-gray-600 mb-2">
                      "${escapeHtml(state.projektMeta?.titel || 'Unbenannt')}" in die Cloud hochladen
                    </p>
                    <button class="btn btn-warning" onclick="uploadProjectToCloud()">
                      ‚òÅÔ∏è In Cloud hochladen
                    </button>
                  </div>
                ` : ''}
                
              ` : `
                <!-- Nicht eingeloggt - Login Form -->
                <div class="space-y-4">
                  <div>
                    <label class="block text-sm font-medium mb-1">E-Mail</label>
                    <input type="email" id="cloud_email" class="w-full px-3 py-2 border rounded">
                  </div>
                  <div>
                    <label class="block text-sm font-medium mb-1">Passwort</label>
                    <input type="password" id="cloud_password" class="w-full px-3 py-2 border rounded">
                  </div>
                  <div class="flex gap-2">
                    <button class="btn btn-primary flex-1" onclick="cloudLogin(document.getElementById('cloud_email').value, document.getElementById('cloud_password').value)">
                      Einloggen
                    </button>
                    <button class="btn btn-outline flex-1" onclick="toggleRegisterFields()">
                      Registrieren
                    </button>
                  </div>
                  
                  <div id="register_fields" class="hidden space-y-2 pt-2 border-t">
                    <div>
                      <label class="block text-sm font-medium mb-1">Name</label>
                      <input type="text" id="cloud_name" class="w-full px-3 py-2 border rounded">
                    </div>
                    <button class="btn btn-success w-full" onclick="cloudRegister(document.getElementById('cloud_email').value, document.getElementById('cloud_password').value, document.getElementById('cloud_name').value)">
                      Konto erstellen
                    </button>
                  </div>
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }
    
    function toggleRegisterFields() {
      const fields = document.getElementById('register_fields');
      if (fields) fields.classList.toggle('hidden');
    }

    function render() {
      const app = document.getElementById('app');
      app.innerHTML = `
        <div class="flex h-screen">
          ${renderSidebar()}
          
          <div class="flex-1 flex flex-col overflow-hidden">
            ${renderHeader()}
            
            <div class="flex-1 flex overflow-hidden">
              ${renderMainContent()}
            </div>
          </div>
        </div>
        
        ${state.showImportModal ? renderImportModal() : ''}
        ${state.showExportModal ? renderExportModal() : ''}
        ${state.showFassungModal ? renderFassungModal() : ''}
        ${state.showFigurModal ? renderFigurModal() : ''}
        ${state.showCueModal ? renderCueModal() : ''}
        ${state.showSzeneModal ? renderSzeneModal() : ''}
        ${state.showKostuemModal ? renderKostuemModal() : ''}
        ${state.showRequisitenModal ? renderRequisitenModal() : ''}
        ${state.showBuehneModal ? renderBuehneModal() : ''}
        ${state.showLightbox ? renderLightbox() : ''}
        ${showCueExportDialog ? renderCueExportDialog() : ''}
        ${state.showProjektModal ? renderProjektModal() : ''}
        ${state.showCloudModal ? renderCloudModal() : ''}
        ${state.showProjektListeModal ? renderProjektListeModal() : ''}
        ${renderKiPanel()}
      `;
      
      // Event-Listener f√ºr Editor
      const editor = document.getElementById('text-editor');
      if (editor) {
        editor.addEventListener('input', () => saveCurrentText());
        editor.addEventListener('blur', () => saveCurrentText());
        // Keyboard shortcuts
        editor.addEventListener('keydown', (e) => {
          if (e.ctrlKey || e.metaKey) {
            // Undo/Redo
            if (e.key === 'z' && !e.shiftKey) {
              e.preventDefault();
              undo();
            } else if ((e.key === 'z' && e.shiftKey) || e.key === 'y') {
              e.preventDefault();
              redo();
            }
            
            // Format-Shortcuts (Ctrl+Shift+Buchstabe)
            if (e.shiftKey) {
              const formatMap = {
                'd': 'dialog',
                'r': 'regieanweisung',
                't': 'szeneTitel',
                'a': 'aktTitel',
                'l': 'lied',
                'v': 'vers',
                'p': 'pause',
                'n': 'standard'
              };
              const format = formatMap[e.key.toLowerCase()];
              if (format) {
                e.preventDefault();
                applyFormat(format);
              }
            }
          }
        });
      }
      
      updateUndoButtons();
    }

    function renderSidebar() {
      const navItems = [
        { id: 'titelblatt', icon: 'üìñ', label: 'Titelblatt' },
        { id: 'textbuch', icon: 'üìù', label: 'Textbuch' },
        { id: 'szenen', icon: 'üé¨', label: 'Szenen' },
        { id: 'figuren', icon: 'üë§', label: 'Figuren' },
        { id: 'buehne', icon: 'üé™', label: 'B√ºhne' },
        { id: 'requisiten', icon: 'üé≠', label: 'Requisiten' },
        { id: 'kostueme', icon: 'üëó', label: 'Kost√ºme' },
        { id: 'medien', icon: 'üéµ', label: 'Medien' },
        { id: 'fassungen', icon: 'üìö', label: 'Fassungen' },
      ];
      
      // Cloud-Status ermitteln
      const istCloudProjekt = !!(currentCloudProjectId && isCloudMode);
      const istEingeloggt = !!cloudUser;
      const projektTitel = state.projektMeta?.titel || 'Unbenannt';
      
      return `
        <div class="sidebar w-56 flex flex-col text-white">
          <!-- Logo (gr√∂√üer) -->
          <div class="p-4 border-b border-white/10">
            <div class="text-center">
              <img src="data:image/jpeg;base64,${NINA_LOGO_BASE64}" alt="N!NA" class="h-24 w-auto mx-auto mb-2" />
              <div class="font-bold text-lg">N!NA-Rebu</div>
              <div class="text-xs text-blue-300">Regiebuch v2.4</div>
            </div>
          </div>
          
          <!-- Projekt-Men√º (Datei-Men√º Stil) -->
          <div class="p-3 border-b border-white/10">
            <div class="relative">
              <button class="w-full text-left px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 flex items-center justify-between"
                      onclick="toggleProjektMenu()">
                <div class="flex items-center gap-2 flex-1 min-w-0">
                  <span>${istCloudProjekt ? '‚òÅÔ∏è' : 'üíæ'}</span>
                  <span class="truncate font-medium">${projektTitel}</span>
                </div>
                <span class="text-gray-400">‚ñº</span>
              </button>
              
              <!-- Dropdown Men√º -->
              <div id="projekt-menu" class="hidden absolute left-0 right-0 top-full mt-1 bg-slate-800 rounded-lg shadow-xl z-50 py-1 text-sm">
                <!-- Neu & √ñffnen -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openProjektModal()">
                  <span>üìÑ</span> Neues Projekt...
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); showProjektListe()">
                  <span>üìÇ</span> √ñffnen...
                </button>
                
                <div class="border-t border-white/10 my-1"></div>
                
                <!-- Speichern -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); saveProjektDaten(); alert('üíæ Lokal gespeichert!')">
                  <span>üíæ</span> Speichern
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openModal('showFassungModal')">
                  <span>üìë</span> Fassung speichern...
                </button>
                
                <div class="border-t border-white/10 my-1"></div>
                
                <!-- Cloud -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3 ${!istEingeloggt ? 'opacity-40' : ''}" 
                        onclick="handleCloudSave()"
                        title="${!istEingeloggt ? 'Erst einloggen' : ''}">
                  <span>‚òÅÔ∏è</span> ${istCloudProjekt ? 'In Cloud gespeichert ‚úì' : 'In Cloud speichern...'}
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3 ${!istCloudProjekt ? 'opacity-40' : ''}" 
                        onclick="handleCloudReload()"
                        title="${!istCloudProjekt ? 'Nur f√ºr Cloud-Projekte' : 'Lokale Daten mit Cloud √ºberschreiben'}">
                  <span>üîÑ</span> Von Cloud neu laden
                </button>
                
                <div class="border-t border-white/10 my-1"></div>
                
                <!-- Import/Export -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openModal('showImportModal')">
                  <span>‚¨áÔ∏è</span> Importieren...
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openModal('showExportModal')">
                  <span>‚¨ÜÔ∏è</span> Exportieren...
                </button>
                
                <div class="border-t border-white/10 my-1"></div>
                
                <!-- Einstellungen & L√∂schen -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openProjektModal(state.projektId)">
                  <span>‚öôÔ∏è</span> Projekteinstellungen...
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3 text-red-400" onclick="closeProjektMenu(); deleteProjekt(state.projektId)">
                  <span>üóëÔ∏è</span> Projekt l√∂schen
                </button>
              </div>
            </div>
            
            <!-- Status-Anzeige -->
            <div class="flex items-center justify-between mt-2 text-xs">
              <span class="text-gray-400">${state.projektMeta?.fassung || 'Arbeitsfassung'}</span>
              <span class="${istCloudProjekt ? 'text-green-400' : 'text-yellow-400'}">
                ${istCloudProjekt ? '‚òÅÔ∏è Cloud' : 'üíæ Lokal'}
              </span>
            </div>
          </div>
          
          <!-- Navigation -->
          <nav class="flex-1 py-2 overflow-y-auto">
            <div class="px-3 py-2">
              <div class="nav-section">Module</div>
            </div>
            ${navItems.map(item => `
              <div class="nav-item ${state.currentView === item.id ? 'active' : ''} px-3 py-2 flex items-center gap-2"
                   onclick="navigateTo('${item.id}')">
                <span>${item.icon}</span>
                <span class="text-sm">${item.label}</span>
              </div>
            `).join('')}
          </nav>
          
          <!-- KI-Assistent -->
          <div class="p-3 border-t border-white/10">
            <button class="btn btn-sm w-full ${getApiKey() ? 'btn-purple' : 'btn-outline-light'}" 
                    onclick="toggleKiPanel()"
                    title="${getApiKey() ? 'KI-Assistent √∂ffnen' : 'API-Key in Einstellungen hinterlegen'}">
              ü§ñ KI-Assistent ${getApiKey() ? '' : '(Key fehlt)'}
            </button>
          </div>
          
          <!-- Cloud-Login Status -->
          <div class="p-3 border-t border-white/10 text-xs">
            ${cloudUser ? `
              <div class="flex items-center justify-between">
                <span class="text-green-400 truncate" title="${cloudUser.email}">‚òÅÔ∏è ${cloudUser.email}</span>
                <button class="text-gray-400 hover:text-white" onclick="cloudLogout()">Logout</button>
              </div>
            ` : `
              <button class="w-full text-center text-gray-400 hover:text-white" onclick="state.showCloudModal = true; render()">
                ‚òÅÔ∏è Cloud-Login
              </button>
            `}
          </div>
        </div>
      `;
    }

        function renderHeader() {
      const isCloudProject = currentCloudProjectId && isCloudMode;
      const projektName = state.projektMeta?.titel || 'Neues Projekt';
      return `
        <header class="bg-white border-b border-gray-200 px-4 py-3 flex items-center justify-between">
          <div>
            <h1 class="text-xl font-bold text-gray-800">${getViewTitle()}</h1>
            <p class="text-sm text-gray-500">${getViewSubtitle()}</p>
          </div>
          <div class="flex items-center gap-3">
            <span class="px-2 py-1 ${isCloudProject ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'} rounded-full text-xs font-medium">
              ${isCloudProject ? '‚òÅÔ∏è' : 'üíæ'} ${projektName}
            </span>
            <button class="text-xs text-gray-500 hover:text-blue-600" onclick="openProjektModal(state.projektId)" title="Struktur bearbeiten">
              ‚öôÔ∏è ${(state.projektMeta.eigeneGruppen || []).length} Teile
            </button>
            <span class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-sm font-medium">
              ${state.projektMeta.fassung || 'Arbeitsfassung'}
            </span>
          </div>
        </header>
      `;
    }
    
    function setStrukturTyp(typ) {
      state.projektMeta.strukturTyp = typ;
      saveProjektDaten();
      render();
    }

    function getViewTitle() {
      const titles = {
        textbuch: 'üìù Textbuch',
        szenen: 'üé¨ Szenen',
        figuren: 'üë§ Figuren',
        cues: 'üí° Cue-Listen',
        requisiten: 'üé≠ Requisiten',
        kostueme: 'üëó Kost√ºme',
        medien: 'üìÅ Medien',
        fassungen: 'üìö Fassungen',
      };
      return titles[state.currentView] || 'N!NA-Rebu';
    }

    function getViewSubtitle() {
      const szene = state.szenen.find(s => s.id === state.aktiveSzene);
      if (state.currentView === 'textbuch' && szene) {
        return `Szene ${szene.nummer}: ${szene.titel}`;
      }
      return `${state.szenen.length} Szenen ¬∑ ${state.figuren.length} Figuren ¬∑ ${state.cues.length} Cues`;
    }

    function renderMainContent() {
      switch (state.currentView) {
        case 'titelblatt': return renderTitelblatt();
        case 'textbuch': return renderTextbuch();
        case 'szenen': return renderSzenenView();
        case 'figuren': return renderFigurenView();
        case 'cues': return renderCuesView();
        case 'buehne': return renderBuehneView();
        case 'requisiten': return renderRequisitenView();
        case 'kostueme': return renderKostuemeView();
        case 'medien': return renderMedienView();
        case 'fassungen': return renderFassungenView();
        default: return renderPlaceholder(state.currentView);
      }
    }
    
    // ============================================
    // TITELBLATT VIEW (wie gedrucktes Regiebuch)
    // ============================================
    function renderTitelblatt() {
      const meta = state.projektMeta || {};
      const figuren = state.figuren || [];
      const szenen = state.szenen || [];
      const cues = state.cues || [];
      
      return `
        <div class="flex-1 overflow-y-auto bg-gray-100 p-8">
          <div class="max-w-3xl mx-auto">
            
            <!-- Titelseite -->
            <div class="bg-white rounded-lg shadow-lg p-12 mb-8 text-center">
              ${meta.titelbild ? `
                <img src="${meta.titelbild}" alt="Titelbild" class="w-64 h-auto mx-auto mb-8 rounded-lg shadow">
              ` : `
                <div class="w-64 h-40 mx-auto mb-8 bg-gradient-to-br from-blue-100 to-purple-100 rounded-lg flex items-center justify-center">
                  <span class="text-6xl">üé≠</span>
                </div>
              `}
              
              <h1 class="text-4xl font-bold text-gray-900 mb-2">${meta.titel || 'Unbenannt'}</h1>
              ${meta.untertitel ? `<h2 class="text-xl text-gray-600 mb-4">${meta.untertitel}</h2>` : ''}
              ${meta.autor ? `<p class="text-lg text-gray-500 mb-6">von ${meta.autor}</p>` : ''}
              
              ${meta.tagline ? `<p class="text-lg italic text-gray-600 mb-4">"${meta.tagline}"</p>` : ''}
              ${meta.logline ? `<p class="text-sm text-gray-500 max-w-xl mx-auto mb-8">${meta.logline}</p>` : ''}
              
              <div class="border-t pt-6 mt-6">
                <p class="text-sm text-gray-500">${meta.fassung || 'Arbeitsfassung'}</p>
                ${meta.premiere ? `<p class="text-sm text-gray-400">Premiere: ${new Date(meta.premiere).toLocaleDateString('de-DE')}</p>` : ''}
                ${meta.spielort ? `<p class="text-sm text-gray-400">${meta.spielort}</p>` : ''}
              </div>
              
              ${meta.copyright ? `<p class="text-xs text-gray-400 mt-6">¬© ${meta.copyright}</p>` : ''}
              
              <button class="mt-6 text-sm text-blue-600 hover:text-blue-800" onclick="openProjektModal(state.projektId)">
                ‚úèÔ∏è Bearbeiten
              </button>
            </div>
            
            <!-- Besetzung / Figurenliste -->
            <div class="bg-white rounded-lg shadow-lg p-8 mb-8">
              <h2 class="text-2xl font-bold text-gray-800 mb-6 pb-2 border-b">Besetzung</h2>
              
              ${figuren.length === 0 ? `
                <p class="text-gray-500 italic">Noch keine Figuren angelegt.</p>
                <button class="mt-4 btn btn-outline" onclick="navigateTo('figuren')">+ Figuren hinzuf√ºgen</button>
              ` : `
                <div class="space-y-4">
                  ${figuren.map(f => `
                    <div class="flex items-start gap-4 py-2 border-b border-gray-100 last:border-0">
                      <div class="w-12 h-12 rounded-full bg-blue-100 text-blue-700 flex items-center justify-center font-bold flex-shrink-0">
                        ${f.kuerzel || (f.name || '').substring(0, 2).toUpperCase()}
                      </div>
                      <div class="flex-1">
                        <div class="font-semibold text-gray-800">${f.name || 'Unbenannt'}</div>
                        ${f.beschreibung ? `<div class="text-sm text-gray-500">${f.beschreibung}</div>` : ''}
                      </div>
                      <div class="text-xs text-gray-400">
                        ${state.szenen.filter(s => s.figuren?.includes(f.id)).length} Szenen
                      </div>
                    </div>
                  `).join('')}
                </div>
              `}
            </div>
            
            <!-- Struktur / Szenen√ºbersicht -->
            <div class="bg-white rounded-lg shadow-lg p-8 mb-8">
              <h2 class="text-2xl font-bold text-gray-800 mb-6 pb-2 border-b">Szenen√ºbersicht</h2>
              
              ${szenen.length === 0 ? `
                <p class="text-gray-500 italic">Noch keine Szenen angelegt.</p>
                <button class="mt-4 btn btn-outline" onclick="navigateTo('szenen')">+ Szenen hinzuf√ºgen</button>
              ` : `
                <div class="space-y-2">
                  ${(() => {
                    let html = '';
                    let lastGruppe = null;
                    szenen.forEach((s, idx) => {
                      const gruppe = s.gruppe || 'Ohne Zuordnung';
                      if (gruppe !== lastGruppe) {
                        html += `<h3 class="font-bold text-lg text-gray-700 mt-4 mb-2 pt-2 border-t first:border-0 first:mt-0">${gruppe}</h3>`;
                        lastGruppe = gruppe;
                      }
                      const figurenInSzene = (s.figuren || []).map(fId => {
                        const fig = figuren.find(f => f.id === fId);
                        return fig ? (fig.kuerzel || fig.name?.substring(0,2)) : '';
                      }).filter(Boolean).join(', ');
                      html += `
                        <div class="flex items-center gap-4 py-1 text-sm hover:bg-gray-50 rounded px-2 cursor-pointer" onclick="selectSzene('${s.id}'); navigateTo('textbuch')">
                          <span class="font-mono text-gray-400 w-12">${s.nummer || (idx + 1)}</span>
                          <span class="flex-1">${s.titel || 'Ohne Titel'}</span>
                          <span class="text-gray-400 text-xs">${figurenInSzene || '‚Äì'}</span>
                          <span class="text-gray-400 text-xs">${s.ort || ''}</span>
                        </div>
                      `;
                    });
                    return html;
                  })()}
                </div>
              `}
            </div>
            
            <!-- Technische √úbersicht -->
            <div class="bg-white rounded-lg shadow-lg p-8 mb-8">
              <h2 class="text-2xl font-bold text-gray-800 mb-6 pb-2 border-b">Technische √úbersicht</h2>
              
              <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                  <div class="text-3xl font-bold text-blue-600">${szenen.length}</div>
                  <div class="text-sm text-gray-500">Szenen</div>
                </div>
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                  <div class="text-3xl font-bold text-green-600">${figuren.length}</div>
                  <div class="text-sm text-gray-500">Figuren</div>
                </div>
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                  <div class="text-3xl font-bold text-yellow-600">${cues.length}</div>
                  <div class="text-sm text-gray-500">Cues</div>
                </div>
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                  <div class="text-3xl font-bold text-purple-600">${(state.projektMeta.eigeneGruppen || []).length}</div>
                  <div class="text-sm text-gray-500">Akte/Teile</div>
                </div>
              </div>
              
              <!-- Cue-√úbersicht -->
              ${cues.length > 0 ? `
                <div class="mt-6">
                  <h3 class="font-semibold text-gray-700 mb-3">Cue-Liste</h3>
                  <div class="space-y-1 text-sm max-h-48 overflow-y-auto">
                    ${cues.slice(0, 20).map(c => {
                      const szene = szenen.find(s => s.id === c.szeneId);
                      return `
                        <div class="flex items-center gap-2 py-1 px-2 bg-gray-50 rounded">
                          <span class="cue-badge cue-${c.typ || 'lx'}">${(c.typ || 'LX').toUpperCase()} ${c.nummer || ''}</span>
                          <span class="flex-1 truncate">${c.beschreibung || '‚Äì'}</span>
                          <span class="text-xs text-gray-400">${szene?.nummer || ''}</span>
                        </div>
                      `;
                    }).join('')}
                    ${cues.length > 20 ? `<div class="text-center text-gray-400 text-xs py-2">... und ${cues.length - 20} weitere</div>` : ''}
                  </div>
                </div>
              ` : ''}
            </div>
            
          </div>
        </div>
      `;
    }
    
    // Hilfsfunktion: Szenen-Liste in Array-Reihenfolge (frei verschiebbar)
    function renderGruppierteSzenenListe() {
      // Falls keine Szenen, Hinweis zeigen
      if (state.szenen.length === 0) {
        return '<div class="text-xs text-gray-400 p-2 text-center">Keine Szenen vorhanden</div>';
      }
      
      let html = '';
      let lastGruppe = null;
      
      // Szenen in Array-Reihenfolge durchgehen (NICHT sortiert!)
      state.szenen.forEach((s, idx) => {
        const gruppe = s.gruppe || 'Ohne Zuordnung';
        
        // Gruppen-√úberschrift einf√ºgen wenn sich die Gruppe √§ndert
        if (gruppe !== lastGruppe) {
          html += `<div class="text-xs font-bold text-gray-400 uppercase px-2 py-1 bg-gray-100 rounded mb-1 mt-2">${gruppe}</div>`;
          lastGruppe = gruppe;
        }
        
        html += `
          <div class="szene-item ${s.id === state.aktiveSzene ? 'active' : ''} flex items-center group" 
               onclick="selectSzene('${s.id}')">
            <div class="flex-1 min-w-0">
              <div class="font-medium text-sm">${s.nummer}</div>
              <div class="text-xs text-gray-500 truncate">${s.titel}</div>
            </div>
            <div class="flex flex-col gap-0.5 opacity-0 group-hover:opacity-100 transition-opacity ml-1" onclick="event.stopPropagation()">
              <button class="text-xs text-gray-400 hover:text-blue-600 px-1 ${idx === 0 ? 'invisible' : ''}" onclick="moveSzene('${s.id}', -1)" title="Nach oben">‚ñ≤</button>
              <button class="text-xs text-gray-400 hover:text-blue-600 px-1 ${idx === state.szenen.length - 1 ? 'invisible' : ''}" onclick="moveSzene('${s.id}', 1)" title="Nach unten">‚ñº</button>
            </div>
          </div>
        `;
      });
      
      return html;
    }

    // ============================================
    // TEXTBUCH VIEW (v1.2: mit Streichungs-Button)
    // ============================================
    function renderTextbuch() {
      // Sicherheitspr√ºfung: Wenn keine Szenen vorhanden, automatisch eine erstellen
      if (state.szenen.length === 0) {
        const startSzeneId = genId();
        const startSzene = {
          id: startSzeneId,
          nummer: '1.1',
          titel: 'Start',
          gruppe: '1',
          ort: '',
          zeit: '',
          zusammenfassung: '',
          figuren: []
        };
        state.szenen.push(startSzene);
        state.textbuch[startSzeneId] = '<p class="format-standard"><br></p>';
        state.aktiveSzene = startSzeneId;
        saveProjektDaten();
      }
      
      // Sicherheitspr√ºfung: Wenn keine aktive Szene, erste Szene ausw√§hlen
      if (!state.aktiveSzene && state.szenen.length > 0) {
        state.aktiveSzene = state.szenen[0].id;
      }
      
      const szene = state.szenen.find(s => s.id === state.aktiveSzene);
      let content = state.textbuch[state.aktiveSzene] || '';
      const szeneCues = state.cues.filter(c => c.szeneId === state.aktiveSzene);
      const szeneFiguren = szene?.figuren?.map(fId => state.figuren.find(f => f.id === fId)).filter(Boolean) || [];
      
      // In Technik-Ansicht: Cue-Marker im Text anzeigen
      const displayContent = state.textAnsicht === 'technik' 
        ? enrichTextWithCueMarkers(content, szeneCues) 
        : content;
      
      return `
        <div class="flex-1 flex overflow-hidden">
          <!-- Szenen-Liste links -->
          <div class="w-48 bg-gray-50 border-r border-gray-200 flex flex-col">
            <div class="p-3 border-b border-gray-200 flex items-center justify-between">
              <div class="text-xs font-semibold text-gray-500 uppercase">Szenen</div>
              <button class="btn btn-xs btn-primary" onclick="openSzeneModal()">+</button>
            </div>
            <div class="flex-1 overflow-y-auto p-2">
              ${renderGruppierteSzenenListe()}
            </div>
          </div>
          
          <!-- Editor Mitte -->
          <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Toolbar -->
            <div class="toolbar">
              <select class="format-select" id="format-select" onchange="state.selectedFormat = this.value">
                ${Object.entries(FORMATVORLAGEN).map(([key, val]) => `
                  <option value="${key}" ${state.selectedFormat === key ? 'selected' : ''}>
                    ${val.icon} ${val.name}
                  </option>
                `).join('')}
              </select>
              <button class="toolbar-btn btn-primary" onclick="applySelectedFormat()" title="Format anwenden (Ctrl+Enter)">
                ‚úì Anwenden
              </button>
              
              <div class="toolbar-divider"></div>
              
              <div class="toolbar-group">
                <button class="toolbar-btn" onclick="execCommand('bold')" title="Fett (Ctrl+B)"><b>F</b></button>
                <button class="toolbar-btn" onclick="execCommand('italic')" title="Kursiv (Ctrl+I)"><i>K</i></button>
                <button class="toolbar-btn" onclick="execCommand('underline')" title="Unterstrichen (Ctrl+U)"><u>U</u></button>
                <button class="toolbar-btn" onclick="toggleGestrichen()" title="Als gestrichen markieren" style="color: #ef4444;"><s>X</s></button>
                <button class="toolbar-btn" onclick="toggleErgaenzung()" title="Als Erg√§nzung markieren" style="color: #3b82f6;">+</button>
              </div>
              
              <div class="toolbar-divider"></div>
              
              <div class="toolbar-group">
                <button class="toolbar-btn" id="undo-btn" onclick="undo()" title="R√ºckg√§ngig (Ctrl+Z)">‚Ü©</button>
                <button class="toolbar-btn" id="redo-btn" onclick="redo()" title="Wiederholen (Ctrl+Y)">‚Ü™</button>
              </div>
              
              <div class="toolbar-divider"></div>
              
              <!-- Ansicht-Auswahl -->
              <select class="format-select" style="width: auto; min-width: 140px;" onchange="setTextAnsicht(this.value)">
                <option value="technik" ${state.textAnsicht === 'technik' ? 'selected' : ''}>‚öôÔ∏è¬è Technik</option>
                <option value="schauspieler" ${state.textAnsicht === 'schauspieler' ? 'selected' : ''}>üìñ Schauspieler</option>
                <option value="aenderungen" ${state.textAnsicht === 'aenderungen' ? 'selected' : ''}>üìù √Ñnderungen</option>
              </select>
              
              <div class="toolbar-divider"></div>
              
              <button class="toolbar-btn toolbar-icon-only" onclick="splitSzeneAtCursor()" title="Szene hier teilen ‚Äì Text ab Cursor wird neue Szene">‚úÇÔ∏è<span class="toolbar-label">Teilen</span></button>
              <button class="toolbar-btn toolbar-icon-only" onclick="cleanupFormatting()" title="Formatierung bereinigen ‚Äì Word-Styles entfernen">üßπ<span class="toolbar-label">Bereinigen</span></button>
            </div>
            
            <!-- Editor -->
            <div class="flex-1 overflow-y-auto p-4 bg-gray-100">
              <div class="editor-container max-w-4xl mx-auto shadow-lg">
                <div id="text-editor" 
                     class="editor-content ${getEditorClasses()}"
                     contenteditable="true"
                     spellcheck="true">${displayContent}</div>
              </div>
            </div>
          </div>
          
          <!-- Details rechts -->
          <div class="details-panel w-64 overflow-y-auto">
            <!-- Szenen-Info -->
            <div class="detail-section">
              <div class="detail-label">Szene bearbeiten</div>
              ${szene ? `
                <div class="space-y-2">
                  <div class="grid grid-cols-3 gap-2">
                    <div>
                      <label class="text-xs text-gray-500">Nr.</label>
                      <input type="text" value="${szene.nummer}" class="text-sm"
                             onchange="updateSzene('${szene.id}', 'nummer', this.value)">
                    </div>
                    <div class="col-span-2">
                      <label class="text-xs text-gray-500">Akt/Teil/Gruppe</label>
                      <input type="text" list="gruppe-options-${szene.id}" value="${szene.gruppe || ''}" class="text-sm"
                             onchange="updateSzene('${szene.id}', 'gruppe', this.value)"
                             placeholder="z.B. Erster Akt, Prolog, Episode 1...">
                      <datalist id="gruppe-options-${szene.id}">
                        ${getAktuelleGruppen().map(g => `<option value="${g}">`).join('')}
                      </datalist>
                    </div>
                  </div>
                  <div>
                    <label class="text-xs text-gray-500">Titel</label>
                    <input type="text" value="${szene.titel}" class="text-sm"
                           onchange="updateSzene('${szene.id}', 'titel', this.value)">
                  </div>
                  <div class="grid grid-cols-2 gap-2">
                    <div>
                      <label class="text-xs text-gray-500">Ort</label>
                      <input type="text" value="${szene.ort || ''}" class="text-sm" placeholder="Wo?"
                             onchange="updateSzene('${szene.id}', 'ort', this.value)">
                    </div>
                    <div>
                      <label class="text-xs text-gray-500">Zeit</label>
                      <input type="text" value="${szene.zeit || ''}" class="text-sm" placeholder="Wann?"
                             onchange="updateSzene('${szene.id}', 'zeit', this.value)">
                    </div>
                  </div>
                  <div>
                    <label class="text-xs text-gray-500">Zusammenfassung</label>
                    <textarea rows="2" class="text-sm" placeholder="Was passiert?"
                              onchange="updateSzene('${szene.id}', 'zusammenfassung', this.value)">${szene.zusammenfassung || ''}</textarea>
                  </div>
                </div>
              ` : '<p class="text-sm text-gray-400">Keine Szene ausgew√§hlt</p>'}
            </div>
            
            <!-- Figuren in Szene (kompakt) -->
            <div class="detail-section">
              <div class="flex items-center justify-between mb-2">
                <div class="detail-label">Figuren</div>
                <select class="text-xs border rounded px-1 py-0.5" style="max-width: 120px;"
                        onchange="if(this.value) { toggleFigurInSzene('${szene?.id}', this.value, true); this.value=''; }">
                  <option value="">+ hinzuf√ºgen...</option>
                  ${state.figuren.filter(f => f && f.name && !szene?.figuren?.includes(f.id)).map(f => `
                    <option value="${f.id}">${f.kuerzel || (f.name || '').substring(0,2)} ‚Äì ${f.name || 'Unbenannt'}</option>
                  `).join('')}
                </select>
              </div>
              <div class="flex flex-wrap gap-1">
                ${szene?.figuren?.length > 0 ? szene.figuren.map(fId => {
                  const f = state.figuren.find(fig => fig.id === fId);
                  if (!f) return '';
                  return `
                    <span class="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-xs">
                      <span class="font-medium">${f.kuerzel || (f.name || '').substring(0,2)}</span>
                      <button class="hover:text-red-600" onclick="toggleFigurInSzene('${szene.id}', '${f.id}', false)" title="Entfernen">√ó</button>
                    </span>
                  `;
                }).join('') : '<span class="text-xs text-gray-400">Keine Figuren</span>'}
              </div>
            </div>
            
            <!-- Cues -->
            <div class="detail-section">
              <div class="flex items-center justify-between mb-2">
                <div class="detail-label">Cues</div>
                <button class="btn btn-xs btn-outline" onclick="openCueModal()">+ Cue</button>
              </div>
              <div class="space-y-1">
                ${szeneCues.length > 0 ? szeneCues.map(c => `
                  <div class="p-1.5 hover:bg-gray-100 rounded cursor-pointer text-xs"
                       onclick="editCue('${c.id}')">
                    <div class="flex items-center gap-1">
                      <span class="cue-badge ${CUE_TYPEN[c.typ]?.class || 'cue-lx'}" style="font-size: 10px; padding: 1px 4px;">
                        ${CUE_TYPEN[c.typ]?.prefix || 'LX'}${c.nummer}
                      </span>
                      <span class="text-gray-600 truncate flex-1">${c.beschreibung || '‚Äì'}</span>
                    </div>
                    ${c.ankerText ? `
                      <div class="text-gray-400 mt-0.5 pl-1 border-l border-purple-200 italic truncate" title="${escapeHtml(c.ankerText)}">
                        üîç "${c.ankerText.length > 30 ? c.ankerText.substring(0, 30) + '...' : c.ankerText}"
                      </div>
                    ` : ''}
                  </div>
                `).join('') : '<p class="text-xs text-gray-400">Keine Cues</p>'}
              </div>
            </div>
            
            <!-- Medien dieser Szene -->
            <div class="detail-section">
              <div class="flex items-center justify-between mb-2">
                <div class="detail-label">üéµ Medien</div>
                <button class="btn btn-xs btn-outline" onclick="navigateTo('medien')">Alle</button>
              </div>
              ${renderSzeneMedien(szene?.id)}
            </div>
            
            <!-- Format-Shortcuts (ganz unten) - nur Anzeige, kein Klick -->
            <div class="detail-section border-t pt-3 mt-3">
              <div class="detail-label text-gray-400">FORMATE (CTRL+SHIFT+...)</div>
              <div id="format-indicator" class="text-xs space-y-0.5 font-mono">
                <div class="format-item px-1.5 py-0.5 rounded" data-format="dialog">
                  <span class="font-bold text-blue-600">D</span> Dialog
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="regieanweisung">
                  <span class="font-bold text-blue-600">R</span> Regieanweisung
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="szeneTitel">
                  <span class="font-bold text-blue-600">T</span> Szenen-Titel
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="aktTitel">
                  <span class="font-bold text-blue-600">A</span> Akt-Titel
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="lied">
                  <span class="font-bold text-blue-600">L</span> Lied
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="vers">
                  <span class="font-bold text-blue-600">V</span> Vers
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="pause">
                  <span class="font-bold text-blue-600">P</span> Pause
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="standard">
                  <span class="font-bold text-blue-600">N</span> Normal
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // ============================================
    // SZENEN VIEW
    // ============================================
    function renderSzenenView() {
      const strukturTyp = state.projektMeta?.strukturTyp || 'akte';
      const struktur = STRUKTUR_TYPEN[strukturTyp];
      
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-5xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold">Alle Szenen (${state.szenen.length})</h2>
              <button class="btn btn-primary" onclick="openSzeneModal()">+ Neue Szene</button>
            </div>
            
            <div class="space-y-6">
              ${renderSzenenNachGruppen(struktur)}
            </div>
            
            ${state.szenen.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üé¨</div>
                <p>Noch keine Szenen vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openSzeneModal()">Erste Szene erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    function renderSzenenNachGruppen(struktur) {
      // Szenen nach Gruppe gruppieren
      const gruppen = {};
      state.szenen.forEach(s => {
        const gruppe = s.gruppe || '1';
        if (!gruppen[gruppe]) gruppen[gruppe] = [];
        gruppen[gruppe].push(s);
      });
      
      // Gruppen sortieren
      const sortierteGruppen = Object.keys(gruppen).sort((a, b) => {
        const indexA = struktur.gruppen.indexOf(a);
        const indexB = struktur.gruppen.indexOf(b);
        return (indexA === -1 ? 999 : indexA) - (indexB === -1 ? 999 : indexB);
      });
      
      if (sortierteGruppen.length === 0) return '';
      
      return sortierteGruppen.map(gruppeId => {
        const gruppenName = struktur.gruppenNamen[gruppeId] || `${struktur.gruppenLabel} ${gruppeId}`;
        const szenen = gruppen[gruppeId];
        
        return `
          <div class="card overflow-hidden">
            <div class="bg-gray-100 px-4 py-2 border-b">
              <h3 class="font-semibold text-gray-700">${gruppenName}</h3>
            </div>
            <div class="divide-y divide-gray-100">
              ${szenen.map(s => {
                const figurenNamen = s.figuren?.map(fId => {
                  const f = state.figuren.find(fig => fig.id === fId);
                  return f ? `<span class="figur-badge">${f.kuerzel || (f.name || '').substring(0,2)}</span>` : '';
                }).join('') || '<span class="text-gray-400 text-sm">‚Äì</span>';
                const cueCount = state.cues.filter(c => c.szeneId === s.id).length;
                
                return `
                  <div class="p-4 hover:bg-blue-50 cursor-pointer transition-colors" onclick="editSzene('${s.id}')">
                    <div class="flex items-start gap-4">
                      <div class="w-12 h-12 rounded bg-blue-100 text-blue-700 flex items-center justify-center font-bold text-lg flex-shrink-0">
                        ${s.nummer}
                      </div>
                      <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2 flex-wrap">
                          <h4 class="font-semibold">${s.titel}</h4>
                          ${s.ort ? `<span class="text-xs bg-gray-100 px-2 py-0.5 rounded">üîç ${s.ort}</span>` : ''}
                          ${s.zeit ? `<span class="text-xs bg-gray-100 px-2 py-0.5 rounded">üïê ${s.zeit}</span>` : ''}
                          ${cueCount > 0 ? `<span class="text-xs bg-yellow-100 text-yellow-700 px-2 py-0.5 rounded">üí° ${cueCount} Cues</span>` : ''}
                        </div>
                        ${s.zusammenfassung ? `<p class="text-sm text-gray-500 mt-1 line-clamp-2">${s.zusammenfassung}</p>` : ''}
                        <div class="flex items-center gap-2 mt-2">
                          <span class="text-xs text-gray-400">Figuren:</span>
                          ${figurenNamen}
                        </div>
                      </div>
                      <div class="flex gap-1 flex-shrink-0">
                        <button class="btn btn-xs btn-outline" onclick="event.stopPropagation(); selectSzene('${s.id}'); navigateTo('textbuch');" title="Text bearbeiten">
                          üìù
                        </button>
                        <button class="btn btn-xs btn-danger" onclick="event.stopPropagation(); deleteSzene('${s.id}')" title="L√∂schen">
                          üóëÔ∏è¬è
                        </button>
                      </div>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }).join('');
    }

    // ============================================
    // FIGUREN VIEW
    // ============================================
    function renderFigurenView() {
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-5xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold">Figuren (${state.figuren.length})</h2>
              <button class="btn btn-primary" onclick="openFigurModal()">+ Neue Figur</button>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              ${state.figuren.map(f => {
                const szenenCount = state.szenen.filter(s => s.figuren?.includes(f.id)).length;
                return `
                  <div class="card p-4 hover:shadow-md transition-shadow cursor-pointer" onclick="editFigur('${f.id}')">
                    <div class="flex items-start gap-4">
                      <div class="w-14 h-14 rounded-full bg-blue-100 text-blue-700 flex items-center justify-center font-bold text-xl flex-shrink-0">
                        ${f.kuerzel || (f.name || '').substring(0, 2)}
                      </div>
                      <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2">
                          <h3 class="font-semibold text-lg">${f.name || 'Unbenannt'}</h3>
                          <span class="text-xs bg-gray-100 px-2 py-0.5 rounded">${szenenCount} Szenen</span>
                        </div>
                        <p class="text-sm text-gray-500 mt-1">${f.beschreibung || 'Keine Beschreibung'}</p>
                        ${f.want ? `<p class="text-xs text-gray-400 mt-2"><strong>Will:</strong> ${f.want}</p>` : ''}
                        ${f.need ? `<p class="text-xs text-gray-400"><strong>Braucht:</strong> ${f.need}</p>` : ''}
                      </div>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
            
            ${state.figuren.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üë§</div>
                <p>Noch keine Figuren vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openFigurModal()">Erste Figur erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }

    // ============================================
    // CUES VIEW
    // ============================================
    function renderCuesView() {
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-5xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold">Cue-Listen (${state.cues.length} Cues)</h2>
              <div class="flex gap-2">
                <button class="btn btn-outline" onclick="openCueExportDialog()">üìÑ Export</button>
                <button class="btn btn-primary" onclick="openCueModal()">+ Neuer Cue</button>
              </div>
            </div>
            
            <div class="grid grid-cols-2 gap-6">
              ${Object.entries(CUE_TYPEN).map(([key, typ]) => {
                const cues = state.cues.filter(c => c.typ === key).sort((a, b) => a.nummer - b.nummer);
                return `
                  <div class="card ${key === 'u' ? 'col-span-2' : ''}">
                    <div class="p-4 border-b border-gray-200 flex items-center gap-2">
                      <span class="text-2xl">${typ.icon}</span>
                      <h3 class="font-semibold">${typ.name}-Cues</h3>
                      <span class="ml-auto bg-gray-100 px-2 py-1 rounded text-sm font-medium">${cues.length}</span>
                    </div>
                    <div class="p-4">
                      ${cues.length > 0 ? `
                        <div class="space-y-2">
                          ${cues.map(c => {
                            const szene = state.szenen.find(s => s.id === c.szeneId);
                            // Verkn√ºpfte Elemente
                            const requisit = c.requisitenId ? state.requisiten.find(r => r.id === c.requisitenId) : null;
                            const medium = c.mediumId ? state.medien.find(m => m.id === c.mediumId) : null;
                            
                            // F√ºr Umbau
                            const umbauVon = c.umbauVon ? state.buehne.find(b => b.id === c.umbauVon) : null;
                            const umbauNach = c.umbauNach ? state.buehne.find(b => b.id === c.umbauNach) : null;
                            
                            // Info-Text je nach Typ
                            let infoText = '';
                            if (requisit) {
                              infoText = `<span class="text-xs text-purple-600">üîó ${requisit.name}</span>`;
                            } else if (medium) {
                              infoText = `<span class="text-xs text-green-600">üîó ${medium.name}</span>`;
                            } else if (c.mediumGeplant) {
                              infoText = `<span class="text-xs text-orange-500">‚è≥ ${c.mediumGeplant} (geplant)</span>`;
                            } else if (key === 'u' && (umbauVon || umbauNach)) {
                              infoText = `<span class="text-xs text-orange-600">üé™ ${umbauVon?.name || '?'} ‚Üí ${umbauNach?.name || '?'}</span>`;
                              if (c.umbauAktionen?.length > 0) {
                                infoText += `<span class="text-xs text-gray-500 ml-2">(${c.umbauAktionen.length} Aktionen)</span>`;
                              }
                            }
                            
                            // Ankertext als Stichwort
                            const stichwort = c.ankerText 
                              ? `<div class="text-xs text-purple-600 italic mt-1 truncate" title="${escapeHtml(c.ankerText)}">üîç ‚Äû${c.ankerText.length > 50 ? c.ankerText.substring(0, 50) + '...' : c.ankerText}"</div>`
                              : '';
                            
                            return `
                              <div class="p-2 bg-gray-50 rounded hover:bg-gray-100 cursor-pointer"
                                   onclick="editCue('${c.id}')">
                                <div class="flex items-center gap-2">
                                  <span class="cue-badge ${typ.class}">${typ.prefix}${c.nummer}</span>
                                  <div class="flex-1 min-w-0">
                                    <span class="text-sm truncate block">${c.beschreibung || '‚Äì'}</span>
                                    ${infoText}
                                  </div>
                                  <span class="text-xs text-gray-400 whitespace-nowrap">${szene?.nummer || '‚Äì'}</span>
                                </div>
                                ${stichwort}
                              </div>
                            `;
                          }).join('')}
                        </div>
                      ` : `
                        <p class="text-sm text-gray-400 text-center py-4">Keine ${typ.name}-Cues</p>
                      `}
                      <button class="btn btn-sm btn-outline w-full mt-3" onclick="openCueModal('${key}')">
                        + ${typ.prefix}-Cue hinzuf√ºgen
                      </button>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        </div>
      `;
    }

    // ============================================
    // KOST√úME VIEW (v1.2: implementiert)
    // ============================================
    function renderKostuemeView() {
      // Bilder asynchron laden
      setTimeout(loadKostuemBilder, 100);
      
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-6xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <div>
                <h2 class="text-lg font-semibold">üëó Kost√ºme & Masken (${state.kostueme.length})</h2>
              </div>
              <div class="flex gap-2">
                <button class="btn btn-outline" onclick="exportKostuemeList()">üìÑ Export</button>
                <button class="btn btn-primary" onclick="openKostuemModal()">+ Neues Kost√ºm</button>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              ${state.kostueme.map(k => {
                const figur = state.figuren.find(f => f.id === k.figur);
                const szenenCount = k.szenen?.length || 0;
                // Bilder-Arrays (mit Fallback f√ºr alte Daten)
                const kostuemBilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
                const maskeBilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
                const hasImages = kostuemBilder.length > 0 || maskeBilder.length > 0;
                
                return `
                  <div class="kostuem-card cursor-pointer" onclick="editKostuem('${k.id}')">
                    <!-- Bilder -->
                    ${hasImages ? `
                      <div class="p-3 bg-gray-50 border-b">
                        ${kostuemBilder.length > 0 ? `
                          <div class="mb-2">
                            <span class="text-xs text-gray-500 mb-1 block">üëó Kost√ºm (${kostuemBilder.length})</span>
                            <div class="image-grid">
                              ${kostuemBilder.slice(0, 3).map((imgId, i) => `
                                <img src="${imageUrlCache[imgId] || ''}" 
                                     class="image-thumb" 
                                     id="img-kostuem-${k.id}-${i}"
                                     onclick="event.stopPropagation(); openKostuemGallery('${k.id}', 'kostuem', ${i})">
                              `).join('')}
                              ${kostuemBilder.length > 3 ? `<div class="add-image-btn" style="cursor:pointer;" onclick="event.stopPropagation(); openKostuemGallery('${k.id}', 'kostuem', 0)">+${kostuemBilder.length - 3}</div>` : ''}
                            </div>
                          </div>
                        ` : ''}
                        ${maskeBilder.length > 0 ? `
                          <div>
                            <span class="text-xs text-gray-500 mb-1 block">üé≠ Maske (${maskeBilder.length})</span>
                            <div class="image-grid">
                              ${maskeBilder.slice(0, 3).map((imgId, i) => `
                                <img src="${imageUrlCache[imgId] || ''}" 
                                     class="image-thumb" 
                                     id="img-maske-${k.id}-${i}"
                                     onclick="event.stopPropagation(); openKostuemGallery('${k.id}', 'maske', ${i})">
                              `).join('')}
                              ${maskeBilder.length > 3 ? `<div class="add-image-btn" style="cursor:pointer;" onclick="event.stopPropagation(); openKostuemGallery('${k.id}', 'maske', 0)">+${maskeBilder.length - 3}</div>` : ''}
                            </div>
                          </div>
                        ` : ''}
                      </div>
                    ` : ''}
                    
                    <div class="p-4 bg-purple-50 border-b border-purple-100">
                      <div class="flex items-center gap-2">
                        <span class="text-2xl">üëó</span>
                        <div class="flex-1">
                          <h3 class="font-semibold">${k.name}</h3>
                          <p class="text-xs text-purple-600">${figur?.name || 'Keine Figur'}</p>
                        </div>
                      </div>
                    </div>
                    <div class="p-4">
                      ${k.beschreibung ? `<p class="text-sm text-gray-600 mb-2">üëó ${k.beschreibung}</p>` : ''}
                      ${k.maske ? `<p class="text-sm text-gray-600 mb-2">üé≠ ${k.maske}</p>` : ''}
                      <div class="flex items-center gap-2 text-xs text-gray-400">
                        <span>üé¨ ${szenenCount} Szenen</span>
                      </div>
                      ${k.notizen ? `<p class="text-xs text-orange-500 mt-2">üìå ${k.notizen}</p>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
            
            ${state.kostueme.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üëó</div>
                <p>Noch keine Kost√ºme vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openKostuemModal()">Erstes Kost√ºm erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    // Kost√ºm-Bilder asynchron nachladen
    async function loadKostuemBilder() {
      for (const k of state.kostueme) {
        // Neue Array-Struktur
        const kostuemBilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
        const maskeBilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
        
        for (let i = 0; i < kostuemBilder.length; i++) {
          const imgId = kostuemBilder[i];
          if (!imageUrlCache[imgId]) {
            const url = await getImageUrl(imgId);
            if (url) {
              const img = document.getElementById(`img-kostuem-${k.id}-${i}`);
              if (img) img.src = url;
            }
          }
        }
        
        for (let i = 0; i < maskeBilder.length; i++) {
          const imgId = maskeBilder[i];
          if (!imageUrlCache[imgId]) {
            const url = await getImageUrl(imgId);
            if (url) {
              const img = document.getElementById(`img-maske-${k.id}-${i}`);
              if (img) img.src = url;
            }
          }
        }
      }
    }
    
    function openKostuemGallery(kostuemId, type, startIndex = 0) {
      const k = state.kostueme.find(x => x.id === kostuemId);
      if (!k) return;
      
      // Bilder je nach Typ
      let bilder;
      if (type === 'kostuem') {
        bilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
      } else {
        bilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
      }
      
      const urls = bilder.map(id => imageUrlCache[id]).filter(Boolean);
      
      if (urls.length > 0) {
        openLightbox(urls, startIndex);
      }
    }
    
    async function exportKostuemeList() {
      // Bilder als Base64 laden
      const bilderBase64 = {};
      for (const k of state.kostueme) {
        if (k.kostuemBilder) {
          for (const imgId of k.kostuemBilder) {
            if (!bilderBase64[imgId]) bilderBase64[imgId] = await getImageAsBase64(imgId);
          }
        }
        if (k.maskeBilder) {
          for (const imgId of k.maskeBilder) {
            if (!bilderBase64[imgId]) bilderBase64[imgId] = await getImageAsBase64(imgId);
          }
        }
        // Fallback f√ºr alte Daten mit einzelnem Bild
        if (k.kostuemBildId && !bilderBase64[k.kostuemBildId]) {
          bilderBase64[k.kostuemBildId] = await getImageAsBase64(k.kostuemBildId);
        }
        if (k.maskeBildId && !bilderBase64[k.maskeBildId]) {
          bilderBase64[k.maskeBildId] = await getImageAsBase64(k.maskeBildId);
        }
      }
      
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Kost√ºme - ${state.projektMeta.titel}</title>
        <style>
          body{font-family:Arial,sans-serif;padding:20px;} 
          .item{margin-bottom:30px;border:1px solid #ddd;padding:15px;page-break-inside:avoid;} 
          .images{display:flex;flex-wrap:wrap;gap:15px;margin:10px 0;}
          .image-box{text-align:center;}
          img{max-width:150px;max-height:150px;}
          h2{margin-bottom:10px;}
          @media print { .no-print{display:none;} }
        </style></head><body>`;
      html += `<div class="no-print" style="margin-bottom:20px;"><button onclick="window.print()" style="padding:10px 20px;font-size:16px;">üñ®Ô∏è¬è Als PDF drucken</button></div>`;
      html += `<h1>Kost√ºme & Masken: ${state.projektMeta.titel}</h1>`;
      html += `<p>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      
      state.kostueme.forEach(k => {
        const figur = state.figuren.find(f => f.id === k.figur);
        const szenenNamen = k.szenen?.map(sId => state.szenen.find(s => s.id === sId)?.nummer).filter(Boolean).join(', ') || '‚Äì';
        
        html += `<div class="item">`;
        html += `<h2>üëó ${k.name}</h2>`;
        html += `<p><strong>Figur:</strong> ${figur?.name || '‚Äì'}</p>`;
        html += `<p><strong>Szenen:</strong> ${szenenNamen}</p>`;
        
        // Kost√ºm-Bilder
        const kostuemBilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
        const maskeBilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
        
        if (kostuemBilder.length > 0 || maskeBilder.length > 0) {
          html += `<div class="images">`;
          kostuemBilder.forEach(imgId => {
            if (bilderBase64[imgId]) html += `<div class="image-box"><img src="${bilderBase64[imgId]}"><br><small>Kost√ºm</small></div>`;
          });
          maskeBilder.forEach(imgId => {
            if (bilderBase64[imgId]) html += `<div class="image-box"><img src="${bilderBase64[imgId]}"><br><small>Maske</small></div>`;
          });
          html += `</div>`;
        }
        
        if (k.beschreibung) html += `<p><strong>Kost√ºm:</strong> ${k.beschreibung}</p>`;
        if (k.maske) html += `<p><strong>Maske:</strong> ${k.maske}</p>`;
        if (k.notizen) html += `<p><em>Notizen: ${k.notizen}</em></p>`;
        html += `</div>`;
      });
      
      html += `</body></html>`;
      openExportWindow(html, 'kostueme-liste');
    }

    // ============================================
    // LIGHTBOX (Bildvergr√∂√üerung)
    // ============================================
    function openLightbox(images, startIndex = 0) {
      state.lightboxImages = images;
      state.lightboxIndex = startIndex;
      state.showLightbox = true;
      render();
    }
    
    function closeLightbox() {
      state.showLightbox = false;
      render();
    }
    
    function lightboxPrev() {
      state.lightboxIndex = (state.lightboxIndex - 1 + state.lightboxImages.length) % state.lightboxImages.length;
      render();
    }
    
    function lightboxNext() {
      state.lightboxIndex = (state.lightboxIndex + 1) % state.lightboxImages.length;
      render();
    }
    
    function renderLightbox() {
      const images = state.lightboxImages;
      const idx = state.lightboxIndex;
      if (!images || images.length === 0) return '';
      
      const currentImg = images[idx];
      const showNav = images.length > 1;
      
      return `
        <div class="lightbox-overlay" onclick="closeLightbox()">
          <span class="lightbox-close" onclick="closeLightbox()">‚úï</span>
          ${showNav ? `<span class="lightbox-nav prev" onclick="event.stopPropagation(); lightboxPrev()">‚ùÆ</span>` : ''}
          <img src="${currentImg}" class="lightbox-content" onclick="event.stopPropagation()">
          ${showNav ? `<span class="lightbox-nav next" onclick="event.stopPropagation(); lightboxNext()">‚ùØ</span>` : ''}
          ${showNav ? `<div class="lightbox-counter">${idx + 1} / ${images.length}</div>` : ''}
        </div>
      `;
    }

    // ============================================
    // B√úHNE VIEW (v1.3)
    // ============================================
    function renderBuehneView() {
      setTimeout(loadBuehneImages, 100);
      
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-6xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <div>
                <h2 class="text-lg font-semibold">üé™ B√ºhne</h2>
                <p class="text-sm text-gray-500">B√ºhnenpl√§ne, Skizzen und Referenzbilder</p>
              </div>
              <div class="flex gap-2">
                <button class="btn btn-outline" onclick="exportBuehneList()">üìÑ Export</button>
                <button class="btn btn-primary" onclick="openBuehneModal()">+ Neues Element</button>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              ${state.buehne.map(b => {
                return `
                  <div class="card cursor-pointer hover:shadow-md" onclick="editBuehne('${b.id}')">
                    <!-- Bilder -->
                    ${b.bilder?.length > 0 ? `
                      <div class="p-2 bg-gray-50 border-b">
                        <div class="image-grid">
                          ${b.bilder.slice(0, 4).map((imgId, i) => `
                            <img src="${imageUrlCache[imgId] || ''}" 
                                 class="image-thumb" 
                                 id="buehne-img-${b.id}-${i}"
                                 onclick="event.stopPropagation(); openBuehneGallery('${b.id}')"
                                 alt="">
                          `).join('')}
                          ${b.bilder.length > 4 ? `<div class="add-image-btn">+${b.bilder.length - 4}</div>` : ''}
                        </div>
                      </div>
                    ` : ''}
                    <div class="p-4">
                      <h3 class="font-semibold mb-1">${b.name}</h3>
                      <p class="text-xs text-purple-600 mb-2">${b.kategorie || 'Allgemein'}</p>
                      ${b.beschreibung ? `<p class="text-sm text-gray-600 mb-2">${b.beschreibung}</p>` : ''}
                      ${b.notizen ? `<p class="text-xs text-orange-500">üìå ${b.notizen}</p>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
            
            ${state.buehne.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üé™</div>
                <p>Noch keine B√ºhnenelemente vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openBuehneModal()">Erstes Element erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    async function loadBuehneImages() {
      for (const b of state.buehne) {
        if (b.bilder) {
          for (let i = 0; i < b.bilder.length; i++) {
            const imgId = b.bilder[i];
            if (!imageUrlCache[imgId]) {
              const url = await getImageUrl(imgId);
              if (url) {
                const img = document.getElementById(`buehne-img-${b.id}-${i}`);
                if (img) img.src = url;
              }
            }
          }
        }
      }
    }
    
    function openBuehneGallery(buehneId) {
      const b = state.buehne.find(x => x.id === buehneId);
      if (b?.bilder?.length > 0) {
        const urls = b.bilder.map(id => imageUrlCache[id]).filter(Boolean);
        if (urls.length > 0) openLightbox(urls, 0);
      }
    }

    // ============================================
    // REQUISITEN VIEW (v1.3)
    // ============================================
    function renderRequisitenView() {
      setTimeout(loadRequisitenImages, 100);
      
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-6xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <div>
                <h2 class="text-lg font-semibold">üé≠ Requisiten</h2>
                <p class="text-sm text-gray-500">Requisiten-Verwaltung mit Zust√§ndigkeiten</p>
              </div>
              <div class="flex gap-2">
                <button class="btn btn-outline" onclick="exportRequisitenList()">üìÑ Export</button>
                <button class="btn btn-primary" onclick="openRequisitenModal()">+ Neue Requisite</button>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              ${state.requisiten.map(r => {
                const szenenNamen = r.szenen?.map(sId => {
                  const s = state.szenen.find(sz => sz.id === sId);
                  return s?.nummer || '';
                }).filter(Boolean).join(', ') || '‚Äì';
                
                return `
                  <div class="card cursor-pointer hover:shadow-md" onclick="editRequisit('${r.id}')">
                    <!-- Bilder -->
                    ${r.bilder?.length > 0 ? `
                      <div class="p-2 bg-gray-50 border-b">
                        <div class="image-grid">
                          ${r.bilder.slice(0, 4).map((imgId, i) => `
                            <img src="${imageUrlCache[imgId] || ''}" 
                                 class="image-thumb" 
                                 id="requisit-img-${r.id}-${i}"
                                 onclick="event.stopPropagation(); openRequisitenGallery('${r.id}')"
                                 alt="">
                          `).join('')}
                          ${r.bilder.length > 4 ? `<div class="add-image-btn">+${r.bilder.length - 4}</div>` : ''}
                        </div>
                      </div>
                    ` : ''}
                    <div class="p-4">
                      <h3 class="font-semibold mb-1">üé≠ ${r.name}</h3>
                      ${r.beschreibung ? `<p class="text-sm text-gray-600 mb-2">${r.beschreibung}</p>` : ''}
                      <div class="flex flex-wrap gap-2 text-xs mb-2">
                        ${r.zustaendig ? `<span class="bg-blue-100 text-blue-700 px-2 py-1 rounded">üë§ ${r.zustaendig}</span>` : ''}
                        <span class="bg-gray-100 text-gray-600 px-2 py-1 rounded">üé¨ ${szenenNamen}</span>
                      </div>
                      ${r.notizen ? `<p class="text-xs text-orange-500">üìå ${r.notizen}</p>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
            
            ${state.requisiten.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üé≠</div>
                <p>Noch keine Requisiten vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openRequisitenModal()">Erste Requisite erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    async function loadRequisitenImages() {
      for (const r of state.requisiten) {
        if (r.bilder) {
          for (let i = 0; i < r.bilder.length; i++) {
            const imgId = r.bilder[i];
            if (!imageUrlCache[imgId]) {
              const url = await getImageUrl(imgId);
              if (url) {
                const img = document.getElementById(`requisit-img-${r.id}-${i}`);
                if (img) img.src = url;
              }
            }
          }
        }
      }
    }
    
    function openRequisitenGallery(reqId) {
      const r = state.requisiten.find(x => x.id === reqId);
      if (r?.bilder?.length > 0) {
        const urls = r.bilder.map(id => imageUrlCache[id]).filter(Boolean);
        if (urls.length > 0) openLightbox(urls, 0);
      }
    }

    // ============================================
    // FASSUNGEN VIEW (v1.2: mit Uhrzeit)
    // ============================================
    function renderFassungenView() {
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-3xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold">Fassungs-Archiv</h2>
              <button class="btn btn-success" onclick="openModal('showFassungModal')">
                üíæ Aktuelle Fassung speichern
              </button>
            </div>
            
            <!-- Warnhinweis -->
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
              <div style="display: flex; align-items: flex-start; gap: 10px;">
                <span style="font-size: 20px;">‚ö†Ô∏è¬è</span>
                <div>
                  <p style="font-size: 13px; font-weight: 600; color: #92400e; margin: 0 0 4px 0;">Nur lokal im Browser gespeichert!</p>
                  <p style="font-size: 12px; color: #a16207; margin: 0;">
                    Alle Fassungen werden nur im Browser-Cache gespeichert. Bei Cache-L√∂schung, Browser-Wechsel oder anderem Computer sind sie <strong>nicht verf√ºgbar</strong>.<br>
                    ‚Üí F√ºr sichere Sicherung: <strong>Export ‚Üí Projekt-Backup (.json)</strong>
                  </p>
                </div>
              </div>
            </div>
            
            <div class="card overflow-hidden">
              <!-- Aktuelle Fassung -->
              <div class="p-4 bg-green-50 border-b-2 border-green-200">
                <div class="flex items-center gap-3">
                  <span class="px-2 py-1 bg-green-500 text-white text-xs font-semibold rounded">AKTIV</span>
                  <span class="font-semibold">${state.projektMeta.fassung}</span>
                  <span class="text-sm text-gray-500 ml-auto">${formatDateTime(state.projektMeta.fassungsDatum)}</span>
                </div>
              </div>
              
              <!-- Archivierte Fassungen -->
              ${state.fassungen.length > 0 ? `
                <div class="divide-y divide-gray-200">
                  ${state.fassungen.slice().reverse().map(f => `
                    <div class="p-4 flex items-center hover:bg-gray-50">
                      <div class="flex-1">
                        <div class="font-medium">${f.name}</div>
                        <div class="text-sm text-gray-500">${formatDateTime(f.datum)}</div>
                      </div>
                      <button class="btn btn-sm btn-outline" onclick="fassungLaden('${f.id}')">
                        üìÇ Laden
                      </button>
                    </div>
                  `).join('')}
                </div>
              ` : `
                <div class="p-8 text-center text-gray-400">
                  <div class="text-4xl mb-2">üìö</div>
                  <p>Noch keine archivierten Fassungen.</p>
                  <p class="text-sm mt-2">Speichere nach jeder Probe eine neue Fassung,<br>um √Ñnderungen nachverfolgen zu k√∂nnen.</p>
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }


    // ============================================
    // SZENE-MEDIEN (f√ºr Textbuch-Sidebar)
    // ============================================
    function renderSzeneMedien(szeneId) {
      if (!szeneId) {
        return '<p class="text-sm text-gray-400">Keine Szene ausgew√§hlt</p>';
      }
      
      const szeneMedien = state.medien.filter(m => m.szenen?.includes(szeneId));
      
      if (szeneMedien.length === 0) {
        return `
          <p class="text-sm text-gray-400 mb-2">Keine Medien zugeordnet</p>
          <button class="btn btn-xs btn-outline w-full" onclick="navigateTo('medien')">
            + Medium hinzuf√ºgen
          </button>
        `;
      }
      
      return `
        <div class="space-y-2">
          ${szeneMedien.map(m => {
            const isPlaying = state.currentlyPlaying === m.id;
            const icon = m.type === 'audio' ? 'üéµ' : 'üé¨';
            const hasFile = m.source === 'cloud' ? !!m.url : !!m.localFileUrl;
            const isYouTube = isYouTubeUrl(m.url);
            
            return `
              <div class="flex items-center gap-2 p-2 bg-gray-50 rounded hover:bg-gray-100">
                <span>${icon}</span>
                <span class="flex-1 text-sm truncate" title="${m.name}">${m.name}</span>
                ${hasFile || isYouTube ? `
                  <button class="btn btn-xs ${isPlaying ? 'btn-primary' : 'btn-outline'}" 
                          data-play-btn="${m.id}"
                          onclick="togglePlayMedium('${m.id}')">
                    ${isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
                  </button>
                ` : m.source === 'local' ? `
                  <button class="btn btn-xs btn-outline" onclick="reloadLocalFile('${m.id}')" title="Datei laden">
                    üìÇ
                  </button>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
        
        <!-- Mini-Player wenn was abgespielt wird -->
        ${state.currentlyPlaying && szeneMedien.find(m => m.id === state.currentlyPlaying) ? `
          <div class="mt-2 p-2 bg-blue-50 rounded">
            ${(() => {
              const m = szeneMedien.find(med => med.id === state.currentlyPlaying);
              if (!m) return '';
              const isYouTube = isYouTubeUrl(m.url);
              const youtubeId = isYouTube ? getYouTubeId(m.url) : null;
              
              // Tempo-Kontrolle nur f√ºr nicht-YouTube
              const tempoControls = !isYouTube ? `
                <div class="flex items-center gap-1 mb-1">
                  <span class="text-xs text-gray-500">Tempo:</span>
                  ${['0.5', '0.75', '1.0', '1.25', '1.5'].map(rate => `
                    <button class="btn btn-xs ${state.playbackRate == rate ? 'btn-primary' : 'btn-outline'}" 
                            data-tempo-btn="${rate}"
                            onclick="setPlaybackRate(${rate})" style="padding: 1px 4px; font-size: 10px;">
                      ${rate}x
                    </button>
                  `).join('')}
                </div>
              ` : '<p class="text-xs text-gray-500 mb-1">YouTube-Player unten</p>';
              
              // Player-Element
              let playerHtml = '';
              if (isYouTube && youtubeId) {
                playerHtml = `<iframe width="100%" height="150" src="https://www.youtube.com/embed/${youtubeId}" 
                              frameborder="0" allowfullscreen class="rounded"></iframe>`;
              } else {
                const src = m.source === 'cloud' ? convertToDirectUrl(m.url) : (m.localFileUrl || '');
                playerHtml = m.type === 'audio' 
                  ? `<audio id="media-${m.id}" class="w-full" controls src="${src}" style="height: 32px;"></audio>`
                  : `<video id="media-${m.id}" class="w-full rounded" controls src="${src}" style="max-height: 120px;"></video>`;
              }
              
              return tempoControls + `<div id="sidebar-player-${state.currentlyPlaying}">${playerHtml}</div>`;
            })()}
          </div>
        ` : ''}
      `;
    }

    // ============================================
    // MEDIEN VIEW (v1.3 - Vereinfacht mit Drag&Drop)
    // ============================================
    function renderMedienView() {
      return `
        <div class="flex-1 flex flex-col overflow-hidden">
          <!-- Header -->
          <div class="px-6 py-4 border-b border-gray-200 bg-white">
            <div class="flex items-center justify-between">
              <div>
                <h2 class="text-lg font-semibold text-gray-900">üé¨ Medien</h2>
                <p class="text-sm text-gray-500">Audio & Video f√ºr Proben und Choreographie</p>
              </div>
              <div id="storage-info" class="text-xs text-gray-400 text-right">
                <!-- Wird von updateStorageInfo gef√ºllt -->
              </div>
            </div>
          </div>
          
          <!-- Content -->
          <div class="flex-1 overflow-y-auto p-6">
            <!-- Upload Zone -->
            <div id="dropzone" 
                 class="border-2 border-dashed border-gray-300 rounded-lg p-8 mb-6 text-center 
                        hover:border-blue-400 hover:bg-blue-50 transition-colors cursor-pointer"
                 onclick="openFilePicker()"
                 ondragover="handleDragOver(event)"
                 ondragleave="handleDragLeave(event)"
                 ondrop="handleFileDrop(event)">
              <div class="text-4xl mb-3">üìÅ</div>
              <p class="text-gray-600 mb-2">Datei hierher ziehen oder klicken</p>
              <p class="text-sm text-gray-400 mb-2">
                üéµ <strong>Audio:</strong> wird permanent gespeichert<br>
                üé¨ <strong>Video:</strong> muss nach Neustart neu gew√§hlt werden
              </p>
            </div>
            
            <!-- Medien Liste -->
            ${state.medien.length === 0 ? `
              <div class="text-center text-gray-400 py-8">
                <p class="text-sm">Noch keine Medien ‚Äì lade eine Datei hoch</p>
              </div>
            ` : `
              <div class="space-y-4">
                ${state.medien.map(m => renderMediumCard(m)).join('')}
              </div>
            `}
          </div>
        </div>
      `;
    }
    
    // Speicherinfo im Header aktualisieren
    async function updateStorageInfo() {
      const infoEl = document.getElementById('storage-info');
      if (!infoEl) return;
      
      try {
        const info = await getAudioStorageInfo();
        infoEl.innerHTML = `
          <div>üíæ ${info.count} Audio${info.count !== 1 ? 's' : ''} gespeichert</div>
          <div>${info.totalSizeMB} MB verwendet</div>
        `;
      } catch (e) {
        infoEl.innerHTML = '';
      }
    }
    
    // File Picker - global reference to prevent garbage collection
    let globalFileInput = null;
    
    function openFilePicker() {
      // Neues Input-Element erstellen
      globalFileInput = document.createElement('input');
      globalFileInput.type = 'file';
      globalFileInput.accept = '.mp3,.wav,.ogg,.m4a,.mp4,.mov,.avi,.webm,audio/*,video/*';
      globalFileInput.style.display = 'none';
      document.body.appendChild(globalFileInput);
      
      globalFileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
          processFile(file);
        }
        // Aufr√§umen
        if (globalFileInput && globalFileInput.parentNode) {
          globalFileInput.parentNode.removeChild(globalFileInput);
        }
        globalFileInput = null;
      });
      
      globalFileInput.click();
    }
    
    // Drag & Drop Handlers
    function handleDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('border-blue-400', 'bg-blue-50');
    }
    
    function handleDragLeave(e) {
      e.currentTarget.classList.remove('border-blue-400', 'bg-blue-50');
    }
    
    function handleFileDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('border-blue-400', 'bg-blue-50');
      const file = e.dataTransfer.files[0];
      if (file) processFile(file);
    }
    
    async function processFile(file) {
      // MIME-Type pr√ºfen
      let isAudio = file.type.startsWith('audio/');
      let isVideo = file.type.startsWith('video/');
      
      // Fallback: Dateiendung pr√ºfen (f√ºr Dateien ohne MIME-Type)
      if (!isAudio && !isVideo) {
        const ext = file.name.split('.').pop().toLowerCase();
        const audioExtensions = ['mp3', 'wav', 'ogg', 'm4a', 'aac', 'flac', 'wma'];
        const videoExtensions = ['mp4', 'mov', 'avi', 'webm', 'mkv', 'm4v', 'wmv'];
        
        if (audioExtensions.includes(ext)) {
          isAudio = true;
        } else if (videoExtensions.includes(ext)) {
          isVideo = true;
        }
      }
      
      if (!isAudio && !isVideo) {
        alert('Nicht erkannt als Audio oder Video.\nBitte MP3, WAV, MP4, MOV oder √§hnliche Dateien verwenden.');
        return;
      }
      
      pushUndo();
      
      const mediumId = 'med_' + Date.now();
      
      const medium = {
        id: mediumId,
        name: file.name.replace(/\.[^/.]+$/, ''),
        source: 'local',
        url: '',
        filename: file.name,
        localFileUrl: URL.createObjectURL(file),
        type: isAudio ? 'audio' : 'video',
        szenen: [],
        notizen: '',
        audioStored: false
      };
      
      // Audio permanent in IndexedDB speichern
      if (isAudio) {
        try {
          await saveAudioToDB(mediumId, file);
          medium.audioStored = true;
          console.log('‚úÖ Audio permanent gespeichert');
        } catch (e) {
          console.error('Audio-Speicherung fehlgeschlagen:', e);
          // Fallback: nur tempor√§r
        }
      }
      
      state.medien.push(medium);
      saveProjektDaten();
      render();
      
      // Speicherinfo aktualisieren
      if (isAudio) {
        updateStorageInfo();
      }
    }
    
    function addFromUrl() {
      const urlInput = document.getElementById('url-input');
      const url = urlInput.value.trim();
      
      if (!url) return;
      
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        alert('Bitte eine g√ºltige URL eingeben (https://...)');
        return;
      }
      
      pushUndo();
      
      const isYouTube = url.includes('youtube.com') || url.includes('youtu.be');
      const isVideo = /\.(mp4|mov|avi|webm|mkv)(\?|$)/i.test(url) || 
                      isYouTube || url.includes('vimeo.com');
      
      // Name generieren
      let name = 'Neues Medium';
      if (isYouTube) {
        name = 'YouTube Video';
        // Versuche Video-ID als Hinweis zu nutzen
        const ytId = getYouTubeId(url);
        if (ytId) name = 'YouTube: ' + ytId;
      } else {
        try {
          const urlObj = new URL(url);
          const filename = urlObj.pathname.split('/').pop();
          if (filename && filename.length > 0) {
            name = decodeURIComponent(filename.replace(/\.[^/.]+$/, ''));
          }
        } catch(e) {}
      }
      
      const medium = {
        id: 'med_' + Date.now(),
        name: name,
        source: 'cloud',
        url: url,
        filename: '',
        type: isVideo ? 'video' : 'audio',
        szenen: [],
        notizen: ''
      };
      
      state.medien.push(medium);
      urlInput.value = '';
      saveProjektDaten();
      render();
    }
    
    function renderMediumCard(medium) {
      const isPlaying = state.currentlyPlaying === medium.id;
      const icon = medium.type === 'audio' ? 'üéµ' : 'üé¨';
      const hasFile = medium.source === 'cloud' ? !!medium.url : !!medium.localFileUrl;
      const isYouTube = isYouTubeUrl(medium.url);
      const youtubeId = isYouTube ? getYouTubeId(medium.url) : null;
      
      // Status-Hinweis f√ºr lokale Dateien
      let statusHint = '';
      if (medium.source === 'local') {
        if (medium.type === 'audio' && medium.audioStored) {
          statusHint = `
            <div class="bg-green-50 border border-green-200 rounded px-3 py-2 mb-3 text-sm text-green-700">
              ‚úÖ Audio permanent gespeichert
            </div>
          `;
        } else if (medium.type === 'video') {
          statusHint = `
            <div class="bg-amber-50 border border-amber-200 rounded px-3 py-2 mb-3 text-sm text-amber-700">
              ‚ö†Ô∏è¬è Video ‚Äì muss nach Browser-Neustart neu gew√§hlt werden
            </div>
          `;
        } else if (medium.type === 'audio' && !medium.audioStored) {
          statusHint = `
            <div class="bg-amber-50 border border-amber-200 rounded px-3 py-2 mb-3 text-sm text-amber-700">
              ‚è≥ Audio wird gespeichert...
            </div>
          `;
        }
      }
      
      return `
        <div class="bg-white border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow">
          <!-- Status-Hinweis -->
          ${statusHint}
          
          <!-- YouTube-Hinweis -->
          ${isYouTube ? `
            <div class="bg-red-50 border border-red-200 rounded px-3 py-2 mb-3 text-sm text-red-700">
              üì∫ YouTube-Video ‚Äì Tempo-Kontrolle nur √ºber YouTube-Player
            </div>
          ` : ''}
          
          <div class="flex items-start gap-4">
            <!-- Icon -->
            <div class="text-3xl">${icon}</div>
            
            <!-- Inline-Edit Felder -->
            <div class="flex-1 min-w-0 space-y-2">
              <!-- Name -->
              <input type="text" class="input w-full font-medium" value="${medium.name}"
                     onchange="updateMedium('${medium.id}', 'name', this.value)"
                     placeholder="Name eingeben...">
              
              <!-- Szenen-Auswahl -->
              <div class="flex items-center gap-2 flex-wrap">
                <span class="text-sm text-gray-500">Szenen:</span>
                ${state.szenen.length === 0 ? `
                  <span class="text-xs text-gray-400">Keine Szenen vorhanden</span>
                ` : state.szenen.map(s => `
                  <label class="inline-flex items-center gap-1 text-sm cursor-pointer hover:bg-gray-100 px-2 py-1 rounded">
                    <input type="checkbox" ${medium.szenen?.includes(s.id) ? 'checked' : ''}
                           onchange="toggleMediumSzene('${medium.id}', '${s.id}', this.checked)">
                    <span>${s.nummer}</span>
                  </label>
                `).join('')}
              </div>
              
              <!-- Notizen -->
              <input type="text" class="input w-full text-sm" value="${medium.notizen || ''}"
                     onchange="updateMedium('${medium.id}', 'notizen', this.value)"
                     placeholder="Notizen (z.B. Ab 2:30 neue Variante)">
              
              <!-- Player Controls -->
              <div class="flex items-center gap-2 flex-wrap pt-2">
                ${hasFile || isYouTube ? `
                  <button class="btn btn-sm ${isPlaying ? 'btn-primary' : 'btn-outline'}" 
                          data-play-btn="${medium.id}"
                          onclick="togglePlayMedium('${medium.id}')">
                    ${isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play'}
                  </button>
                ` : medium.source === 'local' ? `
                  <button class="btn btn-sm btn-outline" onclick="reloadLocalFile('${medium.id}')">
                    üìÇ Datei neu laden
                  </button>
                ` : ''}
                
                <!-- Tempo (nicht f√ºr YouTube) -->
                ${!isYouTube ? `
                  <div class="flex items-center gap-1">
                    <span class="text-xs text-gray-400 mr-1">Tempo:</span>
                    ${['0.5', '0.75', '1.0', '1.25', '1.5'].map(rate => `
                      <button class="btn btn-xs ${state.playbackRate == rate ? 'btn-primary' : 'btn-outline'}" 
                              data-tempo-btn="${rate}"
                              onclick="setPlaybackRate(${rate})" style="padding: 2px 6px;">
                        ${rate}x
                      </button>
                    `).join('')}
                  </div>
                ` : ''}
              </div>
            </div>
            
            <!-- Delete -->
            <button class="btn btn-sm btn-outline text-red-500 hover:bg-red-50" 
                    onclick="deleteMedium('${medium.id}')" title="L√∂schen">üóëÔ∏è¬è</button>
          </div>
          
          <!-- Player Element -->
          <div id="player-${medium.id}" class="mt-3 ${isPlaying ? '' : 'hidden'}">
            ${isYouTube && youtubeId ? `
              <iframe 
                width="100%" 
                height="250" 
                src="https://www.youtube.com/embed/${youtubeId}?autoplay=0" 
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                allowfullscreen
                class="rounded">
              </iframe>
            ` : medium.type === 'audio' ? `
              <audio id="media-${medium.id}" class="w-full" controls
                     src="${medium.source === 'cloud' ? convertToDirectUrl(medium.url) : (medium.localFileUrl || '')}"></audio>
            ` : `
              <video id="media-${medium.id}" class="w-full rounded" controls style="max-height: 300px;"
                     src="${medium.source === 'cloud' ? convertToDirectUrl(medium.url) : (medium.localFileUrl || '')}"></video>
            `}
          </div>
        </div>
      `;
    }
    
    function updateMedium(mediumId, field, value) {
      const medium = state.medien.find(m => m.id === mediumId);
      if (medium) {
        medium[field] = value;
        saveProjektDaten();
      }
    }
    
    function toggleMediumSzene(mediumId, szeneId, checked) {
      const medium = state.medien.find(m => m.id === mediumId);
      if (medium) {
        if (!medium.szenen) medium.szenen = [];
        
        if (checked && !medium.szenen.includes(szeneId)) {
          // Szene hinzuf√ºgen
          medium.szenen.push(szeneId);
          
          // ========== CUE ERSTELLEN ==========
          const existiertBereits = state.cues.some(c => 
            (c.typ === 'q' || c.typ === 'v') && c.mediumId === mediumId && c.szeneId === szeneId
          );
          if (!existiertBereits) {
            const cueTyp = medium.type === 'audio' ? 'q' : 'v';
            const cuesInSzene = state.cues.filter(c => c.typ === cueTyp && c.szeneId === szeneId);
            const nextNummer = cuesInSzene.length > 0 
              ? Math.max(...cuesInSzene.map(c => c.nummer)) + 1 
              : 1;
            
            state.cues.push({
              id: genId(),
              typ: cueTyp,
              nummer: nextNummer,
              szeneId: szeneId,
              beschreibung: medium.name,
              mediumId: mediumId,
              ausloeser: '',
              dauer: '',
            });
          }
          // ====================================
        } else if (!checked) {
          // Szene entfernen
          medium.szenen = medium.szenen.filter(id => id !== szeneId);
          
          // ========== CUE L√ñSCHEN ==========
          state.cues = state.cues.filter(c => 
            !((c.typ === 'q' || c.typ === 'v') && c.mediumId === mediumId && c.szeneId === szeneId)
          );
          // ==================================
        }
        
        saveProjektDaten();
      }
    }
    
    function reloadLocalFile(mediumId) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'audio/*,video/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const medium = state.medien.find(m => m.id === mediumId);
          if (medium) {
            medium.filename = file.name;
            medium.localFileUrl = URL.createObjectURL(file);
            saveProjektDaten();
            render();
          }
        }
      };
      input.click();
    }
    
    function convertToDirectUrl(url) {
      if (!url) return '';
      if (url.includes('drive.google.com')) {
        const match = url.match(/\/d\/([a-zA-Z0-9_-]+)/);
        if (match) return 'https://drive.google.com/uc?export=download&id=' + match[1];
      }
      if (url.includes('dropbox.com')) {
        return url.replace('dl=0', 'dl=1').replace('www.dropbox.com', 'dl.dropboxusercontent.com');
      }
      return url;
    }
    
    // YouTube URL zu Embed-ID extrahieren
    function getYouTubeId(url) {
      if (!url) return null;
      // Verschiedene YouTube URL-Formate
      const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
        /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/
      ];
      for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
      }
      return null;
    }
    
    function isYouTubeUrl(url) {
      return url && (url.includes('youtube.com') || url.includes('youtu.be'));
    }
    
    function togglePlayMedium(mediumId) {
      const medium = state.medien.find(m => m.id === mediumId);
      if (!medium) return;
      
      // YouTube braucht Sonderbehandlung
      if (isYouTubeUrl(medium.url)) {
        // Toggle visibility des Players
        const playerContainer = document.getElementById('player-' + mediumId);
        if (playerContainer) {
          const isHidden = playerContainer.classList.contains('hidden');
          
          // Andere Player verstecken
          document.querySelectorAll('[id^="player-"]').forEach(el => {
            el.classList.add('hidden');
          });
          
          if (isHidden) {
            playerContainer.classList.remove('hidden');
            state.currentlyPlaying = mediumId;
          } else {
            playerContainer.classList.add('hidden');
            state.currentlyPlaying = null;
          }
        }
        updatePlayButtons();
        return;
      }
      
      // Normaler Audio/Video Player
      const mediaElement = document.getElementById('media-' + mediumId);
      const playerContainer = document.getElementById('player-' + mediumId);
      
      if (!mediaElement || !playerContainer) return;
      
      if (state.currentlyPlaying === mediumId) {
        // Pause
        mediaElement.pause();
        state.currentlyPlaying = null;
      } else {
        // Stop andere Player
        if (state.currentlyPlaying) {
          const otherMedia = document.getElementById('media-' + state.currentlyPlaying);
          const otherPlayer = document.getElementById('player-' + state.currentlyPlaying);
          if (otherMedia) otherMedia.pause();
          if (otherPlayer) otherPlayer.classList.add('hidden');
        }
        
        // Play this one
        playerContainer.classList.remove('hidden');
        mediaElement.playbackRate = state.playbackRate;
        mediaElement.play().catch(e => {
          alert('Wiedergabe fehlgeschlagen. URL pr√ºfen oder Datei neu laden.');
        });
        state.currentlyPlaying = mediumId;
      }
      
      updatePlayButtons();
    }
    
    // Nur die Play-Buttons aktualisieren, ohne render()
    function updatePlayButtons() {
      document.querySelectorAll('[data-play-btn]').forEach(btn => {
        const mediumId = btn.getAttribute('data-play-btn');
        const isPlaying = state.currentlyPlaying === mediumId;
        btn.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        btn.className = btn.className.replace(/btn-primary|btn-outline/g, '').trim();
        btn.classList.add(isPlaying ? 'btn-primary' : 'btn-outline');
      });
      
      // Tempo-Buttons aktualisieren
      document.querySelectorAll('[data-tempo-btn]').forEach(btn => {
        const rate = btn.getAttribute('data-tempo-btn');
        btn.className = btn.className.replace(/btn-primary|btn-outline/g, '').trim();
        btn.classList.add(state.playbackRate == rate ? 'btn-primary' : 'btn-outline');
      });
    }
    
    function setPlaybackRate(rate) {
      state.playbackRate = rate;
      
      // Auf allen aktiven Media-Elementen setzen
      if (state.currentlyPlaying) {
        const mediaElement = document.getElementById('media-' + state.currentlyPlaying);
        if (mediaElement && mediaElement.playbackRate !== undefined) {
          mediaElement.playbackRate = rate;
        }
      }
      
      updatePlayButtons();
    }
    
    async function deleteMedium(mediumId) {
      if (!confirm('Medium wirklich l√∂schen?')) return;
      
      // Audio aus IndexedDB l√∂schen
      const medium = state.medien.find(m => m.id === mediumId);
      if (medium && medium.type === 'audio' && medium.audioStored) {
        try {
          await deleteAudioFromDB(mediumId);
        } catch (e) {
          console.warn('Audio-L√∂schung fehlgeschlagen:', e);
        }
      }
      
      // Zugeh√∂rige Cues l√∂schen
      state.cues = state.cues.filter(c => !((c.typ === 'q' || c.typ === 'v') && c.mediumId === mediumId));
      
      pushUndo();
      state.medien = state.medien.filter(m => m.id !== mediumId);
      if (state.currentlyPlaying === mediumId) state.currentlyPlaying = null;
      saveProjektDaten();
      render();
      updateStorageInfo();
    }

    // ============================================
    // PLACEHOLDER
    // ============================================
    function renderPlaceholder(moduleName) {
      const moduleInfo = {
        requisiten: { icon: 'üé≠', name: 'Requisiten', desc: 'Hier kannst du Requisiten verwalten und ihren Einsatz in Szenen tracken.' },
        medien: { icon: 'üìÅ', name: 'Medien', desc: 'Hier kannst du Bilder, Audio und andere Medien hochladen.' },
      };
      const info = moduleInfo[moduleName] || { icon: 'üöß', name: moduleName, desc: 'Dieses Modul wird entwickelt.' };
      
      return `
        <div class="flex-1 flex items-center justify-center">
          <div class="text-center text-gray-400 max-w-md">
            <div class="text-6xl mb-4">${info.icon}</div>
            <h2 class="text-xl font-semibold text-gray-600 mb-2">${info.name}</h2>
            <p class="mb-4">${info.desc}</p>
            <p class="text-sm">üöß Kommt in der n√§chsten Version</p>
          </div>
        </div>
      `;
    }

    // ============================================
    // MODALS
    // ============================================
    function renderImportModal() {
      const hasApiKey = !!localStorage.getItem('nina_rebu_api_key');
      
      return `
        <div class="modal-overlay" onclick="closeModal('showImportModal')">
          <div class="modal-content" style="max-width: 650px; max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">‚¨áÔ∏è¬è Importieren</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showImportModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <!-- Tab-Navigation -->
              <div class="flex border-b mb-4">
                <button class="import-tab px-4 py-2 border-b-2 border-blue-500 text-blue-600 font-medium" data-tab="word" onclick="showImportTab('word')">
                  üìÑ Word/PDF
                </button>
                <button class="import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="nina" onclick="showImportTab('nina')" style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(20,184,166,0.1)); border-radius: 4px 4px 0 0;">
                  üîÑ Dramera
                </button>
                <button class="import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="dramera" onclick="showImportTab('dramera')">
                  üíæ Backup
                </button>
                <button class="import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="text" onclick="showImportTab('text')">
                  üìù Text
                </button>
              </div>
              
              <!-- Word/PDF Tab (NEU - Prim√§r) -->
              <div id="import-tab-word">
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-blue-400 cursor-pointer mb-4"
                     onclick="document.getElementById('import-word-input').click()">
                  <div class="text-4xl mb-2">üìÑ</div>
                  <p class="text-sm text-gray-600" id="import-word-name">Word (.docx) oder PDF ausw√§hlen...</p>
                  <input type="file" id="import-word-input" accept=".docx,.pdf" class="hidden" onchange="handleDocumentFile(this)">
                </div>
                
                <!-- Format-Info -->
                <div id="import-format-info" style="display: none; margin-bottom: 16px; padding: 12px; background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px;">
                  <div style="font-size: 12px; color: #166534; font-weight: 500; margin-bottom: 6px;">üîç Erkannte Formatierungen:</div>
                  <div id="import-format-details" style="font-size: 11px; color: #15803d;"></div>
                </div>
                
                <!-- Preview -->
                <div id="import-word-preview" style="display: none; margin-bottom: 16px;">
                  <div style="font-size: 14px; font-weight: 500; color: #374151; margin-bottom: 8px;">Vorschau:</div>
                  <div id="import-word-preview-text" style="border: 1px solid #e5e7eb; border-radius: 4px; background: #f9fafb; padding: 12px; max-height: 120px; overflow-y: auto; font-size: 11px; font-family: monospace; white-space: pre-wrap; word-break: break-word;"></div>
                </div>
                
                <!-- Status -->
                <div id="import-word-status" style="display: none; margin-bottom: 16px;">
                  <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #2563eb;">
                    <div style="width: 16px; height: 16px; border: 2px solid #2563eb; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    <span id="import-word-status-text">Analysiere...</span>
                  </div>
                </div>
                
                <div class="flex gap-2">
                  <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Abbrechen</button>
                  <button class="btn btn-primary flex-1" id="import-word-btn" onclick="doImportWord()" disabled>üì• Importieren</button>
                </div>
              </div>
              
              <!-- NINA-Exchange Tab (Dramera Import) -->
              <div id="import-tab-nina" style="display: none;">
                <div style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(20,184,166,0.1)); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                  <p style="font-size: 14px; color: #374151; margin-bottom: 8px;">
                    <strong>üîÑ Import aus Dramera Werkbank</strong>
                  </p>
                  <p style="font-size: 12px; color: #6b7280;">
                    Importiere Figuren und Szenen, die du in Dramera entwickelt hast.
                    Die Daten werden in dein aktuelles Projekt √ºbernommen.
                  </p>
                </div>
                
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-purple-400 cursor-pointer mb-4"
                     onclick="document.getElementById('import-nina-input').click()">
                  <div class="text-4xl mb-2">üîÑ</div>
                  <p class="text-sm text-gray-600" id="import-nina-name">NINA-Exchange Datei ausw√§hlen...</p>
                  <p class="text-xs text-gray-400 mt-1">(*_nina-exchange.json)</p>
                  <input type="file" id="import-nina-input" accept=".json" class="hidden" onchange="handleNinaImportFile(this)">
                </div>
                
                <!-- Preview -->
                <div id="import-nina-preview" style="display: none; margin-bottom: 16px; padding: 12px; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px;">
                  <div style="font-size: 12px; font-weight: 600; color: #374151; margin-bottom: 8px;">üìã Gefundene Daten:</div>
                  <div id="import-nina-details" style="font-size: 12px; color: #6b7280;"></div>
                </div>
                
                <div class="flex gap-2">
                  <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Abbrechen</button>
                  <button class="btn flex-1" id="import-nina-btn" onclick="doImportNina()" disabled style="background: linear-gradient(135deg, #8b5cf6, #14b8a6); color: white;">üîÑ Importieren</button>
                </div>
              </div>
              
              <!-- Backup Tab -->
              <div id="import-tab-dramera" style="display: none;">
                <p class="text-sm text-gray-500 mb-4">
                  Importiere ein Projekt-Backup (.json) ‚Äì stellt alle Daten wieder her:
                </p>
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-purple-400 cursor-pointer"
                     onclick="document.getElementById('import-file-input').click()">
                  <div class="text-4xl mb-2">üíæ</div>
                  <p class="text-sm text-gray-600" id="import-file-name">Klicken zum Ausw√§hlen...</p>
                  <input type="file" id="import-file-input" accept=".json" class="hidden" onchange="handleImportFile(this)">
                </div>
                <div class="flex gap-2 mt-4">
                  <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Abbrechen</button>
                  <button class="btn btn-primary flex-1" id="import-btn" onclick="doImportFile()" disabled>Importieren</button>
                </div>
              </div>
              
              <!-- Text Tab -->
              <div id="import-tab-text" style="display: none;">
                <p class="text-sm font-medium text-gray-700 mb-2">Text einf√ºgen oder TXT-Datei hochladen:</p>
                <textarea id="import-text-content" rows="6" placeholder="Text hier einf√ºgen..."></textarea>
                
                <input type="file" id="import-txt-input" accept=".txt,.md" class="text-sm mt-2" onchange="handleTxtImportFile(this)">
                
                <div class="grid grid-cols-2 gap-4 mt-4">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Szenen-Titel</label>
                    <input type="text" id="import-text-title" value="Importierter Text">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Szenen-Nummer</label>
                    <input type="text" id="import-text-nummer" value="1.1">
                  </div>
                </div>
                
                <div class="flex gap-2 mt-4">
                  <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Abbrechen</button>
                  <button class="btn btn-primary flex-1" onclick="doImportText()">üì• Importieren</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // ============================================
    // TEXTMUSTER-ANALYSE v2.0
    // ============================================
    // LOGIK:
    // 1. WORD: Erst Formatvorlagen pr√ºfen ‚Üí wenn nicht vorhanden ‚Üí Analyse
    // 2. PDF: Direkt Analyse
    // 3. ANALYSE: Figurenliste ZUERST ‚Üí dann mit bekannten Namen Dialoge finden!
    // ============================================
    
    // Muster f√ºr Figurenliste-Header
    const FIGURENLISTE_HEADER = [
      /^(Personen|Figuren|Rollen|Besetzung|Dramatis\s+Personae):?\s*$/im,
      /^PERSONNAGES:?\s*$/im,
      /^Characters?:?\s*$/im,
      /^Cast(\s+of\s+Characters)?:?\s*$/im,
      /^Mitwirkende:?\s*$/im,
      /^Die\s+Auswanderer:/im  // Gruppierte Figuren
    ];
    
    // Muster f√ºr Struktur-Erkennung
    const STRUKTUR_PATTERNS = {
      akt: [
        /^(\d+)\.\s*Akt\b/im,
        /^(Erster?|Zweiter?|Dritter?|Vierter?|F√ºnfter?)\s+Akt\b/im,
        /^Akt\s+(\d+|[IVX]+)\b/im,
        /^([IVX]+)\.\s*Akt\b/im,
        /^(Prolog|Epilog|Vorspiel|Nachspiel)\b/im,
        /^(Erster?|Zweiter?|Dritter?)\s+Aufzug\b/im,
        /^(\d+)\.\s*Aufzug\b/im,
        /^Act\s+(\d+|[IVX]+|One|Two|Three)\b/im,
        /^Acte\s+(\d+|[IVX]+|Premier|Deuxi√®me)\b/im
      ],
      szene: [
        /^(\d+)\.\s*Szene\b/im,
        /^Szene\s+(\d+)\b/im,
        /^(Erste?|Zweite?|Dritte?)\s+Szene\b/im,
        /^(\d+)\.\s*Szene\s*[-‚Äì‚Äî/:]\s*(.+)/im,
        /^(Erster?|Zweiter?|Dritter?)\s+Auftritt\b/im,
        /^(\d+)\.\s*Auftritt\b/im,
        /^Scene\s+(\d+)\b/im,
        /^Sc√®ne\s+(\d+)\b/im
      ],
      bild: [
        /^(\d+)\.\s*$/m,           // Nur "1." auf eigener Zeile
        /^Bild\s+(\d+)\b/im,
        /^(\d+)\.\s*Bild\b/im,
        /^([A-Z])\.\s*$/m          // "A." "B." f√ºr Monologe
      ],
      nummeriert: [
        /^(\d+)\.(\d+)\.\s*$/m,    // "1.1." "2.3."
        /^(\d+)\.(\d+)\s+/m        // "1.1 Titel"
      ]
    };
    
    /**
     * SCHRITT 1: FIGURENLISTE aus Text extrahieren
     * Das ist der WICHTIGSTE Schritt - mit bekannten Figuren k√∂nnen Dialoge pr√§ziser erkannt werden!
     */
    function extractFigurenlisteFromText(text) {
      const lines = text.split('\n');
      const figuren = [];
      let inFigurenliste = false;
      let leerzeileNachHeader = false;
      
      for (let i = 0; i < Math.min(lines.length, 120); i++) {
        const line = lines[i].trim();
        
        // Figurenliste-Header gefunden?
        if (!inFigurenliste) {
          if (FIGURENLISTE_HEADER.some(p => p.test(line))) {
            inFigurenliste = true;
            // Pr√ºfe ob gruppierte Figuren im Header selbst
            const gruppiert = line.match(/^(.+?):\s*([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s,]+)$/);
            if (gruppiert && gruppiert[2].includes(',')) {
              const gruppe = gruppiert[1].trim();
              gruppiert[2].split(/,\s*/).forEach(name => {
                if (name.trim().length > 1) {
                  figuren.push({ name: name.trim(), beschreibung: gruppe });
                }
              });
            }
            continue;
          }
        }
        
        // In Figurenliste - Namen extrahieren
        if (inFigurenliste) {
          // Leere Zeile √ºberspringen
          if (!line) {
            leerzeileNachHeader = true;
            continue;
          }
          
          // Ende der Figurenliste erkennen
          if (/^(Ort|Zeit|Handlung|Synopsis|Schauplatz)/i.test(line)) break;
          if (/^(1\.|Erster|ERSTER|Prolog|I\.\s*Akt)/i.test(line)) break;
          if (STRUKTUR_PATTERNS.akt.some(p => p.test(line))) break;
          if (STRUKTUR_PATTERNS.szene.some(p => p.test(line))) break;
          if (STRUKTUR_PATTERNS.bild.some(p => p.test(line))) break;
          
          // Figur mit Beschreibung: "NAME - Beschreibung" oder "NAME, Beschreibung"
          const mitBeschreibung = line.match(/^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]{1,30}?)\s*[-‚Äì‚Äî,]\s*(.+)$/);
          if (mitBeschreibung) {
            figuren.push({
              name: mitBeschreibung[1].trim(),
              beschreibung: mitBeschreibung[2].trim()
            });
            continue;
          }
          
          // Gruppierte Figuren: "Die Bauern: Hans, Fritz, Karl"
          const gruppiert = line.match(/^(.+?):\s*([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s,]+)$/);
          if (gruppiert && !gruppiert[1].match(/^(Personen|Figuren|Rollen|Ort|Zeit)/i)) {
            const gruppe = gruppiert[1].trim();
            gruppiert[2].split(/,\s*/).forEach(name => {
              if (name.trim().length > 1) {
                figuren.push({ name: name.trim(), beschreibung: gruppe });
              }
            });
            continue;
          }
          
          // Einfacher Name (GROSSBUCHSTABEN)
          if (/^[A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√ú\s]{1,25}$/.test(line)) {
            figuren.push({ name: line, beschreibung: '' });
            continue;
          }
          
          // Name mit gemischter Schreibweise (ohne Sonderzeichen am Ende)
          if (/^[A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]{2,30}$/.test(line) && 
              !line.includes(':') && !line.includes('¬©')) {
            figuren.push({ name: line, beschreibung: '' });
          }
        }
      }
      
      // Wenn Figurenliste gefunden wurde, gib sie zur√ºck
      if (figuren.length > 0) {
        console.log('‚úì Figurenliste gefunden:', figuren.length, 'Figuren:', figuren.map(f => f.name).join(', '));
        return figuren;
      }
      
      // FALLBACK: Figuren aus Dialogen extrahieren (weniger pr√§zise)
      console.log('‚ö† Keine Figurenliste gefunden, extrahiere aus Dialogen...');
      return extractFigurenFromDialoge(text);
    }
    
    /**
     * Fallback: Figuren aus Dialog-Mustern extrahieren
     */
    function extractFigurenFromDialoge(text) {
      const figurenSet = new Set();
      const lines = text.split('\n');
      
      const dialogPatterns = [
        /^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√ú\s]{1,20}):\s/m,      // NAME:
        /^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√ú\s]{1,20})\.\s+[A-Z]/m, // NAME. Text
        /^([A-Z√Ñ√ñ√ú]{2,15})\s*$/m,                 // NAME (eigene Zeile)
        /^(CHOR|ALLE|MEHRERE|ERZ√ÑHLER|NARRATOR)[:\.]/im
      ];
      
      for (const line of lines) {
        for (const pattern of dialogPatterns) {
          const match = line.match(pattern);
          if (match && match[1]) {
            const name = match[1].trim();
            if (name.length >= 2 && name.length <= 25) {
              figurenSet.add(name);
            }
            break;
          }
        }
      }
      
      console.log('  Aus Dialogen erkannt:', figurenSet.size, 'Figuren');
      return Array.from(figurenSet).map(name => ({ name, beschreibung: '' }));
    }
    
    /**
     * SCHRITT 2: Mit bekannten Figurennamen DIALOGE erkennen
     * Viel pr√§ziser als blind nach Mustern zu suchen!
     */
    function findDialogeWithKnownFiguren(text, figurenNamen) {
      const dialoge = [];
      const lines = text.split('\n');
      
      // Pattern aus bekannten Figuren bauen (pr√§zise!)
      const figurenPattern = figurenNamen.length > 0 
        ? new RegExp(`^(${figurenNamen.map(n => escapeRegex(n)).join('|')})\\s*[:\\.)]`, 'im')
        : null;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Mit bekannten Figuren pr√ºfen (pr√§ziser!)
        if (figurenPattern) {
          const match = line.match(figurenPattern);
          if (match) {
            dialoge.push({ lineIndex: i, figur: match[1].trim(), line: line });
          }
        }
      }
      
      return dialoge;
    }
    
    // Hilfsfunktion f√ºr Regex-Escape
    function escapeRegex(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    /**
     * SCHRITT 3: Strukturtyp erkennen
     */
    function detectStrukturTyp(text) {
      const lines = text.split('\n').slice(0, 200);
      let scores = { akte: 0, bilder: 0, nummeriert: 0, keine: 0 };
      
      for (const line of lines) {
        const t = line.trim();
        if (STRUKTUR_PATTERNS.akt.some(p => p.test(t))) scores.akte += 3;
        if (STRUKTUR_PATTERNS.szene.some(p => p.test(t))) scores.akte += 2;
        if (STRUKTUR_PATTERNS.bild.some(p => p.test(t))) scores.bilder += 2;
        if (STRUKTUR_PATTERNS.nummeriert.some(p => p.test(t))) scores.nummeriert += 2;
      }
      
      const maxScore = Math.max(...Object.values(scores));
      if (maxScore < 2) return 'keine';
      
      for (const [typ, score] of Object.entries(scores)) {
        if (score === maxScore) return typ;
      }
      return 'akte';
    }
    
    /**
     * SCHRITT 4: Szenen-Grenzen finden
     */
    function findSzenenGrenzen(text, strukturTyp) {
      const lines = text.split('\n');
      const grenzen = [];
      let patterns = [...STRUKTUR_PATTERNS.akt, ...STRUKTUR_PATTERNS.szene];
      
      if (strukturTyp === 'bilder') patterns = [...STRUKTUR_PATTERNS.bild, ...STRUKTUR_PATTERNS.akt];
      if (strukturTyp === 'nummeriert') patterns = [...STRUKTUR_PATTERNS.nummeriert, ...STRUKTUR_PATTERNS.akt];
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        for (const pattern of patterns) {
          if (pattern.test(line)) {
            grenzen.push({
              lineIndex: i,
              text: line,
              isAkt: STRUKTUR_PATTERNS.akt.some(p => p.test(line))
            });
            break;
          }
        }
      }
      return grenzen;
    }
    
    /**
     * SCHRITT 5: Metadaten extrahieren (Titel, Autor, Gattung)
     */
    function extractMetadatenFromText(text) {
      const lines = text.split('\n').slice(0, 80);
      const meta = { titel: '', untertitel: '', autor: '', copyright: '', gattung: '' };
      
      const AUTOR_PATTERNS = [
        /^von\s+([A-Z√Ñ√ñ√úa-z√§√∂√º][\w√§√∂√º√Ñ√ñ√ú√ü\s\.\-]+)$/im,
        /^Autor:?\s*(.+)$/im,
        /^Une\s+pi√®ce\s+de\s+(.+)$/im,
        /^Deutsch\s+von\s+(.+)$/im,
        /^By:?\s+(.+)$/im
      ];
      
      const GATTUNG_PATTERNS = [
        /^(Ein|Eine)\s+(Kom√∂die|Trag√∂die|Drama|Schauspiel|Lustspiel|Musical|Oper|Singspiel)/i,
        /^(Komische\s+)?Oper\s+in\s+.+\s+Akten/i,
        /^(Eine\s+)?(musikalische\s+)?(Chronik|Revue|Kom√∂die|Farce)/i,
        /in\s+(\d+|zwei|drei|vier|f√ºnf)\s+(Akten|Bildern|Szenen|Aufz√ºgen)/i
      ];
      
      for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        
        // Autor
        for (const p of AUTOR_PATTERNS) {
          const m = t.match(p);
          if (m && !meta.autor) { meta.autor = m[1].trim(); break; }
        }
        
        // Gattung
        for (const p of GATTUNG_PATTERNS) {
          if (p.test(t) && !meta.gattung) { meta.gattung = t; meta.untertitel = t; break; }
        }
        
        // Copyright
        if (/¬©|Copyright|Alle Rechte/i.test(t) && !meta.copyright) {
          meta.copyright = t;
        }
        
        // Titel (erste substantielle Zeile die kein Autor/Copyright ist)
        if (!meta.titel && t.length >= 3 && t.length <= 80 &&
            !AUTOR_PATTERNS.some(p => p.test(t)) &&
            !GATTUNG_PATTERNS.some(p => p.test(t)) &&
            !/^(¬©|Alle Rechte|Copyright|\d+$)/i.test(t)) {
          meta.titel = t;
        }
      }
      
      return meta;
    }
    
    // Word-Import Variablen
    let importedWordData = null;
    
    // NINA-Exchange Import Variablen
    let ninaImportData = null;
    
    function showImportTab(tab) {
      // Alle Tabs ausblenden
      document.getElementById('import-tab-word').style.display = tab === 'word' ? 'block' : 'none';
      document.getElementById('import-tab-nina').style.display = tab === 'nina' ? 'block' : 'none';
      document.getElementById('import-tab-dramera').style.display = tab === 'dramera' ? 'block' : 'none';
      document.getElementById('import-tab-text').style.display = tab === 'text' ? 'block' : 'none';
      
      // Tab-Buttons aktualisieren
      document.querySelectorAll('.import-tab').forEach(btn => {
        if (btn.dataset.tab === tab) {
          btn.className = 'import-tab px-4 py-2 border-b-2 border-blue-500 text-blue-600 font-medium';
        } else {
          btn.className = 'import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700';
        }
      });
    }
    
    // NINA-Exchange Import Handler
    function handleNinaImportFile(input) {
      const file = input.files[0];
      if (!file) return;
      
      document.getElementById('import-nina-name').textContent = '‚è≥ Lese ' + file.name + '...';
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          
          // Pr√ºfen ob es ein NINA-Exchange Format ist
          if (data.format !== 'nina-exchange') {
            alert('‚ùå Diese Datei ist kein NINA-Exchange Format.\n\nBitte exportiere das Projekt zuerst aus Dramera mit "F√ºr Rebu/Propla" Export.');
            document.getElementById('import-nina-name').textContent = 'NINA-Exchange Datei ausw√§hlen...';
            return;
          }
          
          ninaImportData = data;
          
          // Preview anzeigen
          document.getElementById('import-nina-name').textContent = '‚úÖ ' + file.name;
          
          const preview = document.getElementById('import-nina-preview');
          const details = document.getElementById('import-nina-details');
          
          let html = [];
          html.push('<div style="margin-bottom: 8px;"><strong>üìÅ Projekt:</strong> ' + escapeHtml(data.project?.name || 'Unbenannt') + '</div>');
          
          if (data.figures?.length) {
            html.push('<div style="margin-bottom: 4px;">üë§ <strong>' + data.figures.length + ' Figuren:</strong> ');
            html.push(data.figures.slice(0, 5).map(f => escapeHtml(f.name)).join(', '));
            if (data.figures.length > 5) html.push(' ...');
            html.push('</div>');
          }
          
          if (data.scenes?.length) {
            html.push('<div style="margin-bottom: 4px;">üé¨ <strong>' + data.scenes.length + ' Szenen:</strong> ');
            html.push(data.scenes.slice(0, 3).map(s => escapeHtml(s.name)).join(', '));
            if (data.scenes.length > 3) html.push(' ...');
            html.push('</div>');
          }
          
          if (data.themes?.length) {
            html.push('<div>üí° <strong>' + data.themes.length + ' Themen</strong></div>');
          }
          
          html.push('<div style="margin-top: 8px; font-size: 11px; color: #9ca3af;">Exportiert: ' + new Date(data.exportedAt).toLocaleString('de-CH') + '</div>');
          
          details.innerHTML = html.join('');
          preview.style.display = 'block';
          
          document.getElementById('import-nina-btn').disabled = false;
          
        } catch (err) {
          console.error('NINA Import Fehler:', err);
          alert('‚ùå Fehler beim Lesen der Datei: ' + err.message);
          document.getElementById('import-nina-name').textContent = 'NINA-Exchange Datei ausw√§hlen...';
        }
      };
      reader.readAsText(file);
    }
    
    // ============================================
    // NINA-EXCHANGE IMPORT v2.0
    // Vollst√§ndiger Import inkl. Texte!
    // ============================================
    async function doImportNina() {
      if (!ninaImportData) return;
      
      const data = ninaImportData;
      const projektId = state.projektId;
      
      if (!projektId) {
        alert('‚ùå Bitte zuerst ein Projekt √∂ffnen oder erstellen!');
        return;
      }
      
      try {
        // === PROJEKT-METADATEN IMPORTIEREN ===
        if (data.project) {
          const p = data.project;
          state.projektMeta = {
            ...state.projektMeta,
            titel: p.name || state.projektMeta.titel,
            untertitel: p.subtitle || state.projektMeta.untertitel || '',
            autor: p.author || state.projektMeta.autor || '',
            regie: p.director || state.projektMeta.regie || '',
            tagline: p.tagline || state.projektMeta.tagline || '',
            logline: p.logline || p.description || state.projektMeta.logline || '',
            copyright: p.copyright || state.projektMeta.copyright || '',
            titelbild: p.cover_image || state.projektMeta.titelbild || '',
            premiere: p.premiere_date || state.projektMeta.premiere || '',
            spielort: p.venue || state.projektMeta.spielort || '',
            fassung: p.version_name || state.projektMeta.fassung || 'Arbeitsfassung',
            fassungsDatum: p.version_date || state.projektMeta.fassungsDatum || '',
            strukturTyp: p.structure_type || state.projektMeta.strukturTyp || 'akte'
          };
          save(KEYS.meta(projektId), state.projektMeta);
        }
        
        // Bestehende Daten laden
        const existingFiguren = load(KEYS.figuren(projektId), []);
        const existingFigurenNames = existingFiguren.map(f => f.name.toLowerCase());
        const existingSzenen = load(KEYS.szenen(projektId), []);
        const existingSzenenNames = existingSzenen.map(s => (s.titel || s.name || '').toLowerCase());
        const existingTextbuch = load(KEYS.textbuch(projektId), {});
        
        let importedFiguren = 0;
        let importedSzenen = 0;
        let importedTexte = 0;
        let skippedFiguren = 0;
        let skippedSzenen = 0;
        
        // === FIGUREN IMPORTIEREN (v2.0 Felder) ===
        const newFiguren = [...existingFiguren];
        const figurenIdMap = {};
        
        for (const fig of (data.figures || [])) {
          if (existingFigurenNames.includes(fig.name.toLowerCase())) {
            skippedFiguren++;
            const existing = existingFiguren.find(f => f.name.toLowerCase() === fig.name.toLowerCase());
            if (existing) figurenIdMap[fig.id] = existing.id;
            continue;
          }
          
          const newId = genId();
          figurenIdMap[fig.id] = newId;
          
          newFiguren.push({
            id: newId,
            name: fig.name,
            kuerzel: fig.short_name || fig.abbreviation || fig.name.substring(0, 3).toUpperCase(),
            beschreibung: fig.description || fig.biography || '',
            farbe: fig.color || '#3b82f6',
            typ: fig.figure_type || 'main',
            // v2.0 Dramaturgie-Felder
            want: fig.want_external || fig.want || '',
            wantInternal: fig.want_internal || '',
            need: fig.need || '',
            ghost: fig.ghost || '',
            biografie: fig.biography || fig.description || '',
            schwaeche: fig.weakness || '',
            staerke: fig.strength || '',
            charakteristik: fig.characteristic || '',
            archetyp: fig.archetype || '',
            beruf: fig.profession || '',
            ziel: fig.goal || '',
            hindernis: fig.obstacle || '',
            konflikt: fig.conflict || '',
            entwicklung: fig.development || ''
          });
          importedFiguren++;
        }
        
        save(KEYS.figuren(projektId), newFiguren);
        // === SZENEN IMPORTIEREN (inkl. TEXT!) ===
        const newSzenen = [...existingSzenen];
        const newTextbuch = { ...existingTextbuch };
        const szenenIdMap = {};
        
        for (const scene of (data.scenes || [])) {
          if (existingSzenenNames.includes((scene.name || '').toLowerCase())) {
            skippedSzenen++;
            // Aber Text trotzdem importieren wenn vorhanden!
            const existing = existingSzenen.find(s => (s.titel || s.name || '').toLowerCase() === (scene.name || '').toLowerCase());
            if (existing && scene.content && !newTextbuch[existing.id]) {
              newTextbuch[existing.id] = scene.content;
              importedTexte++;
            }
            if (existing) szenenIdMap[scene.id] = existing.id;
            continue;
          }
          
          const newId = genId();
          szenenIdMap[scene.id] = newId;
          
          // Figuren-IDs mappen
          let figurenIds = [];
          if (scene.figures && Array.isArray(scene.figures)) {
            figurenIds = scene.figures.map(fId => {
              if (figurenIdMap[fId]) return figurenIdMap[fId];
              const foundFig = newFiguren.find(f => f.name === fId || f.id === fId);
              return foundFig?.id || fId;
            }).filter(Boolean);
          }
          
          newSzenen.push({
            id: newId,
            nummer: scene.number || String(newSzenen.length + 1),
            titel: scene.name,
            name: scene.name,
            ort: scene.location || '',
            zeit: scene.time || '',
            zusammenfassung: scene.summary || scene.description || '',
            gruppe: scene.act || scene.group || '',
            figuren: figurenIds,
            dauer: scene.estimated_duration || null
          });
          
          // ‚úÖ KRITISCH: Szenentext ins Textbuch importieren!
          if (scene.content) {
            newTextbuch[newId] = scene.content;
            importedTexte++;
          }
          
          importedSzenen++;
        }
        
        save(KEYS.szenen(projektId), newSzenen);
        save(KEYS.textbuch(projektId), newTextbuch);
        
        // === CUES IMPORTIEREN ===
        let importedCues = 0;
        if (data.cues && data.cues.length > 0) {
          const existingCues = load(KEYS.cues(projektId), []);
          const newCues = [...existingCues];
          
          for (const cue of data.cues) {
            const szeneId = szenenIdMap[cue.scene_id] || cue.scene_id;
            newCues.push({
              id: genId(),
              szeneId: szeneId,
              typ: cue.cue_type || cue.type || 'lx',
              nummer: cue.cue_number || cue.number || newCues.length + 1,
              beschreibung: cue.description || '',
              ankerText: cue.anchor_text || '',
              dauer: cue.duration || ''
            });
            importedCues++;
          }
          
          save(KEYS.cues(projektId), newCues);
          state.cues = newCues;
        }
        
        // State aktualisieren
        state.figuren = newFiguren;
        state.szenen = newSzenen;
        state.textbuch = newTextbuch;
        
        // Cloud-Sync wenn aktiv
        if (isCloudMode && currentCloudProjectId) {
          // Projekt-Meta in Cloud
          await db.from('projects').update({
            name: state.projektMeta.titel,
            author: state.projektMeta.autor,
            subtitle: state.projektMeta.untertitel,
            tagline: state.projektMeta.tagline,
            logline: state.projektMeta.logline,
            premiere_date: state.projektMeta.premiere || null,
            venue: state.projektMeta.spielort
          }).eq('id', currentCloudProjectId);
          
          // Neue Figuren in Cloud
          for (const fig of newFiguren) {
            if (!existingFiguren.find(ef => ef.id === fig.id)) {
              await db.from('figures').upsert({
                id: fig.id,
                project_id: currentCloudProjectId,
                name: fig.name,
                abbreviation: fig.kuerzel,
                description: fig.beschreibung,
                color: fig.farbe,
                figure_type: fig.typ,
                want: fig.want,
                need: fig.need
              });
            }
          }
          
          // Neue Szenen in Cloud (inkl. Text!)
          for (const sz of newSzenen) {
            if (!existingSzenen.find(es => es.id === sz.id)) {
              await db.from('scenes').upsert({
                id: sz.id,
                project_id: currentCloudProjectId,
                number: sz.nummer,
                name: sz.titel || sz.name,
                title: sz.titel,
                description: sz.zusammenfassung,
                location: sz.ort,
                time_of_day: sz.zeit,
                scene_group: sz.gruppe
              });
              
              // ‚úÖ Szenentext in Cloud speichern!
              if (newTextbuch[sz.id]) {
                await db.from('scene_texts').upsert({
                  scene_id: sz.id,
                  project_id: currentCloudProjectId,
                  content: newTextbuch[sz.id]
                });
              }
            }
          }
        }
        
        closeModal('showImportModal');
        render();
        
        // Erfolgsmeldung
        let msg = '‚úÖ NINA-Exchange v2.0 Import erfolgreich!\n\n';
        msg += 'üë§ Figuren: ' + importedFiguren + ' neu';
        if (skippedFiguren > 0) msg += ', ' + skippedFiguren + ' √ºbersprungen';
        msg += '\nüé¨ Szenen: ' + importedSzenen + ' neu';
        if (skippedSzenen > 0) msg += ', ' + skippedSzenen + ' √ºbersprungen';
        msg += '\nüìù Texte: ' + importedTexte + ' importiert';
        if (importedCues > 0) msg += '\nüéõÔ∏è Cues: ' + importedCues + ' importiert';
        
        if (state.projektMeta.autor) {
          msg += '\n\n‚úçÔ∏è Autor: ' + state.projektMeta.autor;
        }
        
        if (isCloudMode) {
          msg += '\n\n‚òÅÔ∏è Daten wurden in die Cloud synchronisiert.';
        }
        
        alert(msg);
        
        ninaImportData = null;
        
      } catch (err) {
        console.error('NINA Import Fehler:', err);
        alert('‚ùå Import fehlgeschlagen: ' + err.message);
      }
    }
    
    // Neue universelle Dokumenten-Handler-Funktion
    async function handleDocumentFile(input) {
      const file = input.files[0];
      if (!file) return;
      
      const fileName = file.name.toLowerCase();
      const isPDF = fileName.endsWith('.pdf');
      const isWord = fileName.endsWith('.docx');
      
      document.getElementById('import-word-name').textContent = '‚è≥ ' + file.name + ' wird gelesen...';
      document.getElementById('import-format-info').style.display = 'none';
      
      try {
        let result;
        
        if (isPDF) {
          result = await extractPDFContent(file);
        } else if (isWord) {
          result = await extractWordContent(file);
        } else {
          throw new Error('Nicht unterst√ºtztes Format. Bitte .docx oder .pdf verwenden.');
        }
        
        importedWordData = {
          html: result.html,
          text: result.text,
          richText: result.richText, // Text mit Formatierungsmarkern
          formatInfo: result.formatInfo,
          fileName: file.name,
          fileType: isPDF ? 'pdf' : 'word'
        };
        
        // UI aktualisieren
        document.getElementById('import-word-name').textContent = '‚úÖ ' + file.name;
        
        // Format-Info anzeigen
        if (result.formatInfo && Object.keys(result.formatInfo).length > 0) {
          const formatDetails = document.getElementById('import-format-details');
          let infoHtml = [];
          
          // Echte Formatvorlagen (h√∂chste Priorit√§t)
          if (result.hasRealStyles) {
            infoHtml.push('<strong style="color: #059669;">‚úì Echte Formatvorlagen erkannt!</strong>');
            if (result.formatInfo.stuecktitelCount > 0) infoHtml.push(`üìñ ${result.formatInfo.stuecktitelCount}x St√ºcktitel`);
            if (result.formatInfo.aktCount > 0) infoHtml.push(`üé≠ ${result.formatInfo.aktCount}x Akt`);
            if (result.formatInfo.szeneCount > 0) infoHtml.push(`üé¨ ${result.formatInfo.szeneCount}x Szene`);
            if (result.formatInfo.dialogCount > 0) infoHtml.push(`üí¨ ${result.formatInfo.dialogCount}x Dialog`);
            if (result.formatInfo.regieCount > 0) infoHtml.push(`üìù ${result.formatInfo.regieCount}x Regie`);
            if (result.formatInfo.liedCount > 0) infoHtml.push(`üéµ ${result.formatInfo.liedCount}x Lied`);
          } else {
            // Fallback auf Zeichenformate
            if (result.formatInfo.italicCount > 0) infoHtml.push(`üìù ${result.formatInfo.italicCount}x kursiv (‚Üí evtl. Regie)`);
            if (result.formatInfo.boldCount > 0) infoHtml.push(`<b>B</b> ${result.formatInfo.boldCount}x fett`);
            if (result.formatInfo.headingCount > 0) infoHtml.push(`üìë ${result.formatInfo.headingCount}x √úberschriften`);
          }
          
          formatDetails.innerHTML = infoHtml.join(' ‚Ä¢ ') || 'Standardformat erkannt';
          document.getElementById('import-format-info').style.display = 'block';
        }
        
        // Preview
        const preview = document.getElementById('import-word-preview');
        const previewText = document.getElementById('import-word-preview-text');
        preview.style.display = 'block';
        previewText.textContent = result.text.substring(0, 1500) + (result.text.length > 1500 ? '\n...' : '');
        
        // Button aktivieren
        document.getElementById('import-word-btn').disabled = false;
        
      } catch (error) {
        console.error('Import Fehler:', error);
        document.getElementById('import-word-name').textContent = '‚ùå Fehler: ' + error.message;
        alert('Fehler beim Lesen der Datei:\n\n' + error.message);
      }
    }
    
    // Word-Datei mit mammoth.js laden (mit Styling-Erkennung)
    async function extractWordContent(file) {
      const arrayBuffer = await file.arrayBuffer();
      
      // === ERWEITERTE StyleMap v2.0 ===
      // Basierend auf Analyse von 11 Theaterst√ºcken (DE, EN, FR)
      const options = {
        styleMap: [
          // === DEUTSCHE FORMATVORLAGEN ===
          "p[style-name='St√ºcktitel'] => h1.stuecktitel:fresh",
          "p[style-name='Untertitel'] => p.untertitel:fresh",
          "p[style-name='Akt'] => h2.akt:fresh",
          "p[style-name='Akttitel'] => h2.akt:fresh",
          "p[style-name='Akt-Titel'] => h2.akt:fresh",
          "p[style-name='Aufzug'] => h2.akt:fresh",
          "p[style-name='Szene Titel'] => h3.szene-titel:fresh",
          "p[style-name='Szenentitel'] => h3.szene-titel:fresh",
          "p[style-name='Szenen-Titel'] => h3.szene-titel:fresh",
          "p[style-name='Szene'] => h3.szene-titel:fresh",
          "p[style-name='Auftritt'] => h3.szene-titel:fresh",
          "p[style-name='Bild'] => h3.szene-titel:fresh",
          "p[style-name='Dialog'] => p.dialog:fresh",
          "p[style-name='Sprecher'] => p.dialog:fresh",
          "p[style-name='Figurentext'] => p.dialog:fresh",
          "p[style-name='Figurenname'] => p.dialog:fresh",
          "p[style-name='Regieanweisung'] => p.regie:fresh",
          "p[style-name='Regie'] => p.regie:fresh",
          "p[style-name='B√ºhnenanweisung'] => p.regie:fresh",
          "p[style-name='Nebentext'] => p.regie:fresh",
          "p[style-name='Liedtext'] => p.lied:fresh",
          "p[style-name='Lied'] => p.lied:fresh",
          "p[style-name='Song'] => p.lied:fresh",
          "p[style-name='Vers'] => p.vers:fresh",
          "p[style-name='Text'] => p.text:fresh",
          "p[style-name='Titel'] => h1.stuecktitel:fresh",
          "p[style-name='Personen'] => p.figurenliste:fresh",
          "p[style-name='Figuren'] => p.figurenliste:fresh",
          
          // === ENGLISCHE FORMATVORLAGEN ===
          "p[style-name='Title'] => h1.stuecktitel:fresh",
          "p[style-name='Subtitle'] => p.untertitel:fresh",
          "p[style-name='Act'] => h2.akt:fresh",
          "p[style-name='Act Title'] => h2.akt:fresh",
          "p[style-name='Scene'] => h3.szene-titel:fresh",
          "p[style-name='Scene Title'] => h3.szene-titel:fresh",
          "p[style-name='Scene Heading'] => h3.szene-titel:fresh",
          "p[style-name='Dialogue'] => p.dialog:fresh",
          "p[style-name='Character'] => p.dialog:fresh",
          "p[style-name='Character Name'] => p.dialog:fresh",
          "p[style-name='Stage Direction'] => p.regie:fresh",
          "p[style-name='Action'] => p.regie:fresh",
          "p[style-name='Parenthetical'] => p.regie:fresh",
          "p[style-name='Lyrics'] => p.lied:fresh",
          "p[style-name='Cast'] => p.figurenliste:fresh",
          
          // === FRANZ√ñSISCHE FORMATVORLAGEN ===
          "p[style-name='Titre'] => h1.stuecktitel:fresh",
          "p[style-name='Sous-titre'] => p.untertitel:fresh",
          "p[style-name='Acte'] => h2.akt:fresh",
          "p[style-name='Sc√®ne'] => h3.szene-titel:fresh",
          "p[style-name='Didascalie'] => p.regie:fresh",
          "p[style-name='R√©plique'] => p.dialog:fresh",
          "p[style-name='Personnage'] => p.dialog:fresh",
          "p[style-name='Personnages'] => p.figurenliste:fresh",
          
          // === √úBERSCHRIFTEN (Fallback) ===
          "p[style-name='Heading 1'] => h1.heading:fresh",
          "p[style-name='Heading 2'] => h2.heading:fresh",
          "p[style-name='Heading 3'] => h3.heading:fresh",
          "p[style-name='√úberschrift 1'] => h1.heading:fresh",
          "p[style-name='√úberschrift 2'] => h2.heading:fresh",
          "p[style-name='√úberschrift 3'] => h3.heading:fresh",
          
          // === ZEICHENFORMATE ===
          "r[style-name='Figurenname'] => span.figur",
          "r[style-name='Figur'] => span.figur",
          "r[style-name='Character Name'] => span.figur",
          "r[style-name='Sprecher'] => span.figur",
          "b => strong",
          "i => em"
        ]
      };
      
      const result = await mammoth.convertToHtml({ arrayBuffer }, options);
      const html = result.value;
      
      // Debug: Welche Styles wurden erkannt?
      console.log('Mammoth Messages:', result.messages);
      
      // Formatierungen analysieren
      const formatInfo = {
        stuecktitelCount: (html.match(/class="stuecktitel"/g) || []).length,
        untertitelCount: (html.match(/class="untertitel"/g) || []).length,
        aktCount: (html.match(/class="akt"/g) || []).length,
        szeneCount: (html.match(/class="szene-titel"/g) || []).length,
        dialogCount: (html.match(/class="dialog"/g) || []).length,
        regieCount: (html.match(/class="regie"/g) || []).length,
        liedCount: (html.match(/class="lied"/g) || []).length,
        italicCount: (html.match(/<em>/g) || []).length,
        boldCount: (html.match(/<strong>/g) || []).length,
        headingCount: (html.match(/<h[1-6]/g) || []).length
      };
      
      // Pr√ºfen ob echte Formatvorlagen erkannt wurden
      const hasRealStyles = formatInfo.dialogCount > 0 || formatInfo.regieCount > 0 || 
                           formatInfo.aktCount > 0 || formatInfo.szeneCount > 0;
      
      // HTML in strukturierten Text mit Markern konvertieren
      let richText = html
        // Echte Formatvorlagen -> Marker
        .replace(/<h1 class="stuecktitel">([^<]+)<\/h1>/g, '[[STUECKTITEL:$1]]\n')
        .replace(/<p class="untertitel">([^<]+)<\/p>/g, '[[UNTERTITEL:$1]]\n')
        .replace(/<h2 class="akt">([^<]+)<\/h2>/g, '[[AKT:$1]]\n')
        .replace(/<h3 class="szene-titel">([^<]+)<\/h3>/g, '[[SZENE:$1]]\n')
        .replace(/<p class="dialog">([^<]+)<\/p>/g, '[[DIALOG:$1]]\n')
        .replace(/<p class="regie">([^<]+)<\/p>/g, '[[REGIE:$1]]\n')
        .replace(/<p class="lied">([^<]+)<\/p>/g, '[[LIED:$1]]\n')
        .replace(/<p class="text">([^<]+)<\/p>/g, '$1\n')
        // Headings als Fallback
        .replace(/<h1 class="heading">([^<]+)<\/h1>/g, '[[HEADING1:$1]]\n')
        .replace(/<h2 class="heading">([^<]+)<\/h2>/g, '[[HEADING2:$1]]\n')
        .replace(/<h3 class="heading">([^<]+)<\/h3>/g, '[[HEADING3:$1]]\n')
        // Zeichenformate
        .replace(/<em>([^<]+)<\/em>/g, '[[ITALIC:$1]]')
        .replace(/<strong>([^<]+)<\/strong>/g, '[[BOLD:$1]]')
        .replace(/<span class="figur">([^<]+)<\/span>/g, '[[FIGUR:$1]]');
      
      // Reiner Text
      const textOnly = html.replace(/<[^>]+>/g, '\n').replace(/\n+/g, '\n').trim();
      
      return {
        html: html,
        text: textOnly,
        richText: richText.replace(/<[^>]+>/g, '\n').replace(/\n+/g, '\n').trim(),
        formatInfo: formatInfo,
        hasRealStyles: hasRealStyles
      };
    }
    
    // PDF-Datei mit pdf.js laden
    async function extractPDFContent(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      
      let fullText = '';
      let richText = '';
      let formatInfo = {
        italicCount: 0,
        boldCount: 0,
        dialogCount: 0,
        headingCount: 0
      };
      
      // Alle Seiten durchgehen
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const textContent = await page.getTextContent();
        
        let pageText = '';
        let lastY = null;
        let lastFontSize = null;
        
        for (const item of textContent.items) {
          const text = item.str;
          const y = item.transform[5];
          const fontName = item.fontName || '';
          const fontSize = item.height || 12;
          
          // Neue Zeile erkennen (Y-Position √§ndert sich)
          if (lastY !== null && Math.abs(y - lastY) > 5) {
            pageText += '\n';
            richText += '\n';
          }
          
          // Formatierung aus Schriftname erkennen
          const isItalic = fontName.toLowerCase().includes('italic') || fontName.toLowerCase().includes('oblique');
          const isBold = fontName.toLowerCase().includes('bold');
          const isHeading = fontSize > 14;
          
          if (isItalic) {
            formatInfo.italicCount++;
            richText += `[[ITALIC:${text}]]`;
          } else if (isBold) {
            formatInfo.boldCount++;
            richText += `[[BOLD:${text}]]`;
          } else if (isHeading && text.length > 2) {
            formatInfo.headingCount++;
            richText += `[[HEADING:${text}]]`;
          } else {
            richText += text;
          }
          
          pageText += text;
          lastY = y;
          lastFontSize = fontSize;
        }
        
        fullText += pageText + '\n\n';
      }
      
      // Dialog-Muster z√§hlen
      formatInfo.dialogCount = (fullText.match(/^[A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√ú\s]{1,20}[:\.]/gm) || []).length;
      
      return {
        html: fullText.replace(/\n/g, '<br>'),
        text: fullText.trim(),
        richText: richText.trim(),
        formatInfo: formatInfo
      };
    }
    
    // Alte Funktion als Wrapper behalten f√ºr Kompatibilit√§t
    async function handleWordFile(input) {
      return handleDocumentFile(input);
    }
    
    // Word-Import durchf√ºhren (ohne KI - Formatvorlagen funktionieren besser!)
    async function doImportWord() {
      if (!importedWordData) {
        alert('Bitte zuerst eine Datei ausw√§hlen.');
        return;
      }
      
      // Import immer mit Formatvorlagen/Textmuster (kein KI)
      doSimpleWordImport(importedWordData);
    }
    
    // ============================================
    // IMPORT-LOGIK v2.0
    // ============================================
    // WORD: 1. Formatvorlagen ‚Üí 2. Textmuster-Analyse
    // PDF:  Direkt Textmuster-Analyse
    // ANALYSE: Figurenliste ZUERST ‚Üí dann Dialoge erkennen!
    // ============================================
    
    function doSimpleWordImport(data) {
      const richText = data.richText || data.text;
      const plainText = data.text;
      const hasRealStyles = data.hasRealStyles || false;
      
      console.log('=== IMPORT START ===');
      console.log('Dateityp:', data.fileType || 'word');
      console.log('Hat Formatvorlagen:', hasRealStyles);
      
      // PRIORIT√ÑT 1: Word-Formatvorlagen (wenn vorhanden)
      if (hasRealStyles) {
        console.log('‚Üí Nutze Word-Formatvorlagen');
        importWithStyles(richText, plainText, data.fileName);
        return;
      }
      
      // PRIORIT√ÑT 2: Textmuster-Analyse
      // WICHTIG: Figurenliste ZUERST suchen!
      console.log('‚Üí Starte Textmuster-Analyse...');
      const figuren = extractFigurenlisteFromText(plainText);
      
      if (figuren.length > 0) {
        console.log('‚Üí Figurenliste gefunden, starte intelligenten Import');
        importWithPatternAnalysis(data, figuren);
        return;
      }
      
      // PRIORIT√ÑT 3: Basis-Import (Fallback)
      console.log('‚Üí Keine Struktur erkannt, Basis-Import');
      importBasic(richText, data.fileName);
    }
    
    /**
     * NEU: Import mit Textmuster-Analyse
     * Nutzt die erkannte Figurenliste f√ºr pr√§zise Dialog-Erkennung!
     */
    function importWithPatternAnalysis(data, figuren) {
      const text = data.text;
      const richText = data.richText || text;
      const lines = text.split('\n');
      
      // Figurennamen f√ºr Dialog-Erkennung
      const figurenNamen = figuren.map(f => f.name);
      console.log('Bekannte Figuren:', figurenNamen.join(', '));
      
      // Strukturtyp erkennen
      const strukturTyp = detectStrukturTyp(text);
      console.log('Erkannter Strukturtyp:', strukturTyp);
      
      // Metadaten extrahieren
      const meta = extractMetadatenFromText(text);
      console.log('Metadaten:', meta);
      
      // Szenen-Grenzen finden
      const grenzen = findSzenenGrenzen(text, strukturTyp);
      console.log('Szenen-Grenzen gefunden:', grenzen.length);
      
      // Szenen erstellen
      const newSzenen = [];
      const newTextbuch = {};
      let currentAkt = '1';
      
      if (grenzen.length === 0) {
        // Keine Struktur erkannt - als eine Szene importieren
        console.log('Keine Szenen-Grenzen, importiere als eine Szene');
        const szene = {
          id: genId(),
          nummer: '1.1',
          titel: meta.titel || data.fileName.replace(/\.(docx|pdf)$/i, ''),
          gruppe: '1',
          zusammenfassung: meta.gattung || '',
          figuren: []
        };
        newSzenen.push(szene);
        newTextbuch[szene.id] = formatImportedText(richText);
      } else {
        // Szenen aus erkannten Grenzen erstellen
        for (let i = 0; i < grenzen.length; i++) {
          const grenze = grenzen[i];
          const nextGrenze = grenzen[i + 1];
          
          // Akt-Wechsel erkennen
          if (grenze.isAkt) {
            const aktMatch = grenze.text.match(/(\d+)/);
            if (aktMatch) {
              currentAkt = aktMatch[1];
            } else if (/prolog|vorspiel/i.test(grenze.text)) {
              currentAkt = '0';
            } else {
              currentAkt = (parseInt(currentAkt) + 1).toString();
            }
          }
          
          // Szenen-Nummer berechnen
          const szenenInAkt = newSzenen.filter(s => s.gruppe === currentAkt && !s.nummer.endsWith('.0')).length;
          const istAktHeader = grenze.isAkt && !STRUKTUR_PATTERNS.szene.some(p => p.test(grenze.text));
          const nummer = istAktHeader ? currentAkt + '.0' : currentAkt + '.' + (szenenInAkt + 1);
          
          // Text f√ºr diese Szene extrahieren
          const startLine = grenze.lineIndex;
          const endLine = nextGrenze ? nextGrenze.lineIndex : lines.length;
          const szeneText = lines.slice(startLine, endLine).join('\n');
          
          // Titel bereinigen
          let titel = grenze.text
            .replace(/^\d+\.\s*(Szene|Akt|Bild|Auftritt|Aufzug)\s*[-‚Äì‚Äî/:]*\s*/i, '')
            .replace(/^(Erster?|Zweiter?|Dritter?)\s+(Szene|Akt|Auftritt|Aufzug)\s*[-‚Äì‚Äî/:]*\s*/i, '')
            .substring(0, 60);
          if (!titel || titel === grenze.text) titel = grenze.text.substring(0, 50);
          
          const szene = {
            id: genId(),
            nummer: nummer,
            titel: titel,
            gruppe: currentAkt,
            zusammenfassung: '',
            figuren: []
          };
          newSzenen.push(szene);
          newTextbuch[szene.id] = formatImportedText(szeneText);
        }
      }
      
      // Figuren-Objekte erstellen
      const newFiguren = figuren.map(f => ({
        id: genId(),
        name: f.name || 'Unbenannt',
        kuerzel: (f.name || '').substring(0, 2).toUpperCase(),
        beschreibung: f.beschreibung || ''
      }));
      
      // Figuren den Szenen zuordnen (basierend auf Vorkommen im Text)
      newSzenen.forEach(szene => {
        const szeneText = newTextbuch[szene.id] || '';
        szene.figuren = newFiguren
          .filter(f => {
            // Pr√ºfe ob Figur in dieser Szene spricht/vorkommt
            const namePattern = new RegExp(escapeRegex(f.name) + '\\s*[:\\.\\)]', 'i');
            return namePattern.test(szeneText);
          })
          .map(f => f.id);
      });
      
      // State aktualisieren
      state.szenen = newSzenen;
      state.textbuch = newTextbuch;
      state.figuren = newFiguren;
      state.aktiveSzene = newSzenen[0]?.id;
      
      // Projekt-Meta aktualisieren
      if (meta.titel) state.projektMeta.titel = meta.titel;
      if (meta.gattung) state.projektMeta.untertitel = meta.gattung;
      if (meta.autor) state.projektMeta.autor = meta.autor;
      if (meta.copyright) state.projektMeta.copyright = meta.copyright;
      
      state.projektMeta.strukturTyp = strukturTyp === 'bilder' ? 'bilder' : 
                                       strukturTyp === 'nummeriert' ? 'sequenzen' : 'akte';
      
      if (!state.projektMeta.titel) {
        state.projektMeta.titel = data.fileName.replace(/\.(docx|pdf)$/i, '');
      }
      
      // Projektname in Liste aktualisieren
      const projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === state.projektId);
      if (idx !== -1 && state.projektMeta.titel) {
        projekte[idx].name = state.projektMeta.titel;
        save(KEYS.projekte, projekte);
      }
      
      saveProjektDaten();
      closeModal('showImportModal');
      importedWordData = null;
      render();
      
      console.log('=== IMPORT FERTIG ===');
      
      alert(`‚úÖ Import erfolgreich!

üìÑ ${state.projektMeta.titel || 'St√ºck'}
üë§ ${newFiguren.length} Figuren erkannt
üé¨ ${newSzenen.length} Szenen erstellt
üèõÔ∏è Struktur: ${strukturTyp === 'bilder' ? 'Bilder' : strukturTyp === 'nummeriert' ? 'Nummeriert' : 'Akte/Szenen'}

Die Figuren wurden aus der Figurenliste erkannt und den Szenen zugeordnet.`);
    }
    
    // Import mit erkannten Formatvorlagen (ohne KI)
    function importWithStyles(richText, plainText, fileName) {
      // Szenen aus Markern extrahieren
      const lines = richText.split('\n');
      let currentAkt = '1';
      let szenenCounter = 0;
      let currentSzene = null;
      let currentSzeneText = [];
      const newSzenen = [];
      const newTextbuch = {};
      const figurenSet = new Set();
      let stuecktitel = '';
      let untertitel = '';
      
      for (const line of lines) {
        // St√ºcktitel
        if (line.includes('[[STUECKTITEL:')) {
          const match = line.match(/\[\[STUECKTITEL:([^\]]+)\]\]/);
          if (match) stuecktitel = match[1].trim();
          continue;
        }
        
        // Untertitel
        if (line.includes('[[UNTERTITEL:')) {
          const match = line.match(/\[\[UNTERTITEL:([^\]]+)\]\]/);
          if (match) untertitel += (untertitel ? ' ' : '') + match[1].trim();
          continue;
        }
        
        // Akt-Wechsel
        if (line.includes('[[AKT:')) {
          const match = line.match(/\[\[AKT:([^\]]+)\]\]/);
          if (match) {
            const aktText = match[1].trim();
            // Akt-Nummer extrahieren
            const aktNumMatch = aktText.match(/(\d+)/);
            if (aktNumMatch) {
              currentAkt = aktNumMatch[1];
            } else if (aktText.toLowerCase().includes('vorspiel') || aktText.toLowerCase().includes('prolog')) {
              currentAkt = '0';
            } else {
              currentAkt = (parseInt(currentAkt) + 1).toString();
            }
            szenenCounter = 0;
            
            // Akt als "Szene 0" speichern f√ºr Header
            if (currentSzene) {
              newTextbuch[currentSzene.id] = formatImportedText(currentSzeneText.join('\n'));
            }
            currentSzene = {
              id: genId(),
              nummer: currentAkt + '.0',
              titel: aktText,
              gruppe: currentAkt,
              zusammenfassung: '',
              figuren: []
            };
            newSzenen.push(currentSzene);
            currentSzeneText = [line];
          }
          continue;
        }
        
        // Neue Szene
        if (line.includes('[[SZENE:')) {
          // Vorherige Szene speichern
          if (currentSzene) {
            newTextbuch[currentSzene.id] = formatImportedText(currentSzeneText.join('\n'));
          }
          
          const match = line.match(/\[\[SZENE:([^\]]+)\]\]/);
          if (match) {
            szenenCounter++;
            const szeneText = match[1].trim();
            
            // Nummer aus Text extrahieren falls vorhanden
            const numMatch = szeneText.match(/^(\d+)\.\s*Szene/i);
            const nummer = numMatch ? (currentAkt + '.' + numMatch[1]) : (currentAkt + '.' + szenenCounter);
            
            currentSzene = {
              id: genId(),
              nummer: nummer,
              titel: szeneText.replace(/^\d+\.\s*Szene\s*[-‚Äì‚Äî]\s*/i, '').substring(0, 60),
              gruppe: currentAkt,
              zusammenfassung: '',
              figuren: []
            };
            newSzenen.push(currentSzene);
            currentSzeneText = [line];
          }
          continue;
        }
        
        // Dialoge - Figuren sammeln
        if (line.includes('[[DIALOG:')) {
          const match = line.match(/\[\[DIALOG:([^\]]+)\]\]/);
          if (match) {
            const dialogText = match[1].trim();
            const figurMatch = dialogText.match(/^([A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]*?)\s*[:\.]/);
            if (figurMatch) {
              figurenSet.add(figurMatch[1].trim());
            }
          }
        }
        
        // Text zur aktuellen Szene hinzuf√ºgen
        if (currentSzene) {
          currentSzeneText.push(line);
        } else if (line.trim()) {
          // Noch keine Szene - erste Szene erstellen
          szenenCounter++;
          currentSzene = {
            id: genId(),
            nummer: currentAkt + '.' + szenenCounter,
            titel: 'Beginn',
            gruppe: currentAkt,
            zusammenfassung: '',
            figuren: []
          };
          newSzenen.push(currentSzene);
          currentSzeneText = [line];
        }
      }
      
      // Letzte Szene speichern
      if (currentSzene) {
        newTextbuch[currentSzene.id] = formatImportedText(currentSzeneText.join('\n'));
      }
      
      // Fallback: Mindestens eine Szene
      if (newSzenen.length === 0) {
        const szene = {
          id: genId(),
          nummer: '1.1',
          titel: fileName.replace(/\.(docx|pdf)$/i, ''),
          gruppe: '1',
          zusammenfassung: 'Importiert aus ' + fileName,
          figuren: []
        };
        newSzenen.push(szene);
        newTextbuch[szene.id] = formatImportedText(richText);
      }
      
      // Figuren erstellen
      const newFiguren = Array.from(figurenSet).map(name => ({
        id: genId(),
        name: name,
        kuerzel: name.substring(0, 2).toUpperCase(),
        beschreibung: ''
      }));
      
      // Figuren den Szenen zuordnen
      newSzenen.forEach(szene => {
        const szeneText = newTextbuch[szene.id] || '';
        szene.figuren = newFiguren
          .filter(f => szeneText.includes(f.name + ':') || szeneText.includes(f.name + '.'))
          .map(f => f.id);
      });
      
      // State aktualisieren
      state.szenen = newSzenen;
      state.textbuch = newTextbuch;
      state.figuren = newFiguren;
      state.aktiveSzene = newSzenen[0]?.id;
      
      // Projekt-Meta
      if (stuecktitel) state.projektMeta.titel = stuecktitel;
      if (untertitel) state.projektMeta.untertitel = untertitel;
      if (!state.projektMeta.titel) {
        state.projektMeta.titel = fileName.replace(/\.(docx|pdf)$/i, '');
      }
      
      // Projektname aktualisieren
      const projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === state.projektId);
      if (idx !== -1 && state.projektMeta.titel) {
        projekte[idx].name = state.projektMeta.titel;
        save(KEYS.projekte, projekte);
      }
      
      saveProjektDaten();
      closeModal('showImportModal');
      importedWordData = null;
      render();
      
      alert('‚úÖ Import mit Formatvorlagen erfolgreich!\n\nüìÑ ' + (state.projektMeta.titel || 'St√ºck') + '\nüë§ ' + newFiguren.length + ' Figuren erkannt\nüé¨ ' + newSzenen.length + ' Szenen erstellt\n\nDie Struktur wurde automatisch aus den Word-Formatvorlagen erkannt.');
    }
    
    // Basis-Import ohne Struktur (Fallback)
    function importBasic(text, fileName) {
      // Als eine Szene importieren
      const neueSzene = {
        id: genId(),
        nummer: '1.1',
        titel: fileName.replace(/\.(docx|pdf)$/i, ''),
        ort: '',
        zeit: '',
        gruppe: '1',
        zusammenfassung: 'Importiert aus ' + fileName,
        figuren: []
      };
      
      // HTML formatieren
      let html = formatImportedText(text);
      
      state.szenen = [neueSzene];
      state.textbuch = { [neueSzene.id]: html };
      state.aktiveSzene = neueSzene.id;
      
      if (!state.projektMeta.titel) {
        state.projektMeta.titel = fileName.replace(/\.(docx|pdf)$/i, '');
      }
      
      saveProjektDaten();
      closeModal('showImportModal');
      importedWordData = null;
      render();
      
      alert('‚úÖ Dokument importiert!\n\n‚ö†Ô∏è Keine Formatvorlagen erkannt.\nDas Dokument wurde als eine Szene importiert.\n\nTipp: Nutze "‚úÇÔ∏è Teilen" um den Text in mehrere Szenen aufzuteilen,\noder aktiviere die KI-Analyse f√ºr bessere Strukturerkennung.');
    }


    // KI-gest√ºtzter Import
    async function doImportWithAI(text, apiKey) {
      const status = document.getElementById('import-word-status');
      const statusText = document.getElementById('import-word-status-text');
      status.style.display = 'block';
      statusText.textContent = 'Analysiere mit KI...';
      document.getElementById('import-word-btn').disabled = true;
      
      // Nutze richText falls vorhanden (enth√§lt Formatierungsmarker)
      const analysisText = importedWordData?.richText || text;
      const formatInfo = importedWordData?.formatInfo || {};
      
      try {
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 16000,
            messages: [{
              role: 'user',
              content: `Du bist ein erfahrener Dramaturg. Analysiere dieses Theaterst√ºck SEHR SORGF√ÑLTIG.

WICHTIG - SCHWEIZER RECHTSCHREIBUNG: Verwende IMMER "ss" statt "√ü" (z.B. "Strasse", "gross", "weiss").

=== FORMATIERUNGSMARKER IM TEXT ===
Der Text enth√§lt m√∂glicherweise diese Marker:
- [[ITALIC:text]] = Kursiver Text ‚Üí Meist REGIEANWEISUNGEN
- [[BOLD:text]] = Fetter Text ‚Üí Meist FIGURENNAMEN oder √úBERSCHRIFTEN  
- [[HEADING:text]] = √úberschrift ‚Üí Meist AKT-/SZENEN-TITEL
- [[REGIE:text]] = Als Regieanweisung formatiert
- [[DIALOG:text]] = Als Dialog formatiert
- [[SZENE:text]] = Als Szenentitel formatiert
- [[AKT:text]] = Als Akttitel formatiert
- [[LIED:text]] = Als Liedtext formatiert

Erkannte Formatierungen: ${formatInfo.italicCount || 0}x kursiv, ${formatInfo.boldCount || 0}x fett, ${formatInfo.headingCount || 0}x √úberschriften

=== FIGURENLISTE ZUERST! (WICHTIG!) ===
Suche am ANFANG des Textes nach einer Figurenliste:
- "Personen:" / "Figuren:" / "Rollen:" / "Besetzung:"
- "PERSONNAGES:" (franz√∂sisch) / "Characters:" (englisch)
- Format: "NAME - Beschreibung" oder "NAME, Rolle"
- Gruppiert: "Die Bauern: Hans, Fritz, Karl"
Die dort genannten Namen helfen bei der Dialog-Erkennung!

=== STRUKTUR-TYPEN ===
Erkenne welcher Strukturtyp vorliegt:
1. AKTE & SZENEN: "1. Akt", "Erste Szene", "Akt II" ‚Üí strukturTyp: "akte"
2. AUFZ√úGE & AUFTRITTE: "Erster Aufzug", "2. Auftritt" ‚Üí strukturTyp: "akte"
3. BILDER: Nur Nummern "1." "2." "3." oder "A." "B." ‚Üí strukturTyp: "bilder"
4. NUMMERIERT: "1.1", "1.2", "2.1" ‚Üí strukturTyp: "sequenzen"
5. SCHAUPL√ÑTZE: Ortsnamen als √úberschriften ‚Üí strukturTyp: "sequenzen"
6. KEINE GLIEDERUNG: Fortlaufender Text ‚Üí strukturTyp: "episodisch"

=== DIALOG-FORMATE ===
Erkenne das verwendete Format:
- NAME: Text (Doppelpunkt) = h√§ufigstes Format
- NAME. Text (Punkt) = Oper, Klassik (z.B. "LUCENTIO. Holde Bianca...")
- NAME (ohne Zeichen, eigene Zeile) = modernes Theater
- 1. BAUER: / 2. SOLDAT: = Nummerierte generische Figuren
- ERSTER MANN: / ZWEITE FRAU: = Generische Figuren
- CHOR. / ALLE: = Gruppen-Sprecher

=== SZENEN-ERKENNUNG ===
Szenenwechsel erkennen:
1. Explizite Marker: "1. Szene", "Szene 2", "Erste Szene"
2. Akt-Wechsel: "2. Akt", "ERSTER AKT" ‚Üí danach neue Szene
3. Bild-Nummern: "1." "2." "3." (allein auf Zeile)
4. Ortswechsel: Neue √úberschrift oder (Klammern)
5. Zeitsprung: "Am n√§chsten Morgen", "Sp√§ter"
6. "Vorhang" oder "Verwandlung"

REGEL: Jeder ORTSWECHSEL oder ZEITSPRUNG = NEUE SZENE!

=== REGIEANWEISUNGEN ===
- Text in (Klammern) der NICHT in einem Dialog steht
- [[ITALIC:text]] = Kursiv (h√§ufigstes Format!)
- Eigenst√§ndig: "(Er geht zur T√ºr)", "(Stille)", "(Ab)"
- B√ºhne: "(Licht:...)", "(Musik:...)"

=== MUSICAL/OPER ===
Wenn Lieder vorhanden:
- "Musik Nr.X" / "Lied Nr.X" / "Text Nr.X"
- "REFRAIN:" / "(singt)" / "singt:"
- Setze hatLieder: true

Antworte NUR mit validem JSON:

{
  "titel": "Haupttitel des St√ºcks",
  "untertitel": "Untertitel/Gattung falls vorhanden",
  "autor": "Autor:in falls erkennbar",
  "uebersetzer": "√úbersetzer falls erkennbar",
  "copyright": "¬© Jahr falls erkennbar",
  "tagline": "Werbeslogan (max 8 W√∂rter)",
  "logline": "Worum geht es? (2-3 S√§tze)",
  "strukturTyp": "akte|sequenzen|bilder|episodisch",
  "istMusical": false,
  "figuren": [
    {
      "name": "FIGURENNAME",
      "kuerzel": "FN",
      "beschreibung": "Wer ist diese Figur? Was will sie? (2-3 S√§tze)"
    }
  ],
  "szenen": [
    {
      "nummer": "1.1",
      "titel": "Aussagekr√§ftiger Titel",
      "gruppe": "1",
      "ort": "Wo?",
      "zeit": "Wann?",
      "zusammenfassung": "Was passiert? (2-3 S√§tze)",
      "figuren": ["FIGUR1", "FIGUR2"],
      "textAnfang": "Die ersten 50 Zeichen exakt",
      "hatLieder": false
    }
  ]
}

QUALIT√ÑTSREGELN:
- Suche ZUERST nach der Figurenliste!
- Erkenne ALLE Szenen und ALLE Figuren
- "gruppe": "1" = Akt 1, "2" = Akt 2, etc.
- textAnfang: EXAKT die ersten 50 Zeichen (ohne Marker)

TEXT ZUR ANALYSE:
${analysisText.substring(0, 35000)}${analysisText.length > 35000 ? '\n[gek√ºrzt]' : ''}`
            }]
          })
        });
        
        if (!response.ok) {
          throw new Error('API-Fehler: ' + response.status);
        }
        
        const data = await response.json();
        const aiText = data.content[0].text;
        
        // JSON parsen
        let analysis;
        try {
          const jsonMatch = aiText.match(/\{[\s\S]*\}/);
          analysis = JSON.parse(jsonMatch ? jsonMatch[0] : aiText);
        } catch (e) {
          console.error('JSON Parse Error:', aiText);
          throw new Error('KI-Antwort konnte nicht verarbeitet werden.');
        }
        
        statusText.textContent = 'Erstelle Projekt...';
        applyAIAnalysis(analysis, text);
        
      } catch (error) {
        console.error('KI-Import Fehler:', error);
        status.style.display = 'none';
        document.getElementById('import-word-btn').disabled = false;
        
        if (confirm('KI-Analyse fehlgeschlagen: ' + error.message + '\n\nOhne KI importieren?')) {
          doSimpleWordImport(importedWordData);
        }
      }
    }
    
    // KI-Analyse anwenden
    function applyAIAnalysis(analysis, fullText) {
      // Projekt-Meta
      if (analysis.titel) state.projektMeta.titel = analysis.titel;
      if (analysis.untertitel) state.projektMeta.untertitel = analysis.untertitel;
      if (analysis.autor) state.projektMeta.autor = analysis.autor;
      if (analysis.copyright) state.projektMeta.copyright = analysis.copyright;
      if (analysis.tagline) state.projektMeta.tagline = analysis.tagline;
      if (analysis.logline) state.projektMeta.logline = analysis.logline;
      if (analysis.strukturTyp) state.projektMeta.strukturTyp = analysis.strukturTyp;
      
      // Projektname aktualisieren
      const projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === state.projektId);
      if (idx !== -1 && analysis.titel) {
        projekte[idx].name = analysis.titel;
        save(KEYS.projekte, projekte);
      }
      
      // Figuren
      state.figuren = (analysis.figuren || []).map(f => ({
        id: genId(),
        name: f.name || 'Unbenannt',
        kuerzel: f.kuerzel || (f.name || '').substring(0, 2).toUpperCase(),
        beschreibung: f.beschreibung || ''
      }));
      
      // Szenen
      state.szenen = [];
      state.textbuch = {};
      
      const szenenDefs = analysis.szenen || [];
      
      if (szenenDefs.length === 0) {
        // Fallback
        const szene = {
          id: genId(),
          nummer: '1.1',
          titel: analysis.titel || 'Importiert',
          gruppe: '1',
          zusammenfassung: analysis.logline || '',
          figuren: state.figuren.map(f => f.id)
        };
        state.szenen.push(szene);
        state.textbuch[szene.id] = formatImportedText(fullText);
      } else {
        szenenDefs.forEach((sDef, i) => {
          const szene = {
            id: genId(),
            nummer: sDef.nummer || `${Math.floor(i/5)+1}.${(i%5)+1}`,
            titel: sDef.titel || `Szene ${i+1}`,
            gruppe: sDef.gruppe || '1',
            ort: sDef.ort || '',
            zeit: sDef.zeit || '',
            zusammenfassung: sDef.zusammenfassung || '',
            figuren: (sDef.figuren || []).map(fName => {
              const fig = state.figuren.find(f => f.name.toUpperCase() === fName.toUpperCase());
              return fig?.id;
            }).filter(Boolean)
          };
          state.szenen.push(szene);
          
          // Text-Zuordnung (vereinfacht)
          let szeneText = '';
          if (sDef.textAnfang && fullText.includes(sDef.textAnfang.substring(0, 20))) {
            const startIdx = fullText.indexOf(sDef.textAnfang.substring(0, 20));
            const nextDef = szenenDefs[i + 1];
            let endIdx = fullText.length;
            if (nextDef?.textAnfang) {
              const nextStart = fullText.indexOf(nextDef.textAnfang.substring(0, 20), startIdx + 50);
              if (nextStart > startIdx) endIdx = nextStart;
            }
            szeneText = fullText.substring(startIdx, endIdx);
          }
          
          state.textbuch[szene.id] = formatImportedText(szeneText || `[Szene ${szene.nummer}]`);
        });
      }
      
      state.aktiveSzene = state.szenen[0]?.id;
      
      saveProjektDaten();
      closeModal('showImportModal');
      importedWordData = null;
      render();
      
      alert(`‚úÖ KI-Import erfolgreich!

üìÑ ${analysis.titel || 'St√ºck'}
üë§ ${state.figuren.length} Figuren erkannt
üé¨ ${state.szenen.length} Szenen erstellt
üèõÔ∏è Struktur: ${STRUKTUR_TYPEN[analysis.strukturTyp]?.name || 'Akte'}

Pr√ºfe die Ergebnisse und passe sie bei Bedarf an.`);
    }
    
    // Text f√ºr Editor formatieren (mit Marker-Unterst√ºtzung)
    function formatImportedText(text) {
      if (!text) return '<p class="format-standard"><br></p>';
      
      // Marker entfernen aber Information nutzen
      let processedText = text;
      
      // Erst Marker in tempor√§re Tags umwandeln
      processedText = processedText
        // Neue echte Formatvorlagen-Marker
        .replace(/\[\[STUECKTITEL:([^\]]+)\]\]/g, '<STUECKTITEL>$1</STUECKTITEL>')
        .replace(/\[\[UNTERTITEL:([^\]]+)\]\]/g, '<UNTERTITEL>$1</UNTERTITEL>')
        .replace(/\[\[LIED:([^\]]+)\]\]/g, '<LIED>$1</LIED>')
        .replace(/\[\[FIGUR:([^\]]+)\]\]/g, '<FIGUR>$1</FIGUR>')
        .replace(/\[\[HEADING1:([^\]]+)\]\]/g, '<HEADING1>$1</HEADING1>')
        .replace(/\[\[HEADING2:([^\]]+)\]\]/g, '<HEADING2>$1</HEADING2>')
        .replace(/\[\[HEADING3:([^\]]+)\]\]/g, '<HEADING3>$1</HEADING3>')
        // Bestehende Marker
        .replace(/\[\[REGIE:([^\]]+)\]\]/g, '<REGIE>$1</REGIE>')
        .replace(/\[\[DIALOG:([^\]]+)\]\]/g, '<DIALOG>$1</DIALOG>')
        .replace(/\[\[SZENE:([^\]]+)\]\]/g, '<SZENE>$1</SZENE>')
        .replace(/\[\[AKT:([^\]]+)\]\]/g, '<AKT>$1</AKT>')
        .replace(/\[\[HEADING:([^\]]+)\]\]/g, '<HEADING>$1</HEADING>')
        .replace(/\[\[ITALIC:([^\]]+)\]\]/g, '<ITALIC>$1</ITALIC>')
        .replace(/\[\[BOLD:([^\]]+)\]\]/g, '<BOLD>$1</BOLD>');
      
      return processedText
        .split(/\n+/)
        .map(line => {
          line = line.trim();
          if (!line) return '';
          
          // === ECHTE FORMATVORLAGEN (h√∂chste Priorit√§t) ===
          
          // St√ºcktitel (ignorieren wir im Editor, wird in Projekt-Meta gespeichert)
          if (line.includes('<STUECKTITEL>')) {
            const content = line.replace(/<\/?STUECKTITEL>/g, '').trim();
            return `<p class="format-akt-titel" style="font-size: 18pt; text-align: center;">${content}</p>`;
          }
          
          // Untertitel
          if (line.includes('<UNTERTITEL>')) {
            const content = line.replace(/<\/?UNTERTITEL>/g, '').trim();
            return `<p class="format-standard" style="text-align: center; font-style: italic;">${content}</p>`;
          }
          
          // Akt
          if (line.includes('<AKT>')) {
            const content = line.replace(/<\/?AKT>/g, '').trim();
            return `<p class="format-akt-titel">${content}</p>`;
          }
          
          // Szene
          if (line.includes('<SZENE>')) {
            const content = line.replace(/<\/?SZENE>/g, '').trim();
            return `<p class="format-szene-titel">${content}</p>`;
          }
          
          // Regieanweisung
          if (line.includes('<REGIE>')) {
            let content = line.replace(/<\/?REGIE>/g, '').trim();
            // Klammern hinzuf√ºgen falls nicht vorhanden
            if (!content.startsWith('(')) content = '(' + content;
            if (!content.endsWith(')')) content = content + ')';
            return `<p class="format-regieanweisung">${content}</p>`;
          }
          
          // Dialog - MIT Figurenname:Text Erkennung
          if (line.includes('<DIALOG>')) {
            const content = line.replace(/<\/?DIALOG>/g, '').replace(/<\/?[A-Z]+>/g, '').trim();
            // Dialog-Format: NAME: Text oder NAME.Text
            const dialogMatch = content.match(/^([A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]*?)\s*[:\.]\s*(.*)$/);
            if (dialogMatch) {
              const figurName = dialogMatch[1].trim();
              const dialogText = dialogMatch[2] || '';
              return `<div class="format-dialog"><span class="figur-name">${figurName}:</span><span class="dialog-text">${dialogText}</span></div>`;
            }
            // Fallback: Ganzer Text als Dialog ohne erkannten Namen
            return `<p class="format-standard">${content}</p>`;
          }
          
          // Lied
          if (line.includes('<LIED>')) {
            const content = line.replace(/<\/?LIED>/g, '').replace(/<\/?[A-Z]+>/g, '').trim();
            return `<p class="format-lied">${content}</p>`;
          }
          
          // Headings als Fallback
          if (line.includes('<HEADING1>') || line.includes('<HEADING2>')) {
            const content = line.replace(/<\/?HEADING[12]>/g, '').trim();
            // Pr√ºfe ob es ein Akt ist
            if (/^(ERSTER|ZWEITER|DRITTER|I+V?|V?I*|\d+\.?)\s*(AKT|AUFZUG|TEIL)/i.test(content) || /^\d+\.\s*Akt/i.test(content)) {
              return `<p class="format-akt-titel">${content}</p>`;
            }
            return `<p class="format-szene-titel">${content}</p>`;
          }
          
          if (line.includes('<HEADING3>') || line.includes('<HEADING>')) {
            const content = line.replace(/<\/?HEADING3?>/g, '').trim();
            return `<p class="format-szene-titel">${content}</p>`;
          }
          
          // Kursiv = Regieanweisung (wenn keine anderen Marker)
          if (line.includes('<ITALIC>') && !line.match(/^[A-Z√Ñ√ñ√ú]{2,}[:\.]?\s/)) {
            let content = line.replace(/<\/?ITALIC>/g, '').replace(/<\/?[A-Z]+>/g, '').trim();
            if (!content.startsWith('(')) content = '(' + content;
            if (!content.endsWith(')')) content = content + ')';
            return `<p class="format-regieanweisung">${content}</p>`;
          }
          
          // Restliche Marker entfernen
          line = line.replace(/<\/?[A-Z]+[0-9]*>/g, '').trim();
          if (!line) return '';
          
          // === MUSTER-BASIERTE ERKENNUNG (Fallback) ===
          
          // Dialog (NAME: text)
          const dialogMatch = line.match(/^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]*?)\s*[:\.]{1}\s*(.+)$/);
          if (dialogMatch && dialogMatch[1].length < 30 && dialogMatch[1].length > 1) {
            return `<div class="format-dialog"><span class="figur-name">${dialogMatch[1].trim()}:</span><span class="dialog-text">${dialogMatch[2]}</span></div>`;
          }
          
          // Regieanweisung (in Klammern)
          if (line.startsWith('(') && line.endsWith(')')) {
            return `<p class="format-regieanweisung">${line}</p>`;
          }
          
          // Akt-Titel
          if (/^(ERSTER|ZWEITER|DRITTER|VIERTER|F√úNFTER|I+V?|V?I*|\d+\.?)\s*(AKT|AUFZUG|TEIL)/i.test(line)) {
            return `<p class="format-akt-titel">${line}</p>`;
          }
          
          // Szenen-Titel (nummeriert)
          if (/^\d+\.\s*(Szene|SZENE)/i.test(line) || /^(SZENE|Szene)\s*\d/i.test(line)) {
            return `<p class="format-szene-titel">${line}</p>`;
          }
          
          // Lied-Erkennung
          if (line.startsWith('üéµ') || /^\s*(singt|singend|Lied)/i.test(line)) {
            return `<p class="format-lied">${line}</p>`;
          }
          
          return `<p class="format-standard">${line}</p>`;
        })
        .filter(Boolean)
        .join('\n');
    }
    
    function doImportText() {
      const content = document.getElementById('import-text-content').value.trim();
      if (!content) {
        alert('Bitte Text einf√ºgen.');
        return;
      }
      
      const titel = document.getElementById('import-text-title').value.trim() || 'Importierter Text';
      const nummer = document.getElementById('import-text-nummer').value.trim() || '1.1';
      const ersetzen = document.getElementById('import-text-replace').checked;
      
      // Text zu HTML konvertieren (einfache Abs√§tze)
      let html = content
        .split(/\n\n+/)  // Abs√§tze bei Leerzeilen
        .map(para => para.trim())
        .filter(para => para)
        .map(para => {
          // Einfache Heuristik f√ºr Dialog-Erkennung
          const dialogMatch = para.match(/^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü]*(?:\s+[A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü]*)?)[\s]*[:\.]\s*(.+)$/s);
          if (dialogMatch) {
            const figurName = dialogMatch[1].toUpperCase();
            const text = dialogMatch[2].replace(/\n/g, ' ');
            return `<div class="format-dialog"><span class="figur-name">${figurName}:</span><span class="dialog-text">${text}</span></div>`;
          }
          
          // Regieanweisung in Klammern
          if (para.startsWith('(') && para.endsWith(')')) {
            return `<p class="format-regieanweisung">${para}</p>`;
          }
          
          // Akt-Titel erkennen
          if (/^(ERSTER|ZWEITER|DRITTER|VIERTER|F√úNFTER|I+V?|V?I*)\s*(AKT|AUFZUG|TEIL)/i.test(para)) {
            return `<p class="format-akt-titel">${para}</p>`;
          }
          
          // Szenen-Titel erkennen
          if (/^(SZENE|SCENE|BILD|\d+[\.:])/.test(para)) {
            return `<p class="format-szene-titel">${para}</p>`;
          }
          
          // Sonst Standard
          return `<p>${para.replace(/\n/g, '<br>')}</p>`;
        })
        .join('\n');
      
      if (ersetzen) {
        // Alle Szenen l√∂schen
        state.szenen = [];
        state.textbuch = {};
        state.cues = [];
      }
      
      // Neue Szene erstellen
      const neueSzene = {
        id: genId(),
        nummer: nummer,
        titel: titel,
        ort: '',
        zeit: '',
        gruppe: '1',
        zusammenfassung: 'Importierter Text - bitte bearbeiten',
        figuren: []
      };
      
      state.szenen.push(neueSzene);
      state.textbuch[neueSzene.id] = html;
      state.aktiveSzene = neueSzene.id;
      
      saveProjektDaten();
      closeModal('showImportModal');
      render();
      
      alert(`‚úÖ Text importiert!\n\n${content.split(/\n\n+/).length} Abs√§tze wurden als Szene "${titel}" importiert.\n\nNutze "‚úÇÔ∏è¬è Teilen" in der Toolbar um den Text in mehrere Szenen aufzuteilen.`);
    }
    
    function handleTxtImportFile(input) {
      const file = input.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        document.getElementById('import-text-content').value = e.target.result;
        document.getElementById('import-text-title').value = file.name.replace(/\.[^/.]+$/, '');
      };
      reader.readAsText(file);
    }

    function renderExportModal() {
      const aktiveSzene = state.szenen.find(s => s.id === state.aktiveSzene);
      
      return `
        <div class="modal-overlay" onclick="closeModal('showExportModal')">
          <div class="modal-content" style="max-width: 550px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">‚¨ÜÔ∏è¬è Exportieren</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showExportModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="bg-gray-50 rounded-lg p-4 mb-4">
                <p class="font-medium">${state.projektMeta.titel}</p>
                <p class="text-sm text-gray-500">
                  ${state.szenen.length} Szenen ¬∑ ${state.figuren.length} Figuren ¬∑ ${state.cues.length} Cues
                </p>
              </div>
              
              <!-- Textfassung Export -->
              <div class="border-2 border-blue-200 rounded-lg p-4 mb-3 bg-blue-50">
                <div class="flex items-center gap-3 mb-3">
                  <span class="text-2xl">üìÑ</span>
                  <div>
                    <p class="font-medium text-blue-800">Textfassung exportieren</p>
                  </div>
                </div>
                
                <!-- Szenen-Auswahl -->
                <div class="mb-3">
                  <label style="font-size: 11px; color: #1d4ed8; font-weight: 500;">Was exportieren?</label>
                  <select id="export-szenen-auswahl" style="width: 100%; margin-top: 4px; font-size: 13px; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px;" onchange="document.getElementById('export-szenen-liste').style.display = this.value === 'auswahl' ? 'block' : 'none'">
                    <option value="alle">üìö Ganzes St√ºck (alle ${state.szenen.length} Szenen)</option>
                    ${aktiveSzene ? `<option value="aktuelle">üîç Nur aktuelle Szene (${aktiveSzene.nummer} ${aktiveSzene.titel})</option>` : ''}
                    <option value="auswahl">‚òëÔ∏è¬è Szenen ausw√§hlen...</option>
                  </select>
                </div>
                
                <!-- Szenen-Checkboxen (versteckt bis "auswahl" gew√§hlt) -->
                <div id="export-szenen-liste" style="display: none; max-height: 150px; overflow-y: auto; border: 1px solid #bfdbfe; border-radius: 4px; padding: 8px; margin-bottom: 12px; background: white;">
                  ${state.szenen.map(s => `
                    <div style="display: block; font-size: 12px; padding: 4px 0;">
                      <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="export-szene-check" value="${s.id}" checked style="width: 14px; height: 14px; margin-right: 8px; flex-shrink: 0;">
                        <span>${s.nummer} ${s.titel}</span>
                      </label>
                    </div>
                  `).join('')}
                </div>
                
                <div class="flex gap-2">
                  <button class="btn btn-sm btn-primary flex-1" onclick="exportTextfassungWord()">
                    üìù Word (.docx)
                  </button>
                  <button class="btn btn-sm btn-outline flex-1" onclick="exportTextfassungPDF()">
                    üìã PDF (Druck)
                  </button>
                </div>
              </div>
              
              <!-- Projekt-Backup Export - HERVORGEHOBEN -->
              <div class="border-2 border-green-400 rounded-lg p-4 mb-3 bg-green-50 hover:bg-green-100 cursor-pointer" onclick="downloadDrameraExport()">
                <div class="flex items-center gap-3">
                  <span class="text-2xl">üíæ</span>
                  <div class="flex-1">
                    <p class="font-medium text-green-800">Projekt-Backup (.json)</p>
                    <p class="text-sm text-green-700">Vollst√§ndige Sicherung ‚Äì kann wieder importiert werden</p>
                  </div>
                  <span class="px-2 py-1 bg-green-600 text-white text-xs font-bold rounded">SICHER</span>
                </div>
              </div>
              
              <!-- NINA-Exchange Export f√ºr Dramera -->
              <div class="border-2 rounded-lg p-4 mb-3 hover:opacity-90 cursor-pointer" style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(168,113,89,0.15)); border-color: #a87159;" onclick="exportForDramera()">
                <div class="flex items-center gap-3">
                  <span class="text-2xl">üîÑ</span>
                  <div>
                    <p class="font-medium" style="color: #78350f;">F√ºr Dramera Werkbank</p>
                    <p class="text-sm" style="color: #92400e;">√Ñnderungen zur√ºck in die Werkbank bringen</p>
                  </div>
                </div>
              </div>
              
              <!-- Propla Export -->
              <div class="border rounded-lg p-4 mb-3 hover:bg-gray-50 cursor-pointer" onclick="downloadProplaExport()">
                <div class="flex items-center gap-3">
                  <span class="text-2xl">üìÖ</span>
                  <div>
                    <p class="font-medium">F√ºr N!NA-Propla</p>
                    <p class="text-sm text-gray-500">Szenen & Figuren f√ºr Probenplanung</p>
                  </div>
                </div>
              </div>
              
              <button class="btn btn-outline w-full mt-2" onclick="closeModal('showExportModal')">Schliessen</button>
            </div>
          </div>
        </div>
      `;
    }
    
    // Gew√§hlte Szenen f√ºr Export ermitteln
    function getExportSzenen() {
      const select = document.getElementById('export-szenen-auswahl');
      if (!select) return state.szenen;
      
      switch (select.value) {
        case 'aktuelle':
          const aktuelle = state.szenen.find(s => s.id === state.aktiveSzene);
          return aktuelle ? [aktuelle] : state.szenen;
        case 'auswahl':
          const checks = document.querySelectorAll('.export-szene-check:checked');
          const ids = Array.from(checks).map(c => c.value);
          return state.szenen.filter(s => ids.includes(s.id));
        default:
          return state.szenen;
      }
    }
    
    // ============================================
    // TEXTFASSUNG EXPORT (Word & PDF)
    // ============================================
    
    function generateTextfassungHTML(szenenFilter = null) {
      const meta = state.projektMeta;
      const exportSzenen = szenenFilter || getExportSzenen();
      const strukturTyp = meta.strukturTyp || 'akte';
      const struktur = STRUKTUR_TYPEN[strukturTyp];
      
      // Pr√ºfen ob vollst√§ndiger Export oder nur einzelne Szenen
      const istVollstaendig = exportSzenen.length === state.szenen.length;
      const istEinzelszene = exportSzenen.length === 1;
      
      // Szenen nach Gruppen sortieren (nur exportierte Szenen)
      const szenenNachGruppen = {};
      struktur.gruppen.forEach(g => szenenNachGruppen[g] = []);
      exportSzenen.forEach(s => {
        const gruppe = s.gruppe || '1';
        if (szenenNachGruppen[gruppe]) {
          szenenNachGruppen[gruppe].push(s);
        }
      });
      
      // HTML generieren
      let html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${meta.titel || 'Regiebuch'}</title>
  <style>
    @page { 
      size: A4; 
      margin: 2.5cm 2cm;
    }
    body { 
      font-family: 'Times New Roman', Times, serif;
      font-size: 12pt;
      line-height: 1.5;
      color: #000;
    }
    
    /* Titelseite */
    .titelseite {
      page-break-after: always;
      text-align: center;
      padding-top: 2cm;
    }
    .titelseite .titelbild {
      max-width: 14cm;
      max-height: 10cm;
      width: auto;
      height: auto;
      object-fit: contain;
      margin-bottom: 1.5cm;
    }
    .titelseite h1 {
      font-size: 28pt;
      margin-bottom: 0.5cm;
      text-transform: uppercase;
    }
    .titelseite .untertitel {
      font-size: 16pt;
      font-style: italic;
      margin-bottom: 2cm;
    }
    .titelseite .autor {
      font-size: 14pt;
      margin-bottom: 1cm;
    }
    .titelseite .logline {
      font-size: 11pt;
      font-style: italic;
      max-width: 12cm;
      margin: 2cm auto;
      text-align: center;
    }
    .titelseite .meta {
      font-size: 10pt;
      color: #666;
      margin-top: 2cm;
    }
    
    /* Figurenliste */
    .figurenliste {
      page-break-before: always;
      page-break-after: always;
    }
    .figurenliste h2 {
      font-size: 16pt;
      border-bottom: 2px solid #000;
      padding-bottom: 0.3cm;
      margin-bottom: 1cm;
    }
    .figur-eintrag {
      margin-bottom: 0.8cm;
    }
    .figur-eintrag .name {
      font-weight: bold;
      text-transform: uppercase;
    }
    .figur-eintrag .beschreibung {
      margin-left: 1cm;
      font-style: italic;
    }
    
    /* Szenen */
    .szenen-inhalt h2 {
      font-size: 18pt;
      text-align: center;
      margin: 2cm 0 1cm;
      page-break-before: always;
    }
    .szene {
      margin-bottom: 1.5cm;
    }
    .szene-header {
      font-weight: bold;
      font-size: 14pt;
      border-bottom: 1px solid #999;
      padding-bottom: 0.2cm;
      margin-bottom: 0.5cm;
    }
    .szene-meta {
      font-size: 10pt;
      color: #666;
      font-style: italic;
      margin-bottom: 0.5cm;
    }
    
    /* Dialog Export Format */
    .dialog-export {
      margin: 0.2cm 0;
    }
    .dialog-export b {
      font-weight: bold;
      text-transform: uppercase;
    }
    
    /* Fallback f√ºr format-dialog falls nicht konvertiert */
    .format-dialog {
      margin: 0.3cm 0;
    }
    .format-dialog .figur-name {
      font-weight: bold;
      text-transform: uppercase;
    }
    .figur-name {
      font-weight: bold;
      text-transform: uppercase;
    }
    
    .format-regieanweisung {
      font-style: italic;
      margin: 0.3cm 0;
      margin-left: 3.3cm;
      color: #444;
    }
    .format-szene-titel {
      font-weight: bold;
      font-size: 14pt;
      margin: 1cm 0 0.5cm;
      border-bottom: 1px solid #ccc;
    }
    .format-akt-titel {
      font-weight: bold;
      font-size: 18pt;
      text-align: center;
      margin: 2cm 0 1cm;
      text-transform: uppercase;
    }
    .format-lied {
      font-style: italic;
      margin: 0.05cm 0;
      margin-left: 2cm;
      color: #333;
    }
    .format-vers {
      margin: 0.05cm 0;
      margin-left: 2cm;
      font-style: italic;
    }
    .format-pause {
      text-align: center;
      font-weight: bold;
      margin: 1.5cm 0;
      font-size: 14pt;
    }
    .format-standard {
      margin: 0.3cm 0;
    }
    
    /* Cue-Markierungen entfernen f√ºr Druck */
    .cue-marker { display: none; }
    
    @media print {
      body { font-size: 11pt; }
    }
  </style>
</head>
<body>
  
  ${istVollstaendig ? `
  <!-- TITELSEITE -->
  <div class="titelseite">
    ${meta.titelbild ? `<img src="${meta.titelbild}" class="titelbild" alt="Titelbild">` : ''}
    <h1>${meta.titel || 'Ohne Titel'}</h1>
    ${meta.untertitel ? `<div class="untertitel">${meta.untertitel}</div>` : ''}
    ${meta.autor ? `<div class="autor">von ${meta.autor}</div>` : ''}
    ${meta.tagline ? `<div style="font-size: 12pt; margin-top: 1cm;">${meta.tagline}</div>` : ''}
    ${meta.logline ? `<div class="logline">${meta.logline}</div>` : ''}
    <div class="meta">
      ${meta.fassung || 'Arbeitsfassung'}<br>
      ${meta.fassungsDatum ? formatDateTime(new Date(meta.fassungsDatum)) : formatDateTime(new Date())}<br>
      ${meta.spielort ? `Spielort: ${meta.spielort}` : ''}
      ${meta.premiere ? `<br>Premiere: ${new Date(meta.premiere).toLocaleDateString('de-CH')}` : ''}
      ${meta.copyright ? `<br>${meta.copyright}` : ''}
    </div>
  </div>
  
  <!-- FIGURENLISTE -->
  ${state.figuren.length > 0 ? `
    <div class="figurenliste">
      <h2>Figuren</h2>
      ${state.figuren.map(f => `
        <div class="figur-eintrag">
          <span class="name">${f.name}</span>${f.kuerzel ? ` (${f.kuerzel})` : ''}
          ${f.beschreibung ? `<div class="beschreibung">${f.beschreibung}</div>` : ''}
        </div>
      `).join('')}
    </div>
  ` : ''}
  ` : `
  <!-- TEILEXPORT HEADER -->
  <div style="margin-bottom: 1cm;">
    <p style="font-size: 10pt; color: #666;">${meta.titel || 'Regiebuch'} ‚Äì Auszug (${exportSzenen.length} ${exportSzenen.length === 1 ? 'Szene' : 'Szenen'})</p>
  </div>
  `}
  
  <!-- SZENEN -->
  <div class="szenen-inhalt">
    ${istVollstaendig ? struktur.gruppen.map(gruppe => {
      const szenen = szenenNachGruppen[gruppe] || [];
      if (szenen.length === 0) return '';
      
      return `
        <h2>${struktur.gruppenNamen[gruppe] || gruppe}</h2>
        ${szenen.map(szene => {
          let content = state.textbuch[szene.id] || '';
          // Cue-Marker entfernen
          content = content.replace(/<span class="cue-marker[^"]*"[^>]*>[^<]*<\/span>/g, '');
          // Szenen-Titel aus Content entfernen (wird schon im Header angezeigt)
          content = content.replace(/<p[^>]*class\s*=\s*["']format-szene-titel["'][^>]*>[\s\S]*?<\/p>/gi, '');
          // Dialoge Word-kompatibel machen
          content = makeDialogsWordCompatible(content);
          
          return `
            <div class="szene">
              <div class="szene-header">${szene.nummer} ${szene.titel}</div>
              ${(szene.ort || szene.zeit) ? `
                <div class="szene-meta">
                  ${szene.ort ? `Ort: ${szene.ort}` : ''}
                  ${szene.ort && szene.zeit ? ' ¬∑ ' : ''}
                  ${szene.zeit ? `Zeit: ${szene.zeit}` : ''}
                </div>
              ` : ''}
              <div class="szene-text">${content}</div>
            </div>
          `;
        }).join('')}
      `;
    }).join('') : exportSzenen.map(szene => {
      let content = state.textbuch[szene.id] || '';
      // Cue-Marker entfernen
      content = content.replace(/<span class="cue-marker[^"]*"[^>]*>[^<]*<\/span>/g, '');
      // Szenen-Titel aus Content entfernen (wird schon im Header angezeigt)
      content = content.replace(/<p[^>]*class\s*=\s*["']format-szene-titel["'][^>]*>[\s\S]*?<\/p>/gi, '');
      // Dialoge Word-kompatibel machen
      content = makeDialogsWordCompatible(content);
      
      return `
        <div class="szene">
          <div class="szene-header">${szene.nummer} ${szene.titel}</div>
          ${(szene.ort || szene.zeit) ? `
            <div class="szene-meta">
              ${szene.ort ? `Ort: ${szene.ort}` : ''}
              ${szene.ort && szene.zeit ? ' ¬∑ ' : ''}
              ${szene.zeit ? `Zeit: ${szene.zeit}` : ''}
            </div>
          ` : ''}
          <div class="szene-text">${content}</div>
        </div>
      `;
    }).join('')}
  </div>
  
</body>
</html>`;
      
      return html;
    }
    
    // Dialoge f√ºr Word/PDF-Export kompatibel machen - als Tabelle f√ºr korrekte Ausrichtung
    function makeDialogsWordCompatible(html) {
      // format-dialog divs in einfache Paragraphen umwandeln
      // Von: <div class="format-dialog"><span class="figur-name">NAME:</span><span class="dialog-text">Text</span></div>
      // Zu:  <p class="dialog-export"><b>NAME:</b> Text</p>
      
      let result = html.replace(
        /<div[^>]*class\s*=\s*["']format-dialog["'][^>]*>([\s\S]*?)<\/div>/gi,
        function(match, innerContent) {
          // Figur-Name extrahieren
          const nameMatch = innerContent.match(/<span[^>]*class\s*=\s*["']figur-name["'][^>]*>([\s\S]*?)<\/span>/i);
          const textMatch = innerContent.match(/<span[^>]*class\s*=\s*["']dialog-text["'][^>]*>([\s\S]*?)<\/span>/i);
          
          if (nameMatch && textMatch) {
            return '<p class="dialog-export"><b>' + nameMatch[1] + '</b> ' + textMatch[1] + '</p>';
          }
          return match; // Fallback: Original behalten
        }
      );
      
      return result;
    }
    
    function exportTextfassungWord() {
      // Echtes .docx mit docx.js Library erstellen
      exportTextfassungDocx();
    }
    
    async function exportTextfassungDocx() {
      const meta = state.projektMeta;
      const exportSzenen = getExportSzenen();
      const istVollstaendig = exportSzenen.length === state.szenen.length;
      const strukturTyp = meta.strukturTyp || 'akte';
      const struktur = STRUKTUR_TYPEN[strukturTyp];
      
      // docx Library Komponenten
      const { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell, 
              WidthType, AlignmentType, HeadingLevel, BorderStyle, 
              PageBreak, Header, Footer } = docx;
      
      const children = [];
      
      // === TITELSEITE (nur bei vollst√§ndigem Export) ===
      if (istVollstaendig) {
        // Titel
        children.push(new Paragraph({
          children: [new TextRun({ text: meta.titel || 'Ohne Titel', bold: true, size: 56 })],
          alignment: AlignmentType.CENTER,
          spacing: { before: 400, after: 200 }
        }));
        
        // Untertitel
        if (meta.untertitel) {
          children.push(new Paragraph({
            children: [new TextRun({ text: meta.untertitel, italics: true, size: 28 })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 }
          }));
        }
        
        // Autor
        if (meta.autor) {
          children.push(new Paragraph({
            children: [new TextRun({ text: 'von ' + meta.autor, size: 24 })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 }
          }));
        }
        
        // Meta-Infos
        children.push(new Paragraph({
          children: [
            new TextRun({ text: meta.fassung || 'Arbeitsfassung', size: 20 }),
            new TextRun({ text: '\n' + formatDateTime(new Date()), size: 20, break: 1 })
          ],
          alignment: AlignmentType.CENTER,
          spacing: { before: 600 }
        }));
        
        // Seitenumbruch
        children.push(new Paragraph({ children: [new PageBreak()] }));
        
        // === FIGURENLISTE ===
        if (state.figuren.length > 0) {
          children.push(new Paragraph({
            text: 'Figuren',
            heading: HeadingLevel.HEADING_1,
            spacing: { after: 200 }
          }));
          
          state.figuren.forEach(f => {
            children.push(new Paragraph({
              children: [
                new TextRun({ text: f.name, bold: true }),
                new TextRun({ text: f.kuerzel ? ` (${f.kuerzel})` : '' }),
                f.beschreibung ? new TextRun({ text: ' ‚Äì ' + f.beschreibung, italics: true }) : new TextRun('')
              ],
              spacing: { after: 100 }
            }));
          });
          
          children.push(new Paragraph({ children: [new PageBreak()] }));
        }
      } else {
        // Teil-Export Header
        children.push(new Paragraph({
          children: [new TextRun({ 
            text: `${meta.titel || 'Regiebuch'} ‚Äì Auszug (${exportSzenen.length} ${exportSzenen.length === 1 ? 'Szene' : 'Szenen'})`,
            size: 20,
            color: '666666'
          })],
          spacing: { after: 300 }
        }));
      }
      
      // === SZENEN ===
      // Szenen nach Gruppen sortieren
      const szenenNachGruppen = {};
      struktur.gruppen.forEach(g => szenenNachGruppen[g] = []);
      exportSzenen.forEach(s => {
        const gruppe = s.gruppe || '1';
        if (szenenNachGruppen[gruppe]) {
          szenenNachGruppen[gruppe].push(s);
        }
      });
      
      if (istVollstaendig) {
        // Mit Akt-√úberschriften
        struktur.gruppen.forEach(gruppe => {
          const szenen = szenenNachGruppen[gruppe] || [];
          if (szenen.length === 0) return;
          
          // Akt-Titel
          children.push(new Paragraph({
            text: struktur.gruppenNamen[gruppe] || gruppe,
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 400, after: 200 }
          }));
          
          szenen.forEach(szene => {
            addSzeneToDoc(children, szene, { Document, Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, BorderStyle });
          });
        });
      } else {
        // Ohne Akt-√úberschriften
        exportSzenen.forEach(szene => {
          addSzeneToDoc(children, szene, { Document, Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, BorderStyle });
        });
      }
      
      // Dokument mit Formatvorlagen erstellen
      const doc = new Document({
        styles: {
          paragraphStyles: [
            {
              id: 'Dialog',
              name: 'Dialog',
              basedOn: 'Normal',
              next: 'Normal',
              run: { size: 24 },
              paragraph: { spacing: { before: 60, after: 60 } }
            },
            {
              id: 'Regieanweisung',
              name: 'Regieanweisung',
              basedOn: 'Normal',
              next: 'Normal',
              run: { italics: true, size: 24 },
              paragraph: { indent: { left: 1800 }, spacing: { before: 100, after: 100 } }
            },
            {
              id: 'Lied',
              name: 'Lied',
              basedOn: 'Normal',
              next: 'Normal',
              run: { italics: true, size: 24, color: '1e40af' },
              paragraph: { indent: { left: 1200 }, spacing: { before: 20, after: 20 } }
            },
            {
              id: 'Vers',
              name: 'Vers',
              basedOn: 'Normal',
              next: 'Normal',
              run: { italics: true, size: 24 },
              paragraph: { indent: { left: 1200 }, spacing: { before: 20, after: 20 } }
            },
            {
              id: 'AktTitel',
              name: 'Akt-Titel',
              basedOn: 'Normal',
              next: 'Normal',
              run: { bold: true, size: 36, allCaps: true },
              paragraph: { alignment: AlignmentType.CENTER, spacing: { before: 600, after: 300 } }
            },
            {
              id: 'SzenenTitel',
              name: 'Szenen-Titel',
              basedOn: 'Normal',
              next: 'Normal',
              run: { bold: true, size: 28 },
              paragraph: { spacing: { before: 300, after: 100 } }
            },
            {
              id: 'Pause',
              name: 'Pause',
              basedOn: 'Normal',
              next: 'Normal',
              run: { bold: true, size: 28 },
              paragraph: { alignment: AlignmentType.CENTER, spacing: { before: 400, after: 400 } }
            },
            {
              id: 'Standard',
              name: 'Standard',
              basedOn: 'Normal',
              next: 'Normal',
              run: { size: 24 },
              paragraph: { spacing: { after: 100 } }
            }
          ]
        },
        sections: [{
          properties: {
            page: {
              margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 }
            }
          },
          headers: {
            default: new Header({
              children: [new Paragraph({
                children: [
                  new TextRun({ text: meta.titel || 'Regiebuch', size: 18 }),
                  new TextRun({ text: '\t\t' + formatDateTime(new Date()), size: 18 })
                ]
              })]
            })
          },
          children: children
        }]
      });
      
      // Als Blob exportieren und herunterladen
      const blob = await Packer.toBlob(doc);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const fileName = (meta.titel || 'Regiebuch')
        .replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü\s-]/g, '')
        .replace(/\s+/g, '_');
      a.download = `${fileName}_Textfassung.docx`;
      a.click();
      URL.revokeObjectURL(url);
      
      closeModal('showExportModal');
    }
    
    // Hilfsfunktion: Szene zum Dokument hinzuf√ºgen
    function addSzeneToDoc(children, szene, { Document, Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, BorderStyle }) {
      // Szenen-Header
      children.push(new Paragraph({
        children: [new TextRun({ text: `${szene.nummer} ${szene.titel}`, bold: true, size: 28 })],
        spacing: { before: 300, after: 100 },
        border: { bottom: { style: BorderStyle.SINGLE, size: 6, color: 'CCCCCC' } }
      }));
      
      // Ort/Zeit
      if (szene.ort || szene.zeit) {
        children.push(new Paragraph({
          children: [new TextRun({ 
            text: [szene.ort ? `Ort: ${szene.ort}` : '', szene.zeit ? `Zeit: ${szene.zeit}` : ''].filter(Boolean).join(' ¬∑ '),
            italics: true, size: 20, color: '666666'
          })],
          spacing: { after: 200 }
        }));
      }
      
      // Content parsen und hinzuf√ºgen
      const content = state.textbuch[szene.id] || '';
      parseContentToDocx(content, children, { Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, BorderStyle });
    }
    
    // HTML-Content zu docx Paragraphen parsen
    function parseContentToDocx(html, children, { Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, BorderStyle }) {
      // Tempor√§res DOM Element erstellen
      const temp = document.createElement('div');
      temp.innerHTML = html;
      
      // Cue-Marker global entfernen
      const cueMarkers = temp.querySelectorAll('.cue-marker');
      cueMarkers.forEach(m => m.remove());
      
      // Rekursive Funktion um alle Knoten zu durchlaufen
      function processNode(node) {
        // Text-Knoten direkt verarbeiten
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent.trim();
          if (text) {
            children.push(new Paragraph({
              children: [new TextRun({ text: text })],
              spacing: { after: 100 },
              style: 'Standard'
            }));
          }
          return;
        }
        
        // Nur Element-Knoten weiter verarbeiten
        if (node.nodeType !== Node.ELEMENT_NODE) return;
        
        const el = node;
        const classList = el.classList || [];
        const tagName = el.tagName?.toLowerCase() || '';
        
        // Szenen-Titel √ºberspringen (wird schon im Header angezeigt)
        if (classList.contains('format-szene-titel')) return;
        
        // Bekannte formatierte Elemente verarbeiten (nicht rekursiv weitergehen)
        if (classList.contains('format-dialog')) {
          const nameEl = el.querySelector('.figur-name');
          const textEls = el.querySelectorAll('.dialog-text');
          
          // Namen extrahieren (kann leer sein)
          const name = nameEl ? nameEl.textContent.trim() : '';
          
          // Alle dialog-text Elemente sammeln
          let dialogText = '';
          if (textEls.length > 0) {
            textEls.forEach(t => {
              dialogText += t.textContent + ' ';
            });
            dialogText = dialogText.trim();
          }
          
          if (dialogText) {
            if (name) {
              // Dialog mit Figurname
              children.push(new Paragraph({
                children: [
                  new TextRun({ text: name, bold: true }),
                  new TextRun({ text: ' ' + dialogText })
                ],
                spacing: { before: 60, after: 60 },
                style: 'Dialog'
              }));
            } else {
              // Dialog ohne Figurname (Fortsetzung)
              children.push(new Paragraph({
                children: [new TextRun({ text: dialogText })],
                spacing: { before: 60, after: 60 },
                style: 'Dialog'
              }));
            }
          } else {
            // Fallback: Gesamten Text als Dialog exportieren
            const text = el.textContent.trim();
            if (text) {
              children.push(new Paragraph({
                children: [new TextRun({ text: text })],
                spacing: { before: 60, after: 60 },
                style: 'Dialog'
              }));
            }
          }
          return; // Nicht rekursiv weitergehen
        }
        
        if (classList.contains('format-regieanweisung')) {
          children.push(new Paragraph({
            children: [new TextRun({ text: el.textContent, italics: true })],
            indent: { left: 1800 },
            spacing: { before: 100, after: 100 },
            style: 'Regieanweisung'
          }));
          return;
        }
        
        if (classList.contains('format-lied')) {
          children.push(new Paragraph({
            children: [new TextRun({ text: el.textContent, italics: true, color: '1e40af' })],
            indent: { left: 1200 },
            spacing: { before: 20, after: 20 },
            style: 'Lied'
          }));
          return;
        }
        
        if (classList.contains('format-vers')) {
          children.push(new Paragraph({
            children: [new TextRun({ text: el.textContent, italics: true })],
            indent: { left: 1200 },
            spacing: { before: 20, after: 20 },
            style: 'Vers'
          }));
          return;
        }
        
        if (classList.contains('format-akt-titel')) {
          children.push(new Paragraph({
            children: [new TextRun({ text: el.textContent, bold: true, size: 36, allCaps: true })],
            alignment: AlignmentType.CENTER,
            spacing: { before: 600, after: 300 },
            style: 'AktTitel'
          }));
          return;
        }
        
        if (classList.contains('format-pause')) {
          children.push(new Paragraph({
            children: [new TextRun({ text: el.textContent, bold: true, size: 28 })],
            alignment: AlignmentType.CENTER,
            spacing: { before: 400, after: 400 },
            style: 'Pause'
          }));
          return;
        }
        
        // BR-Tags als Zeilenumbruch
        if (tagName === 'br') {
          children.push(new Paragraph({
            children: [new TextRun({ text: '' })],
            spacing: { after: 50 }
          }));
          return;
        }
        
        // Block-Elemente ohne bekannte Klasse: Kinder rekursiv verarbeiten
        const blockElements = ['div', 'p', 'section', 'article', 'main', 'header', 'footer', 'ul', 'ol', 'li', 'blockquote'];
        if (blockElements.includes(tagName) || el.children.length > 0) {
          // Hat das Element selbst nur Text (keine Kind-Elemente)?
          if (el.children.length === 0) {
            const text = el.textContent.trim();
            if (text) {
              children.push(new Paragraph({
                children: [new TextRun({ text: text })],
                spacing: { after: 100 },
                style: 'Standard'
              }));
            }
          } else {
            // Rekursiv durch Kinder gehen
            for (let i = 0; i < el.childNodes.length; i++) {
              processNode(el.childNodes[i]);
            }
          }
          return;
        }
        
        // Inline-Elemente (span, b, i, etc.): Text direkt ausgeben
        const text = el.textContent.trim();
        if (text) {
          const isBold = tagName === 'b' || tagName === 'strong';
          const isItalic = tagName === 'i' || tagName === 'em';
          
          children.push(new Paragraph({
            children: [new TextRun({ 
              text: text, 
              bold: isBold,
              italics: isItalic
            })],
            spacing: { after: 100 },
            style: 'Standard'
          }));
        }
      }
      
      // Alle Kind-Knoten des tempor√§ren Elements verarbeiten
      for (let i = 0; i < temp.childNodes.length; i++) {
        processNode(temp.childNodes[i]);
      }
    }
    
    function exportTextfassungPDF() {
      const html = generateTextfassungHTML();
      
      // Neues Fenster f√ºr Druckvorschau
      const printWindow = window.open('', '_blank');
      printWindow.document.write(html);
      printWindow.document.close();
      
      // Kurz warten dann drucken
      setTimeout(() => {
        printWindow.print();
      }, 500);
      
      closeModal('showExportModal');
    }
    
    // NEU: Export f√ºr Propla
    // ============================================
    // ============================================
    // NINA-EXCHANGE EXPORT v2.0
    // Vollst√§ndiges Format f√ºr Werkbank, Rebu, Propla
    // ============================================
    function exportForDramera() {
      // NINA-Exchange Format v2.0 erstellen
      const ninaExport = {
        format: 'nina-exchange',
        version: '2.0',
        exportedFrom: 'rebu',
        exportedAt: new Date().toISOString(),
        
        // === PROJEKT (alle Felder) ===
        project: {
          name: state.projektMeta.titel || 'Unbenannt',
          subtitle: state.projektMeta.untertitel || '',
          author: state.projektMeta.autor || '',
          director: state.projektMeta.regie || '',
          description: state.projektMeta.logline || '',
          tagline: state.projektMeta.tagline || '',
          logline: state.projektMeta.logline || '',
          copyright: state.projektMeta.copyright || '',
          cover_image: state.projektMeta.titelbild || '',
          premiere_date: state.projektMeta.premiere || null,
          venue: state.projektMeta.spielort || '',
          version_name: state.projektMeta.fassung || 'Arbeitsfassung',
          version_date: state.projektMeta.fassungsDatum || new Date().toISOString(),
          structure_type: state.projektMeta.strukturTyp || 'akte',
          status: 'active'
        },
        
        // === FIGUREN (alle Felder) ===
        figures: state.figuren.map((f, idx) => ({
          id: f.id,
          name: f.name || '',
          short_name: f.kuerzel || f.name?.substring(0, 3).toUpperCase() || '',
          description: f.beschreibung || '',
          figure_type: f.typ || 'main',
          color: f.farbe || '#3b82f6',
          sort_order: idx,
          // Dramaturgie-Felder
          want_external: f.want || '',
          want_internal: f.wantInternal || '',
          need: f.need || '',
          ghost: f.ghost || '',
          biography: f.biografie || f.beschreibung || '',
          weakness: f.schwaeche || '',
          strength: f.staerke || '',
          characteristic: f.charakteristik || '',
          archetype: f.archetyp || '',
          profession: f.beruf || '',
          goal: f.ziel || '',
          obstacle: f.hindernis || '',
          conflict: f.konflikt || '',
          development: f.entwicklung || ''
        })),
        
        // === SZENEN (alle Felder) ===
        scenes: state.szenen.map((s, idx) => {
          // Text aus Textbuch holen
          const rawContent = state.textbuch[s.id] || '';
          
          // Figuren-IDs (nicht Namen, f√ºr bessere Referenz)
          const figurenIds = s.figuren || [];
          
          return {
            id: s.id,
            number: s.nummer || String(idx + 1),
            name: s.titel || `Szene ${idx + 1}`,
            act: s.gruppe || '',
            group: s.gruppe || '',
            description: s.zusammenfassung || '',
            summary: s.zusammenfassung || '',
            location: s.ort || '',
            time: s.zeit || '',
            figures: figurenIds,
            content: rawContent,
            estimated_duration: s.dauer || null,
            status: 'written',
            sort_order: idx
          };
        }),
        
        // === CUES (Licht, Ton, Video) ===
        cues: state.cues.map(c => ({
          id: c.id,
          scene_id: c.szeneId,
          cue_type: c.typ,
          cue_number: c.nummer,
          description: c.beschreibung || '',
          anchor_text: c.ankerText || '',
          duration: c.dauer || '',
          sort_order: c.sortOrder || 0
        })),
        
        // === MEDIEN (Audio, Video, Bilder) ===
        media: (state.medien || []).map(m => ({
          id: m.id,
          name: m.name || '',
          type: m.typ || 'audio',
          url: m.url || '',
          scene_id: m.szeneId || null
        }))
      };
      
      // Als JSON-Datei herunterladen
      const fileName = `${(state.projektMeta.titel || 'projekt').replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü]/g, '_')}_nina-exchange.json`;
      const content = JSON.stringify(ninaExport, null, 2);
      
      // UTF-8 BOM f√ºr bessere Kompatibilit√§t
      const BOM = '\uFEFF';
      const blob = new Blob([BOM + content], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      
      closeModal('showExportModal');
      
      // Szenen mit Text z√§hlen
      const szenenMitText = state.szenen.filter(s => (state.textbuch[s.id] || '').trim().length > 0).length;
      
      let msg = '‚úÖ NINA-Exchange v2.0 Export erstellt!\n\n';
      msg += `üìÅ Datei: ${fileName}\n\n`;
      msg += `üìã Projekt: ${state.projektMeta.titel || 'Unbenannt'}\n`;
      msg += `‚úçÔ∏è Autor: ${state.projektMeta.autor || '(nicht angegeben)'}\n\n`;
      msg += `üë§ ${ninaExport.figures.length} Figuren\n`;
      msg += `üé¨ ${ninaExport.scenes.length} Szenen (${szenenMitText} mit Text)\n`;
      msg += `üéõÔ∏è ${ninaExport.cues.length} Cues\n`;
      msg += `\nDiese Datei kann in Werkbank, Rebu und Propla importiert werden.`;
      
      alert(msg);
    }

    function downloadProplaExport() {
      const exportData = {
        version: '1.0',
        exportDate: new Date().toISOString(),
        source: 'NINA-Rebu v1.4',
        
        projekt: {
          titel: state.projektMeta.titel,
          untertitel: state.projektMeta.untertitel || '',
          autor: state.projektMeta.autor || '',
          premiere: state.projektMeta.premiere || '',
          spielort: state.projektMeta.spielort || ''
        },
        
        figuren: state.figuren.map(f => ({
          id: f.id,
          name: f.name || 'Unbenannt',
          kuerzel: f.kuerzel || (f.name || '').substring(0, 2),
          beschreibung: f.beschreibung || ''
        })),
        
        szenen: state.szenen.map(s => ({
          id: s.id,
          nummer: s.nummer,
          titel: s.titel,
          gruppe: s.gruppe || '1',
          ort: s.ort || '',
          zeit: s.zeit || '',
          zusammenfassung: s.zusammenfassung || '',
          figuren: s.figuren || [],
          // Gesch√§tzte Dauer basierend auf Textl√§nge
          dauer: Math.max(5, Math.round((state.textbuch[s.id]?.length || 0) / 500))
        })),
        
        strukturTyp: state.projektMeta.strukturTyp || 'akte'
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${state.projektMeta.titel.replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü]/g, '_')}_fuer_propla.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      closeModal('showExportModal');
      alert('‚úÖ Export f√ºr N!NA-Propla erstellt!\n\nDie Datei enth√§lt:\n‚Ä¢ Szenenfolge mit Zusammenfassungen\n‚Ä¢ Figurenliste mit Beschreibungen\n‚Ä¢ Szenenbesetzung f√ºr Probenplanung');
    }

    function renderFassungModal() {
      const defaultName = `Fassung vom ${formatDateTime(new Date())}`;
      return `
        <div class="modal-overlay" onclick="closeModal('showFassungModal')">
          <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">üíæ Neue Fassung speichern</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showFassungModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <!-- Warnhinweis -->
              <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                <div style="display: flex; align-items: flex-start; gap: 8px;">
                  <span style="font-size: 18px;">‚ö†Ô∏è¬è</span>
                  <div>
                    <p style="font-size: 13px; font-weight: 500; color: #92400e; margin: 0 0 4px 0;">Nur lokal im Browser!</p>
                    <p style="font-size: 11px; color: #a16207; margin: 0;">
                      Diese Fassung wird nur im Browser-Cache gespeichert. Bei Cache-L√∂schung sind alle Daten weg!
                    </p>
                  </div>
                </div>
              </div>
              
              <p class="text-sm text-gray-500 mb-4">
                Speichere den aktuellen Stand als benannte Fassung (Snapshot).
              </p>
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Name der Fassung</label>
                <input type="text" id="fassung-name" value="${defaultName}" class="w-full">
              </div>
              <div class="flex gap-2 mt-4">
                <button class="btn btn-outline flex-1" onclick="closeModal('showFassungModal')">Abbrechen</button>
                <button class="btn btn-success flex-1" onclick="saveFassung()">üíæ Speichern</button>
              </div>
              
              <!-- Zus√§tzlich: Sicher speichern -->
              <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
                <button class="btn w-full" style="background: #059669; color: white;" onclick="saveFassungAndExport()">
                  üíæ Speichern + üì• Backup exportieren (sicher!)
                </button>
                <p style="font-size: 10px; color: #6b7280; text-align: center; margin-top: 6px;">
                  Speichert die Fassung UND l√§dt ein Backup auf deinen Computer herunter
                </p>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderFigurModal() {
      const f = state.editingFigur || {};
      const isEdit = !!f.id;
      return `
        <div class="modal-overlay" onclick="closeModal('showFigurModal')">
          <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Figur bearbeiten' : 'üë§ Neue Figur'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showFigurModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                  <input type="text" id="figur-name" value="${f.name || ''}" placeholder="MARTHE">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">K√ºrzel</label>
                  <input type="text" id="figur-kuerzel" value="${f.kuerzel || ''}" placeholder="MA" maxlength="4">
                </div>
              </div>
              <div class="mt-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea id="figur-beschreibung" rows="2" placeholder="Die Marketenderin">${f.beschreibung || ''}</textarea>
              </div>
              <div class="grid grid-cols-2 gap-4 mt-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Will (extern)</label>
                  <input type="text" id="figur-want" value="${f.want || ''}" placeholder="√úberleben">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Braucht (intern)</label>
                  <input type="text" id="figur-need" value="${f.need || ''}" placeholder="Liebe">
                </div>
              </div>
              <div class="grid grid-cols-2 gap-4 mt-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Wunde</label>
                  <input type="text" id="figur-wunde" value="${f.wunde || ''}" placeholder="Verlust der Mutter">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Geheimnis</label>
                  <input type="text" id="figur-geheimnis" value="${f.geheimnis || ''}" placeholder="Kennt die Wahrheit">
                </div>
              </div>
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteFigur('${f.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showFigurModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveFigur()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderCueModal() {
      const c = state.editingCue || {};
      const isEdit = !!c.id && state.cues.find(x => x.id === c.id);
      const selectedTyp = c.typ || 'lx';
      
      // Parse umbauAktionen f√ºr Checkboxen
      const umbauAktionen = c.umbauAktionen || [];
      
      return `
        <div class="modal-overlay" onclick="closeModal('showCueModal')">
          <div class="modal-content" style="max-width: 600px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Cue bearbeiten' : 'üí° Neuer Cue'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showCueModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Typ</label>
                  <select id="cue-typ" onchange="updateCueModalForTyp()">
                    ${Object.entries(CUE_TYPEN).map(([k, v]) => `
                      <option value="${k}" ${selectedTyp === k ? 'selected' : ''}>${v.icon} ${v.name} (${v.prefix})</option>
                    `).join('')}
                  </select>
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Nummer</label>
                  <input type="number" id="cue-nummer" value="${c.nummer || ''}" min="1">
                </div>
              </div>
              
              <!-- Verkn√ºpfung f√ºr Requisite -->
              <div id="cue-requisite-section" class="mt-4 ${selectedTyp === 'r' ? '' : 'hidden'}">
                <label class="block text-sm font-medium text-gray-700 mb-1">üé≠ Requisite verkn√ºpfen</label>
                <select id="cue-requisite" onchange="toggleCueRequisitenNeu()">
                  <option value="">‚Äì Neue Requisite erstellen ‚Äì</option>
                  ${state.requisiten.map(r => `
                    <option value="${r.id}" ${c.requisitenId === r.id ? 'selected' : ''}>${r.name}</option>
                  `).join('')}
                </select>
                <input type="text" id="cue-requisite-neu" class="mt-2 ${c.requisitenId ? 'hidden' : ''}" 
                       placeholder="Name der neuen Requisite" value="${c.requisitenName || ''}">
              </div>
              
              <!-- Verkn√ºpfung f√ºr Ton/Video -->
              <div id="cue-medium-section" class="mt-4 ${(selectedTyp === 'q' || selectedTyp === 'v') ? '' : 'hidden'}">
                <label class="block text-sm font-medium text-gray-700 mb-1" id="cue-medium-label">
                  ${selectedTyp === 'q' ? 'üîä Audio' : 'üì∫ Video'} verkn√ºpfen
                </label>
                <select id="cue-medium" onchange="toggleCueMediumNeu()">
                  <option value="">‚Äì Noch nicht vorhanden ‚Äì</option>
                  ${state.medien.filter(m => 
                    (selectedTyp === 'q' && m.type === 'audio') || 
                    (selectedTyp === 'v' && m.type === 'video')
                  ).map(m => `
                    <option value="${m.id}" ${c.mediumId === m.id ? 'selected' : ''}>${m.name}</option>
                  `).join('')}
                </select>
                <input type="text" id="cue-medium-geplant" class="mt-2 ${c.mediumId ? 'hidden' : ''}" 
                       placeholder="Geplanter Ton/Video (z.B. Waldger√§usche)" value="${c.mediumGeplant || ''}">
                <p class="text-xs text-gray-400 mt-1">Kann sp√§ter im Medien-Modul verkn√ºpft werden</p>
              </div>
              
              <!-- Umbau-Sektion -->
              <div id="cue-umbau-section" class="mt-4 ${selectedTyp === 'u' ? '' : 'hidden'}">
                <div class="grid grid-cols-2 gap-4 mb-3">
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">üé™ Von B√ºhnenbild</label>
                    <select id="cue-umbau-von">
                      <option value="">‚Äì w√§hlen ‚Äì</option>
                      ${state.buehne.map(b => `
                        <option value="${b.id}" ${c.umbauVon === b.id ? 'selected' : ''}>${b.name}</option>
                      `).join('')}
                    </select>
                  </div>
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">‚û°Ô∏è¬è Nach B√ºhnenbild</label>
                    <select id="cue-umbau-nach">
                      <option value="">‚Äì w√§hlen ‚Äì</option>
                      ${state.buehne.map(b => `
                        <option value="${b.id}" ${c.umbauNach === b.id ? 'selected' : ''}>${b.name}</option>
                      `).join('')}
                    </select>
                  </div>
                </div>
                
                <label class="block text-sm font-medium text-gray-700 mb-1">üìã Umbau-Aktionen</label>
                <div class="border rounded p-2 max-h-32 overflow-y-auto mb-2" id="umbau-aktionen-liste">
                  ${umbauAktionen.map((a, i) => `
                    <div class="flex items-center gap-2 mb-1">
                      <input type="text" class="umbau-aktion flex-1" value="${a}" placeholder="z.B. Zug 1 HOCH">
                      <button class="text-red-500 text-sm" onclick="removeUmbauAktion(${i})">‚úï</button>
                    </div>
                  `).join('')}
                </div>
                <button class="btn btn-xs btn-outline" onclick="addUmbauAktion()">+ Aktion hinzuf√ºgen</button>
                
                <!-- Requisiten AB/AUF -->
                <div class="grid grid-cols-2 gap-4 mt-3">
                  <div>
                    <label class="block text-sm font-medium text-red-600 mb-1">üî¥ Requisiten AB</label>
                    <div class="max-h-20 overflow-y-auto border rounded p-1">
                      ${state.requisiten.map(r => `
                        <label class="checkbox-item text-xs">
                          <input type="checkbox" class="umbau-req-ab" value="${r.id}" 
                                 ${c.requisitenAb?.includes(r.id) ? 'checked' : ''}>
                          ${r.name}
                        </label>
                      `).join('') || '<span class="text-xs text-gray-400">Keine Requisiten</span>'}
                    </div>
                  </div>
                  <div>
                    <label class="block text-sm font-medium text-green-600 mb-1">üü¢ Requisiten AUF</label>
                    <div class="max-h-20 overflow-y-auto border rounded p-1">
                      ${state.requisiten.map(r => `
                        <label class="checkbox-item text-xs">
                          <input type="checkbox" class="umbau-req-auf" value="${r.id}"
                                 ${c.requisitenAuf?.includes(r.id) ? 'checked' : ''}>
                          ${r.name}
                        </label>
                      `).join('') || '<span class="text-xs text-gray-400">Keine Requisiten</span>'}
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="mt-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Szene (vor dieser Szene)</label>
                <select id="cue-szene">
                  <option value="">‚Äì Szene w√§hlen ‚Äì</option>
                  ${state.szenen.map(s => `
                    <option value="${s.id}" ${c.szeneId === s.id ? 'selected' : ''}>${s.nummer} ${s.titel}</option>
                  `).join('')}
                </select>
              </div>
              
              <div class="mt-4 ${selectedTyp === 'u' ? 'hidden' : ''}" id="cue-beschreibung-section">
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea id="cue-beschreibung" rows="2" placeholder="Morgend√§mmerung - langsamer Fade up">${c.beschreibung || ''}</textarea>
              </div>
              
              <!-- NEU: Ankertext (Textposition) -->
              <div class="mt-4 ${selectedTyp === 'u' ? 'hidden' : ''}" id="cue-anker-section">
                <label class="block text-sm font-medium text-gray-700 mb-1">üîç Position im Text (Anker)</label>
                <div class="relative">
                  <input type="text" id="cue-ankertext" value="${escapeHtml(c.ankerText || '')}" 
                         placeholder="z.B. (Das Fenster wird ge√∂ffnet.) oder: Ich liebe dich."
                         class="pr-10">
                  <span class="absolute right-3 top-1/2 -translate-y-1/2 text-xs text-gray-400" title="Text im Textbuch markieren, dann Cue erstellen">‚ÑπÔ∏è¬è</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Der Cue wird an dieser Textstelle angezeigt. Tipp: Im Textbuch Text markieren, dann "Cue hier einf√ºgen" klicken.</p>
              </div>
              
              <div class="grid grid-cols-2 gap-4 mt-4 ${selectedTyp === 'u' ? 'hidden' : ''}" id="cue-trigger-section">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Ausl√∂ser</label>
                  <input type="text" id="cue-ausloeser" value="${c.ausloeser || ''}" placeholder="MARTHE tritt auf">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Dauer</label>
                  <input type="text" id="cue-dauer" value="${c.dauer || ''}" placeholder="5s">
                </div>
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteCue('${c.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showCueModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveCue()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Umbau-Aktionen dynamisch hinzuf√ºgen/entfernen
    function addUmbauAktion() {
      const liste = document.getElementById('umbau-aktionen-liste');
      const div = document.createElement('div');
      div.className = 'flex items-center gap-2 mb-1';
      div.innerHTML = `
        <input type="text" class="umbau-aktion flex-1" placeholder="z.B. Zug 1 HOCH">
        <button class="text-red-500 text-sm" onclick="this.parentElement.remove()">‚úï</button>
      `;
      liste.appendChild(div);
    }
    
    function removeUmbauAktion(index) {
      // Wird beim Laden des Modals verwendet
      if (state.editingCue?.umbauAktionen) {
        state.editingCue.umbauAktionen.splice(index, 1);
        render();
      }
    }
    
    function toggleCueRequisitenNeu() {
      const select = document.getElementById('cue-requisite');
      const neu = document.getElementById('cue-requisite-neu');
      if (select && neu) {
        neu.classList.toggle('hidden', select.value !== '');
      }
    }
    
    function toggleCueMediumNeu() {
      const select = document.getElementById('cue-medium');
      const neu = document.getElementById('cue-medium-geplant');
      if (select && neu) {
        neu.classList.toggle('hidden', select.value !== '');
      }
    }
    
    // UI-Update wenn Cue-Typ ge√§ndert wird
    function updateCueModalForTyp() {
      const typ = document.getElementById('cue-typ').value;
      const reqSection = document.getElementById('cue-requisite-section');
      const medSection = document.getElementById('cue-medium-section');
      const umbauSection = document.getElementById('cue-umbau-section');
      const beschreibungSection = document.getElementById('cue-beschreibung-section');
      const triggerSection = document.getElementById('cue-trigger-section');
      
      // Requisite-Sektion
      if (reqSection) {
        reqSection.classList.toggle('hidden', typ !== 'r');
      }
      
      // Medium-Sektion (Ton oder Video)
      if (medSection) {
        medSection.classList.toggle('hidden', typ !== 'q' && typ !== 'v');
        
        // Label aktualisieren
        const label = document.getElementById('cue-medium-label');
        if (label) {
          label.innerHTML = typ === 'q' ? 'üîä Audio verkn√ºpfen' : 'üì∫ Video verkn√ºpfen';
        }
        
        // Dropdown aktualisieren
        const select = document.getElementById('cue-medium');
        if (select) {
          const currentVal = select.value;
          select.innerHTML = `<option value="">‚Äì Noch nicht vorhanden ‚Äì</option>` +
            state.medien.filter(m => 
              (typ === 'q' && m.type === 'audio') || 
              (typ === 'v' && m.type === 'video')
            ).map(m => `<option value="${m.id}" ${currentVal === m.id ? 'selected' : ''}>${m.name}</option>`).join('');
        }
      }
      
      // Umbau-Sektion
      if (umbauSection) {
        umbauSection.classList.toggle('hidden', typ !== 'u');
      }
      
      // Beschreibung und Trigger f√ºr Umbau ausblenden
      if (beschreibungSection) {
        beschreibungSection.classList.toggle('hidden', typ === 'u');
      }
      if (triggerSection) {
        triggerSection.classList.toggle('hidden', typ === 'u');
      }
    }

    function renderSzeneModal() {
      const s = state.editingSzene || {};
      const isEdit = !!s.id;
      const aktuelleGruppen = getAktuelleGruppen();
      
      return `
        <div class="modal-overlay" onclick="closeModal('showSzeneModal')">
          <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Szene bearbeiten' : 'üé¨ Neue Szene'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showSzeneModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-4 gap-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Nummer</label>
                  <input type="text" id="szene-nummer" value="${s.nummer || ''}" placeholder="1.1">
                </div>
                <div class="col-span-2">
                  <label class="block text-sm font-medium text-gray-700 mb-1">Titel *</label>
                  <input type="text" id="szene-titel" value="${s.titel || ''}" placeholder="Prolog">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Akt/Teil</label>
                  <input type="text" list="szene-gruppe-list" id="szene-gruppe" value="${s.gruppe || aktuelleGruppen[0] || ''}" placeholder="Erster Akt">
                  <datalist id="szene-gruppe-list">
                    ${aktuelleGruppen.map(g => `<option value="${g}">`).join('')}
                  </datalist>
                </div>
              </div>
              <div class="grid grid-cols-2 gap-4 mt-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Ort</label>
                  <input type="text" id="szene-ort" value="${s.ort || ''}" placeholder="Marktplatz">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Zeit</label>
                  <input type="text" id="szene-zeit" value="${s.zeit || ''}" placeholder="Morgen">
                </div>
              </div>
              <div class="mt-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Zusammenfassung</label>
                <textarea id="szene-zusammenfassung" rows="3" placeholder="Was passiert in dieser Szene?">${s.zusammenfassung || ''}</textarea>
              </div>
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteSzene('${s.id}'); closeModal('showSzeneModal');">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showSzeneModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveSzene()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // v1.3: Kost√ºm-Modal mit Maske und Bildern
    function renderKostuemModal() {
      const k = state.editingKostuem || {};
      const isEdit = !!k.id;
      
      // Bilder-Arrays (mit Fallback f√ºr alte Daten)
      const kostuemBilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
      const maskeBilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
      
      return `
        <div class="modal-overlay" onclick="closeModal('showKostuemModal')">
          <div class="modal-content" style="max-width: 750px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Kost√ºm bearbeiten' : 'üëó Neues Kost√ºm'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showKostuemModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <!-- Name und Figur -->
              <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                  <input type="text" id="kostuem-name" value="${k.name || ''}" placeholder="Marthe - Grundkost√ºm">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Figur</label>
                  <select id="kostuem-figur">
                    <option value="">‚Äì Figur w√§hlen ‚Äì</option>
                    ${state.figuren.map(f => `
                      <option value="${f.id}" ${k.figur === f.id ? 'selected' : ''}>${f.name}</option>
                    `).join('')}
                  </select>
                </div>
              </div>
              
              <!-- Bilder: Kost√ºm (mehrere) -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">üëó Kost√ºm-Bilder</label>
                <div class="image-grid" id="kostuem-bilder-grid">
                  ${kostuemBilder.map((imgId, i) => `
                    <div class="relative">
                      <img src="${imageUrlCache[imgId] || ''}" class="image-thumb" id="kostuem-edit-img-${i}">
                      <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                              onclick="removeKostuemBildMulti('kostuem', ${i})">‚úï</button>
                    </div>
                  `).join('')}
                  <div class="add-image-btn" onclick="document.getElementById('kostuem-bilder-input').click()">+</div>
                </div>
                <input type="file" id="kostuem-bilder-input" accept="image/*" multiple class="hidden" onchange="addKostuemBilder(this, 'kostuem')">
              </div>
              
              <!-- Bilder: Maske (mehrere) -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">üé≠ Maske-Bilder</label>
                <div class="image-grid" id="maske-bilder-grid">
                  ${maskeBilder.map((imgId, i) => `
                    <div class="relative">
                      <img src="${imageUrlCache[imgId] || ''}" class="image-thumb" id="maske-edit-img-${i}">
                      <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                              onclick="removeKostuemBildMulti('maske', ${i})">‚úï</button>
                    </div>
                  `).join('')}
                  <div class="add-image-btn" onclick="document.getElementById('maske-bilder-input').click()">+</div>
                </div>
                <input type="file" id="maske-bilder-input" accept="image/*" multiple class="hidden" onchange="addKostuemBilder(this, 'maske')">
              </div>
              
              <!-- Beschreibung Kost√ºm -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">üëó Kost√ºm-Beschreibung</label>
                <textarea id="kostuem-beschreibung" rows="2" placeholder="Einfaches Leinenkleid, Sch√ºrze, Kopftuch">${k.beschreibung || ''}</textarea>
              </div>
              
              <!-- Beschreibung Maske -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">üé≠ Maske-Beschreibung</label>
                <textarea id="kostuem-maske" rows="2" placeholder="Graue Per√ºcke, blasse Schminke, Altersflecken">${k.maske || ''}</textarea>
              </div>
              
              <!-- Szenen -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Szenen</label>
                <div class="max-h-24 overflow-y-auto border rounded p-2">
                  ${state.szenen.length === 0 ? '<span class="text-xs text-gray-400">Keine Szenen vorhanden</span>' : 
                    state.szenen.map(s => `
                    <label class="checkbox-item">
                      <input type="checkbox" class="kostuem-szene-check" value="${s.id}" 
                             ${k.szenen?.includes(s.id) ? 'checked' : ''}>
                      <span class="text-sm">${s.nummer} ${s.titel}</span>
                    </label>
                  `).join('')}
                </div>
              </div>
              
              <!-- Notizen -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Notizen</label>
                <input type="text" id="kostuem-notizen" value="${k.notizen || ''}" placeholder="Muss verstaubt aussehen">
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteKostuem('${k.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showKostuemModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveKostuem()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Tempor√§re Speicher f√ºr neue Bilder im Kost√ºm-Modal
    let pendingKostuemBilder = [];
    let pendingMaskeBilder = [];
    
    function addKostuemBilder(input, type) {
      const files = Array.from(input.files);
      const pending = type === 'kostuem' ? pendingKostuemBilder : pendingMaskeBilder;
      const gridId = type === 'kostuem' ? 'kostuem-bilder-grid' : 'maske-bilder-grid';
      
      files.forEach(file => {
        pending.push(file);
        const reader = new FileReader();
        reader.onload = (e) => {
          const grid = document.getElementById(gridId);
          const addBtn = grid.querySelector('.add-image-btn');
          const div = document.createElement('div');
          div.className = 'relative';
          const idx = pending.length - 1;
          div.innerHTML = `
            <img src="${e.target.result}" class="image-thumb">
            <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                    onclick="this.parentElement.remove();">‚úï</button>
          `;
          grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
      });
      input.value = '';
    }
    
    function removeKostuemBildMulti(type, index) {
      const bilder = type === 'kostuem' 
        ? (state.editingKostuem.kostuemBilder || [])
        : (state.editingKostuem.maskeBilder || []);
      
      if (bilder[index]) {
        const imgId = bilder[index];
        bilder.splice(index, 1);
        deleteImageFromDB(imgId);
        
        if (type === 'kostuem') {
          state.editingKostuem.kostuemBilder = bilder;
        } else {
          state.editingKostuem.maskeBilder = bilder;
        }
        render();
      }
    }

    // ============================================
    // B√úHNE MODAL (v1.3)
    // ============================================
    let pendingBuehneImages = [];
    
    function renderBuehneModal() {
      const b = state.editingBuehne || {};
      const isEdit = !!b.id;
      
      return `
        <div class="modal-overlay" onclick="closeModal('showBuehneModal')">
          <div class="modal-content" style="max-width: 700px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è B√ºhnenelement bearbeiten' : 'üé™ Neues B√ºhnenelement'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showBuehneModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                  <input type="text" id="buehne-name" value="${b.name || ''}" placeholder="Grundriss Akt 1">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Kategorie</label>
                  <select id="buehne-kategorie">
                    <option value="Grundriss" ${b.kategorie === 'Grundriss' ? 'selected' : ''}>Grundriss</option>
                    <option value="Skizze" ${b.kategorie === 'Skizze' ? 'selected' : ''}>Skizze</option>
                    <option value="Foto" ${b.kategorie === 'Foto' ? 'selected' : ''}>Foto</option>
                    <option value="Technischer Plan" ${b.kategorie === 'Technischer Plan' ? 'selected' : ''}>Technischer Plan</option>
                    <option value="Referenz" ${b.kategorie === 'Referenz' ? 'selected' : ''}>Referenz</option>
                    <option value="Sonstiges" ${b.kategorie === 'Sonstiges' || !b.kategorie ? 'selected' : ''}>Sonstiges</option>
                  </select>
                </div>
              </div>
              
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea id="buehne-beschreibung" rows="2" placeholder="Beschreibung des Elements">${b.beschreibung || ''}</textarea>
              </div>
              
              <!-- Bilder -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Bilder</label>
                <div class="image-grid" id="buehne-bilder-grid">
                  ${(b.bilder || []).map((imgId, i) => `
                    <div class="relative">
                      <img src="${imageUrlCache[imgId] || ''}" class="image-thumb" id="buehne-edit-img-${i}">
                      <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                              onclick="removeBuehneImage(${i})">‚úï</button>
                    </div>
                  `).join('')}
                  <div class="add-image-btn" onclick="document.getElementById('buehne-image-input').click()">+</div>
                </div>
                <input type="file" id="buehne-image-input" accept="image/*" multiple class="hidden" onchange="addBuehneImages(this)">
              </div>
              
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Notizen</label>
                <input type="text" id="buehne-notizen" value="${b.notizen || ''}" placeholder="Zus√§tzliche Hinweise">
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteBuehne('${b.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showBuehneModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveBuehne()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    function addBuehneImages(input) {
      const files = Array.from(input.files);
      files.forEach(file => {
        pendingBuehneImages.push(file);
        const reader = new FileReader();
        reader.onload = (e) => {
          const grid = document.getElementById('buehne-bilder-grid');
          const addBtn = grid.querySelector('.add-image-btn');
          const div = document.createElement('div');
          div.className = 'relative';
          div.innerHTML = `
            <img src="${e.target.result}" class="image-thumb">
            <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                    onclick="this.parentElement.remove(); pendingBuehneImages.pop();">‚úï</button>
          `;
          grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
      });
      input.value = '';
    }
    
    function removeBuehneImage(index) {
      if (state.editingBuehne?.bilder) {
        const imgId = state.editingBuehne.bilder[index];
        state.editingBuehne.bilder.splice(index, 1);
        if (imgId) deleteImageFromDB(imgId);
        render();
      }
    }

    // ============================================
    // REQUISITEN MODAL (v1.3)
    // ============================================
    let pendingRequisitenImages = [];
    
    function renderRequisitenModal() {
      const r = state.editingRequisit || {};
      const isEdit = !!r.id;
      
      return `
        <div class="modal-overlay" onclick="closeModal('showRequisitenModal')">
          <div class="modal-content" style="max-width: 700px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Requisite bearbeiten' : 'üé≠ Neue Requisite'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showRequisitenModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                  <input type="text" id="requisit-name" value="${r.name || ''}" placeholder="Weinglas">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Zust√§ndig</label>
                  <input type="text" id="requisit-zustaendig" value="${r.zustaendig || ''}" placeholder="Name der zust√§ndigen Person">
                </div>
              </div>
              
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea id="requisit-beschreibung" rows="2" placeholder="Kristallglas, muss zerbrechlich aussehen">${r.beschreibung || ''}</textarea>
              </div>
              
              <!-- Szenen -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Szenen</label>
                <div class="max-h-24 overflow-y-auto border rounded p-2">
                  ${state.szenen.length === 0 ? '<span class="text-xs text-gray-400">Keine Szenen vorhanden</span>' : 
                    state.szenen.map(s => `
                    <label class="checkbox-item">
                      <input type="checkbox" class="requisit-szene-check" value="${s.id}" 
                             ${r.szenen?.includes(s.id) ? 'checked' : ''}>
                      <span class="text-sm">${s.nummer} ${s.titel}</span>
                    </label>
                  `).join('')}
                </div>
              </div>
              
              <!-- Bilder -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Bilder</label>
                <div class="image-grid" id="requisit-bilder-grid">
                  ${(r.bilder || []).map((imgId, i) => `
                    <div class="relative">
                      <img src="${imageUrlCache[imgId] || ''}" class="image-thumb" id="requisit-edit-img-${i}">
                      <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                              onclick="removeRequisitenImage(${i})">‚úï</button>
                    </div>
                  `).join('')}
                  <div class="add-image-btn" onclick="document.getElementById('requisit-image-input').click()">+</div>
                </div>
                <input type="file" id="requisit-image-input" accept="image/*" multiple class="hidden" onchange="addRequisitenImages(this)">
              </div>
              
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Notizen</label>
                <input type="text" id="requisit-notizen" value="${r.notizen || ''}" placeholder="Zus√§tzliche Hinweise">
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteRequisit('${r.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showRequisitenModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveRequisit()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    function addRequisitenImages(input) {
      const files = Array.from(input.files);
      files.forEach(file => {
        pendingRequisitenImages.push(file);
        const reader = new FileReader();
        reader.onload = (e) => {
          const grid = document.getElementById('requisit-bilder-grid');
          const addBtn = grid.querySelector('.add-image-btn');
          const div = document.createElement('div');
          div.className = 'relative';
          div.innerHTML = `
            <img src="${e.target.result}" class="image-thumb">
            <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                    onclick="this.parentElement.remove(); pendingRequisitenImages.pop();">‚úï</button>
          `;
          grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
      });
      input.value = '';
    }
    
    function removeRequisitenImage(index) {
      if (state.editingRequisit?.bilder) {
        const imgId = state.editingRequisit.bilder[index];
        state.editingRequisit.bilder.splice(index, 1);
        if (imgId) deleteImageFromDB(imgId);
        render();
      }
    }

    // ============================================
    // ACTION HANDLERS
    // ============================================
    function navigateTo(view) {
      // Vor dem View-Wechsel aktuellen Text speichern
      saveCurrentText();
      state.currentView = view;
      render();
    }

    function selectSzene(szeneId) {
      state.aktiveSzene = szeneId;
      state.undoStack = [];
      state.redoStack = [];
      render();
    }

    // v2.0: Szene frei verschieben (√ºber alle Akte/Gruppen hinweg)
    function moveSzene(szeneId, direction) {
      const idx = state.szenen.findIndex(s => s.id === szeneId);
      if (idx === -1) return;
      
      const newIdx = idx + direction;
      if (newIdx < 0 || newIdx >= state.szenen.length) return;
      
      // Einfach Array-Position tauschen (keine Nummern-√Ñnderung)
      const temp = state.szenen[idx];
      state.szenen[idx] = state.szenen[newIdx];
      state.szenen[newIdx] = temp;
      
      saveProjektDaten();
      render();
    }

    function updateSzene(szeneId, field, value) {
      const szene = state.szenen.find(s => s.id === szeneId);
      if (szene) {
        szene[field] = value;
        saveProjektDaten();
        render();
      }
    }

    function toggleFigurInSzene(szeneId, figurId, checked) {
      const szene = state.szenen.find(s => s.id === szeneId);
      if (!szene) return;
      
      if (!szene.figuren) szene.figuren = [];
      
      if (checked && !szene.figuren.includes(figurId)) {
        szene.figuren.push(figurId);
      } else if (!checked) {
        szene.figuren = szene.figuren.filter(id => id !== figurId);
      }
      
      saveProjektDaten();
      render();
    }

    function toggleGestrichenes(show) {
      state.showGestrichenes = show;
      render();
    }

    function applySelectedFormat() {
      const select = document.getElementById('format-select');
      if (select) {
        state.selectedFormat = select.value;
        applyFormat(state.selectedFormat);
      }
    }

    // Modal Handlers
    function openModal(modalName) {
      state[modalName] = true;
      render();
    }

    function closeModal(modalName) {
      state[modalName] = false;
      state.editingFigur = null;
      state.editingCue = null;
      state.editingSzene = null;
      state.editingKostuem = null;
      state.editingMedium = null;
      render();
    }

    function openFigurModal(figurId = null) {
      if (figurId) {
        state.editingFigur = { ...state.figuren.find(f => f.id === figurId) };
      } else {
        state.editingFigur = { name: '', kuerzel: '', beschreibung: '', want: '', need: '', wunde: '', geheimnis: '' };
      }
      state.showFigurModal = true;
      render();
    }

    function editFigur(figurId) {
      openFigurModal(figurId);
    }

    function saveFigur() {
      const name = document.getElementById('figur-name').value.trim().toUpperCase();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      
      const data = {
        name: name,
        kuerzel: document.getElementById('figur-kuerzel').value.trim().toUpperCase() || name.substring(0, 2),
        beschreibung: document.getElementById('figur-beschreibung').value.trim(),
        want: document.getElementById('figur-want').value.trim(),
        need: document.getElementById('figur-need').value.trim(),
        wunde: document.getElementById('figur-wunde').value.trim(),
        geheimnis: document.getElementById('figur-geheimnis').value.trim(),
      };
      
      if (state.editingFigur?.id) {
        // Update
        const idx = state.figuren.findIndex(f => f.id === state.editingFigur.id);
        if (idx !== -1) {
          state.figuren[idx] = { ...state.figuren[idx], ...data };
        }
      } else {
        // Create
        state.figuren.push({ id: genId(), ...data });
      }
      
      saveProjektDaten();
      closeModal('showFigurModal');
    }

    function deleteFigur(figurId) {
      if (!confirm('Figur wirklich l√∂schen?')) return;
      state.figuren = state.figuren.filter(f => f.id !== figurId);
      // Auch aus Szenen entfernen
      state.szenen.forEach(s => {
        if (s.figuren) {
          s.figuren = s.figuren.filter(id => id !== figurId);
        }
      });
      saveProjektDaten();
      closeModal('showFigurModal');
    }

    function openCueModal(typ = 'lx') {
      state.editingCue = { typ: typ, nummer: '', beschreibung: '', szeneId: state.aktiveSzene, ausloeser: '', dauer: '', ankerText: '' };
      state.showCueModal = true;
      render();
      // Nach Render das Typ-Handling aktivieren
      setTimeout(updateCueModalForTyp, 50);
    }

    function editCue(cueId) {
      const cue = state.cues.find(c => c.id === cueId);
      if (cue) {
        state.editingCue = { ...cue };
        state.showCueModal = true;
        render();
        setTimeout(updateCueModalForTyp, 50);
      }
    }

    // NEU: Cue erstellen mit markiertem Text als Anker
    function createCueFromSelection(typ = 'lx') {
      const selection = window.getSelection();
      let ankerText = '';
      
      if (selection && selection.toString().trim()) {
        ankerText = selection.toString().trim();
        // Auf max 200 Zeichen begrenzen
        if (ankerText.length > 200) {
          ankerText = ankerText.substring(0, 200) + '...';
        }
      }
      
      if (!ankerText) {
        alert('Bitte zuerst einen Text im Textbuch markieren.\n\nDieser Text wird als Positions-Anker f√ºr den Cue verwendet.');
        return;
      }
      
      state.editingCue = { 
        typ: typ, 
        nummer: '', 
        beschreibung: '', 
        szeneId: state.aktiveSzene, 
        ausloeser: '', 
        dauer: '', 
        ankerText: ankerText 
      };
      state.showCueModal = true;
      render();
      setTimeout(updateCueModalForTyp, 50);
    }

    function saveCue() {
      const typ = document.getElementById('cue-typ').value;
      const nummer = parseInt(document.getElementById('cue-nummer').value) || 1;
      const szeneId = document.getElementById('cue-szene').value;
      
      let requisitenId = null;
      let mediumId = null;
      let mediumGeplant = null;
      
      // Bei Requisiten-Cue: Verkn√ºpfung oder neue Requisite
      if (typ === 'r') {
        const reqSelect = document.getElementById('cue-requisite');
        const reqNeu = document.getElementById('cue-requisite-neu');
        
        if (reqSelect?.value) {
          // Bestehende Requisite verkn√ºpfen
          requisitenId = reqSelect.value;
          // Szene zur Requisite hinzuf√ºgen falls nicht vorhanden
          if (szeneId) {
            const req = state.requisiten.find(r => r.id === requisitenId);
            if (req && !req.szenen?.includes(szeneId)) {
              if (!req.szenen) req.szenen = [];
              req.szenen.push(szeneId);
            }
          }
        } else if (reqNeu?.value.trim()) {
          // Neue Requisite erstellen
          const neueRequisite = {
            id: genId(),
            name: reqNeu.value.trim(),
            beschreibung: '',
            zustaendig: '',
            szenen: szeneId ? [szeneId] : [],
            bilder: [],
            notizen: '',
            erstelltVonCue: true
          };
          state.requisiten.push(neueRequisite);
          requisitenId = neueRequisite.id;
        }
      }
      
      // Bei Ton/Video-Cue: Medium verkn√ºpfen oder geplanten Namen speichern
      if (typ === 'q' || typ === 'v') {
        const medSelect = document.getElementById('cue-medium');
        const medGeplant = document.getElementById('cue-medium-geplant');
        
        if (medSelect?.value) {
          mediumId = medSelect.value;
          // Szene zum Medium hinzuf√ºgen
          if (szeneId) {
            const med = state.medien.find(m => m.id === mediumId);
            if (med && !med.szenen?.includes(szeneId)) {
              if (!med.szenen) med.szenen = [];
              med.szenen.push(szeneId);
            }
          }
        } else if (medGeplant?.value.trim()) {
          // Geplanter Ton/Video noch nicht importiert
          mediumGeplant = medGeplant.value.trim();
        }
      }
      
      // Basis-Daten
      const data = {
        typ,
        nummer,
        szeneId,
        beschreibung: document.getElementById('cue-beschreibung')?.value.trim() || '',
        ausloeser: document.getElementById('cue-ausloeser')?.value.trim() || '',
        dauer: document.getElementById('cue-dauer')?.value.trim() || '',
        ankerText: document.getElementById('cue-ankertext')?.value.trim() || '', // NEU
        requisitenId,
        mediumId,
        mediumGeplant,
      };
      
      // Umbau-spezifische Daten
      if (typ === 'u') {
        data.umbauVon = document.getElementById('cue-umbau-von')?.value || null;
        data.umbauNach = document.getElementById('cue-umbau-nach')?.value || null;
        
        // Umbau-Aktionen sammeln
        const aktionInputs = document.querySelectorAll('.umbau-aktion');
        data.umbauAktionen = Array.from(aktionInputs)
          .map(input => input.value.trim())
          .filter(v => v);
        
        // Requisiten AB/AUF
        const reqAbChecks = document.querySelectorAll('.umbau-req-ab:checked');
        const reqAufChecks = document.querySelectorAll('.umbau-req-auf:checked');
        data.requisitenAb = Array.from(reqAbChecks).map(cb => cb.value);
        data.requisitenAuf = Array.from(reqAufChecks).map(cb => cb.value);
        
        // Beschreibung automatisch generieren
        const vonName = state.buehne.find(b => b.id === data.umbauVon)?.name || '';
        const nachName = state.buehne.find(b => b.id === data.umbauNach)?.name || '';
        data.beschreibung = vonName && nachName ? `${vonName} ‚Üí ${nachName}` : 'Umbau';
      }
      
      if (state.editingCue?.id && state.cues.find(c => c.id === state.editingCue.id)) {
        // Update
        const idx = state.cues.findIndex(c => c.id === state.editingCue.id);
        if (idx !== -1) {
          state.cues[idx] = { ...state.cues[idx], ...data };
        }
      } else {
        // Create
        state.cues.push({ id: genId(), ...data });
      }
      
      saveProjektDaten();
      closeModal('showCueModal');
    }

    function deleteCue(cueId) {
      if (!confirm('Cue wirklich l√∂schen?')) return;
      
      const cue = state.cues.find(c => c.id === cueId);
      
      // Bei Requisiten-Cue: Szene von Requisite entfernen
      if (cue?.requisitenId && cue.szeneId) {
        const req = state.requisiten.find(r => r.id === cue.requisitenId);
        if (req?.szenen) {
          req.szenen = req.szenen.filter(s => s !== cue.szeneId);
        }
      }
      
      // Bei Medien-Cue: Szene von Medium entfernen  
      if (cue?.mediumId && cue.szeneId) {
        const med = state.medien.find(m => m.id === cue.mediumId);
        if (med?.szenen) {
          med.szenen = med.szenen.filter(s => s !== cue.szeneId);
        }
      }
      
      state.cues = state.cues.filter(c => c.id !== cueId);
      saveProjektDaten();
      closeModal('showCueModal');
    }

    function openSzeneModal(szeneId = null) {
      if (szeneId) {
        state.editingSzene = { ...state.szenen.find(s => s.id === szeneId) };
      } else {
        const lastNr = state.szenen.length > 0 
          ? state.szenen[state.szenen.length - 1].nummer 
          : '0.0';
        const [akt, szene] = lastNr.split('.').map(Number);
        const newNr = szene >= 5 ? `${akt + 1}.1` : `${akt}.${szene + 1}`;
        // Letzte Gruppe √ºbernehmen
        const lastGruppe = state.szenen.length > 0 
          ? state.szenen[state.szenen.length - 1].gruppe || '1'
          : '1';
        state.editingSzene = { nummer: newNr, titel: '', ort: '', zeit: '', figuren: [], zusammenfassung: '', gruppe: lastGruppe };
      }
      state.showSzeneModal = true;
      render();
    }
    
    // Alias f√ºr Konsistenz mit anderen edit-Funktionen
    function editSzene(szeneId) {
      openSzeneModal(szeneId);
    }

    function saveSzene() {
      const titel = document.getElementById('szene-titel').value.trim();
      if (!titel) {
        alert('Bitte einen Titel eingeben.');
        return;
      }
      
      const data = {
        nummer: document.getElementById('szene-nummer').value.trim() || '1.1',
        titel: titel,
        ort: document.getElementById('szene-ort').value.trim(),
        zeit: document.getElementById('szene-zeit').value.trim(),
        zusammenfassung: document.getElementById('szene-zusammenfassung')?.value.trim() || '',
        gruppe: document.getElementById('szene-gruppe')?.value || '1',
      };
      
      if (state.editingSzene?.id) {
        // Update
        const idx = state.szenen.findIndex(s => s.id === state.editingSzene.id);
        if (idx !== -1) {
          state.szenen[idx] = { ...state.szenen[idx], ...data };
        }
      } else {
        // Create
        const newSzene = { id: genId(), ...data, figuren: [] };
        state.szenen.push(newSzene);
        state.aktiveSzene = newSzene.id;
      }
      
      saveProjektDaten();
      closeModal('showSzeneModal');
    }

    function deleteSzene(szeneId) {
      if (!confirm('Szene wirklich l√∂schen? Der Text wird auch gel√∂scht!')) return;
      state.szenen = state.szenen.filter(s => s.id !== szeneId);
      delete state.textbuch[szeneId];
      state.cues = state.cues.filter(c => c.szeneId !== szeneId);
      if (state.aktiveSzene === szeneId) {
        state.aktiveSzene = state.szenen[0]?.id || null;
      }
      saveProjektDaten();
      render();
    }
    
    // NEU v1.4: Formatierung bereinigen (Word-Styles entfernen)
    function cleanupFormatting() {
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) {
        alert('Bitte zuerst eine Szene ausw√§hlen.');
        return;
      }
      
      if (!confirm('Formatierung bereinigen?\n\nDies entfernt alle Word-Styles (Schriftgr√∂√üen, Farben, etc.) und beh√§lt nur die Regiebuch-Formatvorlagen.')) {
        return;
      }
      
      // Undo speichern
      pushUndo();
      
      // HTML des Editors holen
      let html = editor.innerHTML;
      
      // 1. Alle style-Attribute entfernen
      html = html.replace(/\s*style="[^"]*"/gi, '');
      
      // 2. Alle class-Attribute entfernen die NICHT unsere Format-Klassen sind
      // Aber format-* Klassen behalten
      html = html.replace(/\s*class="(?!format-|figur-name|dialog-text|cue-marker|cue-badge)[^"]*"/gi, '');
      
      // 3. Leere spans entfernen: <span>text</span> ‚Üí text
      html = html.replace(/<span>([^<]*)<\/span>/gi, '$1');
      
      // 4. Word-spezifische Tags entfernen
      html = html.replace(/<\/?o:[^>]*>/gi, ''); // Office namespace
      html = html.replace(/<\/?w:[^>]*>/gi, '');
      html = html.replace(/<\/?m:[^>]*>/gi, '');
      
      // 5. Verschachtelte b/strong und i/em vereinfachen
      html = html.replace(/<(b|strong)>\s*<(b|strong)>/gi, '<strong>');
      html = html.replace(/<\/(b|strong)>\s*<\/(b|strong)>/gi, '</strong>');
      html = html.replace(/<(i|em)>\s*<(i|em)>/gi, '<em>');
      html = html.replace(/<\/(i|em)>\s*<\/(i|em)>/gi, '</em>');
      
      // 6. font-Tags entfernen
      html = html.replace(/<font[^>]*>([^<]*)<\/font>/gi, '$1');
      
      // 7. Normale Abs√§tze ohne Klasse bekommen format-standard
      html = html.replace(/<p>(?!<)/gi, '<p class="format-standard">');
      
      // Zur√ºck in Editor
      editor.innerHTML = html;
      saveCurrentText();
      
      alert('‚úÖ Formatierung bereinigt!\n\nAlle Word-Styles wurden entfernt.');
    }
    
    // v1.4: Akt-Titel formatieren (erstellt nur neue Szene wenn Text davor)
    function createActFromTitle(titelText, sourceNode) {
      if (!state.aktiveSzene) return;
      
      const aktuelleSzene = state.szenen.find(s => s.id === state.aktiveSzene);
      if (!aktuelleSzene) return;
      
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Finde das Akt-Titel Element im Editor
      const aktTitelElemente = editor.querySelectorAll('.format-akt-titel');
      let aktTitelElement = null;
      for (const el of aktTitelElemente) {
        if (el.textContent.includes(titelText) || el.textContent === titelText) {
          aktTitelElement = el;
          break;
        }
      }
      
      if (!aktTitelElement) return;
      
      // Pr√ºfen ob "echter" Text VOR dem Akt-Titel existiert
      let hatEchtenTextDavor = false;
      let prevEl = aktTitelElement.previousElementSibling;
      while (prevEl) {
        const text = prevEl.textContent.trim();
        const isEmpty = !text || text === '' || prevEl.innerHTML === '<br>';
        
        if (!isEmpty) {
          hatEchtenTextDavor = true;
          break;
        }
        prevEl = prevEl.previousElementSibling;
      }
      
      // Akt-Nummer aus Text extrahieren
      let neueGruppe = '1';
      const aktMatch = titelText.match(/^(\d+)\.\s*AKT/i);
      if (aktMatch) {
        neueGruppe = aktMatch[1];
      } else {
        const existingGroups = [...new Set(state.szenen.map(s => s.gruppe || '1'))];
        const maxGroup = Math.max(...existingGroups.map(g => parseInt(g) || 1));
        neueGruppe = String(maxGroup + 1);
      }
      
      // FALL 1: Kein Text davor ‚Üí Nur Gruppe der aktuellen Szene √§ndern
      if (!hatEchtenTextDavor) {
        aktuelleSzene.gruppe = neueGruppe;
        aktuelleSzene.nummer = neueGruppe + '.' + (aktuelleSzene.nummer.split('.')[1] || '1');
        sortSzenen();
        saveProjektDaten();
        render();
        // Keine Meldung - einfach weiterarbeiten
        return;
      }
      
      // FALL 2: Text davor ‚Üí Neue Szene erstellen
      // Alle Elemente AB dem Akt-Titel sammeln (inklusive Akt-Titel)
      const elementsToMove = [aktTitelElement.outerHTML];
      let currentEl = aktTitelElement.nextElementSibling;
      while (currentEl) {
        elementsToMove.push(currentEl.outerHTML);
        currentEl = currentEl.nextElementSibling;
      }
      
      // Elemente AB dem Akt-Titel entfernen
      currentEl = aktTitelElement;
      while (currentEl) {
        const next = currentEl.nextElementSibling;
        currentEl.remove();
        currentEl = next;
      }
      
      // Aktuelle Szene speichern
      const alteSzeneContent = editor.innerHTML;
      state.textbuch[state.aktiveSzene] = alteSzeneContent;
      saveProjektDaten();
      
      // Neue Szene im neuen Akt erstellen
      const neueSzeneId = genId();
      const neueSzene = {
        id: neueSzeneId,
        nummer: neueGruppe + '.1',
        titel: 'Neue Szene',
        gruppe: neueGruppe,
        ort: '',
        zeit: '',
        zusammenfassung: '',
        figuren: []
      };
      
      state.szenen.push(neueSzene);
      state.textbuch[neueSzeneId] = elementsToMove.join('\n') || '<p class="format-standard"><br></p>';
      
      sortSzenen();
      saveProjektDaten();
      
      const szeneInfo = neueSzene.nummer;
      
      // Warten bis alles fertig ist, dann Szene wechseln
      setTimeout(() => {
        selectSzene(neueSzeneId);
        setTimeout(() => {
          alert(`‚úÖ Neuer Akt erstellt!\n\nSzene ${szeneInfo} wurde angelegt.\nMarkiere jetzt den Szenen-Titel um die Szene zu benennen.`);
        }, 100);
      }, 200);
    }
    
    // v1.4: Neue Szene aus Szenen-Titel erstellen
    function createSceneFromTitle(titelText, sourceNode) {
      if (!state.aktiveSzene) return;
      
      const aktuelleSzene = state.szenen.find(s => s.id === state.aktiveSzene);
      if (!aktuelleSzene) return;
      
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Nummer aus Text extrahieren (z.B. "1.2 Prolog" ‚Üí "1.2")
      const nummerMatch = titelText.match(/^(\d+\.?\d*)\s*[-‚Äì]?\s*/);
      let nummer = '';
      let titel = titelText;
      
      if (nummerMatch) {
        let extractedNum = nummerMatch[1];
        if (!extractedNum.includes('.')) {
          extractedNum = aktuelleSzene.gruppe + '.' + extractedNum;
        }
        nummer = extractedNum;
        titel = titelText.substring(nummerMatch[0].length).trim();
        titel = titel.replace(/^[-‚Äì]\s*/, '');
      } else {
        titel = titelText;
      }
      
      // Finde das Szenen-Titel Element im Editor
      const szeneTitelElemente = editor.querySelectorAll('.format-szene-titel');
      let szeneTitelElement = null;
      for (const el of szeneTitelElemente) {
        if (el.textContent.includes(titel) || el.textContent.includes(titelText) || el.textContent === titelText) {
          szeneTitelElement = el;
          break;
        }
      }
      
      if (!szeneTitelElement) return;
      
      // Pr√ºfen ob NUR Akt-Titel oder leere Elemente VOR dem Szenen-Titel sind
      // In diesem Fall: Nur die aktuelle Szene umbenennen, KEINE neue Szene
      let hatEchtenTextDavor = false;
      let prevEl = szeneTitelElement.previousElementSibling;
      while (prevEl) {
        const text = prevEl.textContent.trim();
        const isAktTitel = prevEl.classList.contains('format-akt-titel');
        const isSzeneTitel = prevEl.classList.contains('format-szene-titel');
        const isEmpty = !text || text === '' || prevEl.innerHTML.replace(/<br\s*\/?>/gi, '').trim() === '';
        
        // Wenn ein anderer Szenen-Titel davor ist, ist das "echter Text"
        if (isSzeneTitel) {
          hatEchtenTextDavor = true;
          break;
        }
        
        // Akt-Titel und leere Elemente √ºberspringen
        if (!isAktTitel && !isEmpty) {
          hatEchtenTextDavor = true;
          break;
        }
        prevEl = prevEl.previousElementSibling;
      }
      
      // FALL 1: Kein echter Text davor (direkt nach Akt-Titel oder am Anfang)
      // ‚Üí Nur den Titel der aktuellen Szene √§ndern, KEINE neue Szene
      if (!hatEchtenTextDavor) {
        if (!titel) titel = titelText.replace(/^\d+\.?\d*\s*[-‚Äì]?\s*/, '').trim();
        
        // Aktuelle Szene umbenennen
        aktuelleSzene.titel = titel;
        
        // Nummer anpassen wenn extrahiert
        if (nummer && nummer !== aktuelleSzene.nummer) {
          aktuelleSzene.nummer = nummer;
        }
        
        sortSzenen();
        saveProjektDaten();
        render();
        
        // Keine Meldung, da keine neue Szene erstellt wurde
        return;
      }
      
      // FALL 2: Echter Text davor ‚Üí Neue Szene erstellen
      if (!nummer) {
        const gruppe = aktuelleSzene.gruppe || '1';
        const szenenInGruppe = state.szenen
          .filter(s => s.gruppe === gruppe)
          .sort((a, b) => parseFloat(a.nummer) - parseFloat(b.nummer));
        
        // H√∂chste Szenen-Nummer in dieser Gruppe finden
        let maxSubNummer = 0;
        szenenInGruppe.forEach(s => {
          const parts = s.nummer.split('.');
          if (parts.length > 1) {
            const sub = parseInt(parts[1]) || 0;
            if (sub > maxSubNummer) maxSubNummer = sub;
          }
        });
        
        nummer = gruppe + '.' + (maxSubNummer + 1);
      }
      
      if (!titel) titel = titelText;
      
      // Fragen ob neue Szene erstellt werden soll
      const confirmMsg = `üìÑ Neue Szene aus Titel erstellen?\n\n` +
        `Aktuelle Szene: ${aktuelleSzene.nummer} ${aktuelleSzene.titel}\n` +
        `Neue Szene: ${nummer} "${titel}"\n\n` +
        `Was passiert:\n` +
        `‚Ä¢ Text VOR diesem Titel ‚Üí bleibt in Szene ${aktuelleSzene.nummer}\n` +
        `‚Ä¢ Text AB diesem Titel ‚Üí wird zu Szene ${nummer}\n\n` +
        `Fortfahren?`;
      
      if (!confirm(confirmMsg)) {
        return;
      }
      
      // Alle Elemente AB dem Szenen-Titel sammeln (inklusive Titel)
      const elementsToMove = [szeneTitelElement.outerHTML];
      let currentEl = szeneTitelElement.nextElementSibling;
      while (currentEl) {
        elementsToMove.push(currentEl.outerHTML);
        currentEl = currentEl.nextElementSibling;
      }
      
      // Elemente AB dem Szenen-Titel entfernen
      currentEl = szeneTitelElement;
      while (currentEl) {
        const next = currentEl.nextElementSibling;
        currentEl.remove();
        currentEl = next;
      }
      
      // Aktuelle Szene speichern
      const alteSzeneContent = editor.innerHTML;
      state.textbuch[state.aktiveSzene] = alteSzeneContent;
      saveProjektDaten();
      
      // Neue Szene erstellen
      const neueSzeneId = genId();
      const neueSzene = {
        id: neueSzeneId,
        nummer: nummer,
        titel: titel,
        gruppe: aktuelleSzene.gruppe || '1',
        ort: '',
        zeit: '',
        zusammenfassung: '',
        figuren: aktuelleSzene.figuren || []
      };
      
      state.szenen.push(neueSzene);
      state.textbuch[neueSzeneId] = elementsToMove.join('\n') || '<p class="format-standard"><br></p>';
      
      sortSzenen();
      saveProjektDaten();
      
      const neueNummer = nummer;
      const neuerTitel = titel;
      
      // Warten bis confirm-Dialog komplett weg ist, dann Szene wechseln
      setTimeout(() => {
        selectSzene(neueSzeneId);
        setTimeout(() => {
          alert(`‚úÖ Neue Szene ${neueNummer} "${neuerTitel}" erstellt!`);
        }, 100);
      }, 200);
    }
    
    // NEU v1.4: Szene an Cursor-Position teilen
    function splitSzeneAtCursor() {
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) {
        alert('Bitte zuerst eine Szene ausw√§hlen.');
        return;
      }
      
      const selection = window.getSelection();
      if (!selection.rangeCount) {
        alert('Bitte den Cursor an die Stelle setzen, wo die neue Szene beginnen soll.');
        return;
      }
      
      const range = selection.getRangeAt(0);
      
      // Pr√ºfen ob Cursor im Editor ist
      if (!editor.contains(range.startContainer)) {
        alert('Bitte den Cursor im Text platzieren, wo geteilt werden soll.');
        return;
      }
      
      // Aktuelle Szene finden
      const aktuelleSzene = state.szenen.find(s => s.id === state.aktiveSzene);
      if (!aktuelleSzene) return;
      
      // Text vor dem Cursor (bleibt in aktueller Szene)
      const rangeVor = document.createRange();
      rangeVor.setStart(editor, 0);
      rangeVor.setEnd(range.startContainer, range.startOffset);
      
      const tempDivVor = document.createElement('div');
      tempDivVor.appendChild(rangeVor.cloneContents());
      const textVor = stripCueMarkers(tempDivVor.innerHTML);
      
      // Text nach dem Cursor (wird neue Szene)
      const rangeNach = document.createRange();
      rangeNach.setStart(range.startContainer, range.startOffset);
      rangeNach.setEndAfter(editor.lastChild || editor);
      
      const tempDivNach = document.createElement('div');
      tempDivNach.appendChild(rangeNach.cloneContents());
      const textNach = stripCueMarkers(tempDivNach.innerHTML);
      
      // Pr√ºfen ob beide Teile Inhalt haben
      const textVorClean = textVor.replace(/<[^>]+>/g, '').trim();
      const textNachClean = textNach.replace(/<[^>]+>/g, '').trim();
      
      if (!textVorClean || !textNachClean) {
        alert('Beide Teile m√ºssen Text enthalten. Bitte den Cursor anders platzieren.');
        return;
      }
      
      // Neue Szenennummer berechnen
      const altNr = aktuelleSzene.nummer;
      const [akt, szene] = altNr.split('.').map(Number);
      const neueNr = `${akt}.${szene + 1}`;
      
      // Best√§tigung
      if (!confirm(`Szene "${altNr}" hier teilen?\n\nText vor dem Cursor bleibt in Szene ${altNr}.\nText nach dem Cursor wird neue Szene ${neueNr}.`)) {
        return;
      }
      
      // Text in aktueller Szene aktualisieren
      state.textbuch[state.aktiveSzene] = textVor;
      
      // Neue Szene erstellen
      const neueSzene = {
        id: genId(),
        nummer: neueNr,
        titel: `Teil ${szene + 1}`,
        ort: aktuelleSzene.ort,
        zeit: aktuelleSzene.zeit,
        gruppe: aktuelleSzene.gruppe,
        zusammenfassung: '',
        figuren: [...(aktuelleSzene.figuren || [])]
      };
      
      // Szene an richtiger Stelle einf√ºgen (nach aktueller Szene)
      const idx = state.szenen.findIndex(s => s.id === state.aktiveSzene);
      state.szenen.splice(idx + 1, 0, neueSzene);
      
      // Text f√ºr neue Szene speichern
      state.textbuch[neueSzene.id] = textNach;
      
      // Nachfolgende Szenen umnummerieren (wenn gew√ºnscht)
      // TODO: Optional
      
      saveProjektDaten();
      
      // Zur neuen Szene wechseln
      state.aktiveSzene = neueSzene.id;
      render();
      
      // Hinweis anzeigen
      alert(`‚úÖ Szene geteilt!\n\nNeue Szene "${neueNr}" wurde erstellt.\nBitte Titel und Zusammenfassung anpassen.`);
      
      // Modal zum Bearbeiten √∂ffnen
      setTimeout(() => editSzene(neueSzene.id), 100);
    }

    // v1.2: Kost√ºm-Handler
    async function openKostuemModal(kostuemId = null) {
      // Reset pending images
      pendingKostuemBilder = [];
      pendingMaskeBilder = [];
      
      if (kostuemId) {
        const kostuem = state.kostueme.find(k => k.id === kostuemId);
        state.editingKostuem = { ...kostuem };
        
        // Migration: alte Einzelbilder zu Arrays konvertieren
        if (!state.editingKostuem.kostuemBilder && kostuem.kostuemBildId) {
          state.editingKostuem.kostuemBilder = [kostuem.kostuemBildId];
        }
        if (!state.editingKostuem.maskeBilder && kostuem.maskeBildId) {
          state.editingKostuem.maskeBilder = [kostuem.maskeBildId];
        }
        
        // Bilder vorladen
        const allImages = [...(state.editingKostuem.kostuemBilder || []), ...(state.editingKostuem.maskeBilder || [])];
        for (const imgId of allImages) {
          await getImageUrl(imgId);
        }
      } else {
        state.editingKostuem = { 
          name: '', figur: '', beschreibung: '', maske: '', szenen: [], notizen: '',
          kostuemBilder: [], maskeBilder: []
        };
      }
      state.showKostuemModal = true;
      render();
    }

    function editKostuem(kostuemId) {
      openKostuemModal(kostuemId);
    }

    async function saveKostuem() {
      const name = document.getElementById('kostuem-name').value.trim();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      
      const szenenChecks = document.querySelectorAll('.kostuem-szene-check:checked');
      const szenen = Array.from(szenenChecks).map(cb => cb.value);
      
      const kostuemId = state.editingKostuem?.id || genId();
      
      // Bestehende Bilder √ºbernehmen
      let kostuemBilder = state.editingKostuem?.kostuemBilder || [];
      let maskeBilder = state.editingKostuem?.maskeBilder || [];
      
      // Neue Kost√ºm-Bilder speichern
      for (let i = 0; i < pendingKostuemBilder.length; i++) {
        const imgId = `img_kostuem_${kostuemId}_${Date.now()}_${i}`;
        await saveImageToDB(imgId, pendingKostuemBilder[i]);
        kostuemBilder.push(imgId);
      }
      
      // Neue Maske-Bilder speichern
      for (let i = 0; i < pendingMaskeBilder.length; i++) {
        const imgId = `img_maske_${kostuemId}_${Date.now()}_${i}`;
        await saveImageToDB(imgId, pendingMaskeBilder[i]);
        maskeBilder.push(imgId);
      }
      
      const data = {
        id: kostuemId,
        name: name,
        figur: document.getElementById('kostuem-figur').value,
        beschreibung: document.getElementById('kostuem-beschreibung').value.trim(),
        maske: document.getElementById('kostuem-maske').value.trim(),
        szenen: szenen,
        notizen: document.getElementById('kostuem-notizen').value.trim(),
        kostuemBilder: kostuemBilder,
        maskeBilder: maskeBilder,
      };
      
      if (state.editingKostuem?.id) {
        // Update
        const idx = state.kostueme.findIndex(k => k.id === state.editingKostuem.id);
        if (idx !== -1) {
          state.kostueme[idx] = data;
        }
      } else {
        // Create
        state.kostueme.push(data);
      }
      
      // Reset pending
      pendingKostuemBilder = [];
      pendingMaskeBilder = [];
      
      saveProjektDaten();
      closeModal('showKostuemModal');
    }

    async function deleteKostuem(kostuemId) {
      if (!confirm('Kost√ºm wirklich l√∂schen?')) return;
      
      const kostuem = state.kostueme.find(k => k.id === kostuemId);
      
      // Alle Bilder l√∂schen
      if (kostuem?.kostuemBilder) {
        for (const imgId of kostuem.kostuemBilder) {
          await deleteImageFromDB(imgId);
        }
      }
      if (kostuem?.maskeBilder) {
        for (const imgId of kostuem.maskeBilder) {
          await deleteImageFromDB(imgId);
        }
      }
      // Fallback f√ºr alte Daten
      if (kostuem?.kostuemBildId) await deleteImageFromDB(kostuem.kostuemBildId);
      if (kostuem?.maskeBildId) await deleteImageFromDB(kostuem.maskeBildId);
      
      state.kostueme = state.kostueme.filter(k => k.id !== kostuemId);
      saveProjektDaten();
      closeModal('showKostuemModal');
    }

    // ============================================
    // B√úHNE HANDLER (v1.3)
    // ============================================
    async function openBuehneModal(buehneId = null) {
      pendingBuehneImages = [];
      
      if (buehneId) {
        const b = state.buehne.find(x => x.id === buehneId);
        state.editingBuehne = { ...b };
        // Bilder vorladen
        if (b.bilder) {
          for (const imgId of b.bilder) {
            await getImageUrl(imgId);
          }
        }
      } else {
        state.editingBuehne = { name: '', kategorie: 'Sonstiges', beschreibung: '', bilder: [], notizen: '' };
      }
      state.showBuehneModal = true;
      render();
    }
    
    function editBuehne(buehneId) {
      openBuehneModal(buehneId);
    }
    
    async function saveBuehne() {
      const name = document.getElementById('buehne-name').value.trim();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      
      const buehneId = state.editingBuehne?.id || genId();
      let bilder = state.editingBuehne?.bilder || [];
      
      // Neue Bilder speichern
      for (let i = 0; i < pendingBuehneImages.length; i++) {
        const imgId = `img_buehne_${buehneId}_${Date.now()}_${i}`;
        await saveImageToDB(imgId, pendingBuehneImages[i]);
        bilder.push(imgId);
      }
      
      const data = {
        id: buehneId,
        name: name,
        kategorie: document.getElementById('buehne-kategorie').value,
        beschreibung: document.getElementById('buehne-beschreibung').value.trim(),
        bilder: bilder,
        notizen: document.getElementById('buehne-notizen').value.trim(),
      };
      
      if (state.editingBuehne?.id) {
        const idx = state.buehne.findIndex(b => b.id === state.editingBuehne.id);
        if (idx !== -1) state.buehne[idx] = data;
      } else {
        state.buehne.push(data);
      }
      
      pendingBuehneImages = [];
      saveProjektDaten();
      closeModal('showBuehneModal');
    }
    
    async function deleteBuehne(buehneId) {
      if (!confirm('B√ºhnenelement wirklich l√∂schen?')) return;
      
      const b = state.buehne.find(x => x.id === buehneId);
      if (b?.bilder) {
        for (const imgId of b.bilder) {
          await deleteImageFromDB(imgId);
        }
      }
      
      state.buehne = state.buehne.filter(x => x.id !== buehneId);
      saveProjektDaten();
      closeModal('showBuehneModal');
    }

    // ============================================
    // REQUISITEN HANDLER (v1.3)
    // ============================================
    async function openRequisitenModal(reqId = null) {
      pendingRequisitenImages = [];
      
      if (reqId) {
        const r = state.requisiten.find(x => x.id === reqId);
        state.editingRequisit = { ...r };
        // Bilder vorladen
        if (r.bilder) {
          for (const imgId of r.bilder) {
            await getImageUrl(imgId);
          }
        }
      } else {
        state.editingRequisit = { name: '', zustaendig: '', beschreibung: '', szenen: [], bilder: [], notizen: '' };
      }
      state.showRequisitenModal = true;
      render();
    }
    
    function editRequisit(reqId) {
      openRequisitenModal(reqId);
    }
    
    async function saveRequisit() {
      const name = document.getElementById('requisit-name').value.trim();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      
      const szenenChecks = document.querySelectorAll('.requisit-szene-check:checked');
      const neueSzenen = Array.from(szenenChecks).map(cb => cb.value);
      
      const reqId = state.editingRequisit?.id || genId();
      let bilder = state.editingRequisit?.bilder || [];
      
      // Alte Szenen (f√ºr Vergleich)
      const alteSzenen = state.editingRequisit?.szenen || [];
      
      // Neue Bilder speichern
      for (let i = 0; i < pendingRequisitenImages.length; i++) {
        const imgId = `img_requisit_${reqId}_${Date.now()}_${i}`;
        await saveImageToDB(imgId, pendingRequisitenImages[i]);
        bilder.push(imgId);
      }
      
      const data = {
        id: reqId,
        name: name,
        zustaendig: document.getElementById('requisit-zustaendig').value.trim(),
        beschreibung: document.getElementById('requisit-beschreibung').value.trim(),
        szenen: neueSzenen,
        bilder: bilder,
        notizen: document.getElementById('requisit-notizen').value.trim(),
      };
      
      if (state.editingRequisit?.id) {
        const idx = state.requisiten.findIndex(r => r.id === state.editingRequisit.id);
        if (idx !== -1) state.requisiten[idx] = data;
      } else {
        state.requisiten.push(data);
      }
      
      // ========== CUE-SYNCHRONISATION ==========
      // Neue Szenen ‚Üí Cues erstellen
      const hinzugefuegteSzenen = neueSzenen.filter(s => !alteSzenen.includes(s));
      for (const szeneId of hinzugefuegteSzenen) {
        // Pr√ºfen ob Cue bereits existiert
        const existiertBereits = state.cues.some(c => 
          c.typ === 'r' && c.requisitenId === reqId && c.szeneId === szeneId
        );
        if (!existiertBereits) {
          // N√§chste freie Nummer f√ºr Requisiten-Cues in dieser Szene
          const reqCuesInSzene = state.cues.filter(c => c.typ === 'r' && c.szeneId === szeneId);
          const nextNummer = reqCuesInSzene.length > 0 
            ? Math.max(...reqCuesInSzene.map(c => c.nummer)) + 1 
            : 1;
          
          state.cues.push({
            id: genId(),
            typ: 'r',
            nummer: nextNummer,
            szeneId: szeneId,
            beschreibung: name,
            requisitenId: reqId,
            ausloeser: '',
            dauer: '',
          });
        }
      }
      
      // Entfernte Szenen ‚Üí Cues l√∂schen
      const entfernteSzenen = alteSzenen.filter(s => !neueSzenen.includes(s));
      for (const szeneId of entfernteSzenen) {
        state.cues = state.cues.filter(c => 
          !(c.typ === 'r' && c.requisitenId === reqId && c.szeneId === szeneId)
        );
      }
      // ==========================================
      
      pendingRequisitenImages = [];
      saveProjektDaten();
      closeModal('showRequisitenModal');
    }
    
    async function deleteRequisit(reqId) {
      if (!confirm('Requisite wirklich l√∂schen?')) return;
      
      const r = state.requisiten.find(x => x.id === reqId);
      if (r?.bilder) {
        for (const imgId of r.bilder) {
          await deleteImageFromDB(imgId);
        }
      }
      
      // Zugeh√∂rige Cues l√∂schen
      state.cues = state.cues.filter(c => !(c.typ === 'r' && c.requisitenId === reqId));
      
      state.requisiten = state.requisiten.filter(x => x.id !== reqId);
      saveProjektDaten();
      closeModal('showRequisitenModal');
    }

    // ============================================
    // EXPORT FUNKTIONEN (v1.3)
    // ============================================
    
    // Cue-Export Dialog
    let showCueExportDialog = false;
    
    function openCueExportDialog() {
      showCueExportDialog = true;
      render();
    }
    
    function closeCueExportDialog() {
      showCueExportDialog = false;
      render();
    }
    
    function renderCueExportDialog() {
      if (!showCueExportDialog) return '';
      
      return `
        <div class="modal-overlay" onclick="closeCueExportDialog()">
          <div class="modal-content" style="max-width: 450px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">üìÑ Cue-Listen exportieren</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeCueExportDialog()">‚úï</button>
            </div>
            <div class="modal-body">
              <p class="text-sm text-gray-600 mb-4">W√§hle die Cue-Typen f√ºr den Export:</p>
              
              <!-- Schnellauswahl -->
              <div class="flex flex-wrap gap-2 mb-4">
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('all')">Alle (Inspizient)</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('lx')">Nur Licht</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('q')">Nur Ton</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('lx-q')">Licht + Ton</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('u')">Nur Umbau</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('u-r')">Umbau + Requisiten</button>
              </div>
              
              <!-- Checkboxen -->
              <div class="border rounded p-3 mb-4">
                ${Object.entries(CUE_TYPEN).map(([key, typ]) => {
                  const count = state.cues.filter(c => c.typ === key).length;
                  return `
                    <label class="checkbox-item">
                      <input type="checkbox" id="cue-export-${key}" checked>
                      <span>${typ.icon} ${typ.name} (${typ.prefix})</span>
                      <span class="ml-auto text-xs text-gray-400">${count} Cues</span>
                    </label>
                  `;
                }).join('')}
              </div>
              
              <!-- Sortierung -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Sortierung:</label>
                <select id="cue-export-sort">
                  <option value="szene">Nach Szene (chronologisch)</option>
                  <option value="typ">Nach Typ (gruppiert)</option>
                </select>
              </div>
              
              <div class="flex gap-2">
                <button class="btn btn-outline flex-1" onclick="closeCueExportDialog()">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="exportCueListen()">üìÑ Exportieren</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    function selectCueExportPreset(preset) {
      // Alle Checkboxen zur√ºcksetzen
      Object.keys(CUE_TYPEN).forEach(key => {
        const cb = document.getElementById('cue-export-' + key);
        if (cb) cb.checked = false;
      });
      
      // Preset ausw√§hlen
      let keys = [];
      switch(preset) {
        case 'all': keys = Object.keys(CUE_TYPEN); break;
        case 'lx': keys = ['lx']; break;
        case 'q': keys = ['q']; break;
        case 'lx-q': keys = ['lx', 'q']; break;
        case 'u': keys = ['u']; break;
        case 'u-r': keys = ['u', 'r']; break;
      }
      
      keys.forEach(key => {
        const cb = document.getElementById('cue-export-' + key);
        if (cb) cb.checked = true;
      });
    }
    
    function exportCueListen() {
      // Ausgew√§hlte Typen sammeln
      const selectedTypes = Object.keys(CUE_TYPEN).filter(key => {
        const cb = document.getElementById('cue-export-' + key);
        return cb?.checked;
      });
      
      if (selectedTypes.length === 0) {
        alert('Bitte mindestens einen Cue-Typ ausw√§hlen.');
        return;
      }
      
      const sortBy = document.getElementById('cue-export-sort')?.value || 'szene';
      
      // Cues filtern
      let cues = state.cues.filter(c => selectedTypes.includes(c.typ));
      
      // Sortieren
      if (sortBy === 'szene') {
        // Nach Szene sortieren (chronologisch)
        cues = cues.sort((a, b) => {
          const szeneA = state.szenen.find(s => s.id === a.szeneId);
          const szeneB = state.szenen.find(s => s.id === b.szeneId);
          const numA = szeneA?.nummer || '99.99';
          const numB = szeneB?.nummer || '99.99';
          if (numA !== numB) return numA.localeCompare(numB, undefined, { numeric: true });
          // Innerhalb einer Szene nach Typ-Reihenfolge
          const typOrder = ['u', 'lx', 'q', 'v', 'r'];
          return typOrder.indexOf(a.typ) - typOrder.indexOf(b.typ);
        });
      } else {
        // Nach Typ gruppiert
        cues = cues.sort((a, b) => {
          if (a.typ !== b.typ) return a.typ.localeCompare(b.typ);
          return a.nummer - b.nummer;
        });
      }
      
      // Titel f√ºr Export
      const typNamen = selectedTypes.map(t => CUE_TYPEN[t].name).join(' + ');
      
      // HTML generieren
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8">
        <title>Cue-Liste ${typNamen} - ${state.projektMeta.titel}</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 20px; font-size: 11pt; }
          h1 { font-size: 18pt; margin-bottom: 5px; }
          h2 { font-size: 14pt; margin: 20px 0 10px; padding-bottom: 5px; border-bottom: 2px solid #333; }
          .meta { color: #666; margin-bottom: 20px; }
          table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
          th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: left; vertical-align: top; }
          th { background: #f0f0f0; font-weight: bold; }
          .cue-badge { 
            display: inline-block; padding: 2px 8px; border-radius: 10px; 
            font-size: 9pt; font-weight: bold; margin-right: 5px;
          }
          .cue-lx { background: #fef3c7; color: #92400e; }
          .cue-q { background: #d1fae5; color: #065f46; }
          .cue-v { background: #e0e7ff; color: #3730a3; }
          .cue-r { background: #fce7f3; color: #9d174d; }
          .cue-u { background: #fed7aa; color: #9a3412; }
          .umbau-details { font-size: 9pt; color: #666; margin-top: 5px; }
          .umbau-ab { color: #dc2626; }
          .umbau-auf { color: #16a34a; }
          .geplant { color: #f97316; font-style: italic; }
          .stichwort { font-style: italic; color: #6b21a8; }
          .szene-header { background: #e5e7eb; }
          @media print { 
            .no-print { display: none; } 
            h2 { page-break-before: auto; }
            tr { page-break-inside: avoid; }
          }
        </style>
      </head><body>`;
      
      html += `<div class="no-print" style="margin-bottom:20px;">
        <button onclick="window.print()" style="padding:10px 20px;font-size:14px;">üñ®Ô∏è¬è Als PDF drucken</button>
      </div>`;
      
      html += `<h1>Cue-Liste: ${typNamen}</h1>`;
      html += `<p class="meta">${state.projektMeta.titel}<br>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      
      if (sortBy === 'szene') {
        // Nach Szene gruppiert
        let currentSzene = null;
        
        html += `<table><tr>
          <th style="width:80px;">Cue</th>
          <th>Beschreibung</th>
          <th style="width:200px;">Stichwort</th>
          <th style="width:60px;">Dauer</th>
        </tr>`;
        
        cues.forEach(c => {
          const szene = state.szenen.find(s => s.id === c.szeneId);
          const szeneKey = szene?.id || 'none';
          
          if (szeneKey !== currentSzene) {
            currentSzene = szeneKey;
            html += `<tr class="szene-header">
              <td colspan="4"><strong>üé¨ ${szene ? szene.nummer + ' ' + szene.titel : 'Ohne Szene'}</strong></td>
            </tr>`;
          }
          
          const typ = CUE_TYPEN[c.typ];
          let beschreibung = c.beschreibung || '‚Äì';
          
          // Stichwort: Ankertext hat Priorit√§t, dann Ausl√∂ser-Feld
          let stichwort = '';
          if (c.ankerText) {
            stichwort = `<em>‚Äû${c.ankerText}"</em>`;
          }
          if (c.ausloeser) {
            stichwort = stichwort ? stichwort + `<br><small style="color:#666">${c.ausloeser}</small>` : c.ausloeser;
          }
          if (!stichwort) stichwort = '‚Äì';
          
          // Zusatzinfos je nach Typ
          if (c.typ === 'r' && c.requisitenId) {
            const req = state.requisiten.find(r => r.id === c.requisitenId);
            if (req) beschreibung = `üé≠ ${req.name}` + (c.beschreibung ? `: ${c.beschreibung}` : '');
          } else if ((c.typ === 'q' || c.typ === 'v') && c.mediumId) {
            const med = state.medien.find(m => m.id === c.mediumId);
            if (med) beschreibung = `üîó ${med.name}` + (c.beschreibung ? `: ${c.beschreibung}` : '');
          } else if ((c.typ === 'q' || c.typ === 'v') && c.mediumGeplant) {
            beschreibung = `<span class="geplant">‚è≥ ${c.mediumGeplant} (geplant)</span>`;
          } else if (c.typ === 'u') {
            // Umbau-Details
            const vonName = c.umbauVon ? state.buehne.find(b => b.id === c.umbauVon)?.name : null;
            const nachName = c.umbauNach ? state.buehne.find(b => b.id === c.umbauNach)?.name : null;
            
            beschreibung = `<strong>${vonName || '?'} ‚Üí ${nachName || '?'}</strong>`;
            
            if (c.umbauAktionen?.length > 0) {
              beschreibung += `<div class="umbau-details"><strong>Aktionen:</strong><br>`;
              beschreibung += c.umbauAktionen.map(a => `‚òê¬ê ${a}`).join('<br>');
              beschreibung += `</div>`;
            }
            
            if (c.requisitenAb?.length > 0) {
              const namen = c.requisitenAb.map(id => state.requisiten.find(r => r.id === id)?.name).filter(Boolean);
              if (namen.length > 0) {
                beschreibung += `<div class="umbau-details umbau-ab">üî¥ AB: ${namen.join(', ')}</div>`;
              }
            }
            
            if (c.requisitenAuf?.length > 0) {
              const namen = c.requisitenAuf.map(id => state.requisiten.find(r => r.id === id)?.name).filter(Boolean);
              if (namen.length > 0) {
                beschreibung += `<div class="umbau-details umbau-auf">üü¢ AUF: ${namen.join(', ')}</div>`;
              }
            }
          }
          
          html += `<tr>
            <td><span class="cue-badge ${typ.class}">${typ.prefix}${c.nummer}</span></td>
            <td>${beschreibung}</td>
            <td>${stichwort}</td>
            <td>${c.dauer || '‚Äì'}</td>
          </tr>`;
        });
        
        html += `</table>`;
        
      } else {
        // Nach Typ gruppiert
        selectedTypes.forEach(typKey => {
          const typ = CUE_TYPEN[typKey];
          const typCues = cues.filter(c => c.typ === typKey);
          
          if (typCues.length === 0) return;
          
          html += `<h2>${typ.icon} ${typ.name}-Cues (${typCues.length})</h2>`;
          html += `<table><tr>
            <th style="width:60px;">Nr.</th>
            <th style="width:80px;">Szene</th>
            <th>Beschreibung</th>
            <th style="width:200px;">Stichwort</th>
            <th style="width:60px;">Dauer</th>
          </tr>`;
          
          typCues.forEach(c => {
            const szene = state.szenen.find(s => s.id === c.szeneId);
            let beschreibung = c.beschreibung || '‚Äì';
            
            // Stichwort: Ankertext hat Priorit√§t
            let stichwort = '';
            if (c.ankerText) {
              stichwort = `<em>‚Äû${c.ankerText}"</em>`;
            }
            if (c.ausloeser) {
              stichwort = stichwort ? stichwort + `<br><small style="color:#666">${c.ausloeser}</small>` : c.ausloeser;
            }
            if (!stichwort) stichwort = '‚Äì';
            
            // Gleiche Zusatzinfos wie oben...
            if (c.typ === 'u') {
              const vonName = c.umbauVon ? state.buehne.find(b => b.id === c.umbauVon)?.name : null;
              const nachName = c.umbauNach ? state.buehne.find(b => b.id === c.umbauNach)?.name : null;
              beschreibung = `${vonName || '?'} ‚Üí ${nachName || '?'}`;
              if (c.umbauAktionen?.length > 0) {
                beschreibung += ` (${c.umbauAktionen.length} Aktionen)`;
              }
            }
            
            html += `<tr>
              <td><strong>${typ.prefix}${c.nummer}</strong></td>
              <td>${szene?.nummer || '‚Äì'}</td>
              <td>${beschreibung}</td>
              <td>${stichwort}</td>
              <td>${c.dauer || '‚Äì'}</td>
            </tr>`;
          });
          
          html += `</table>`;
        });
      }
      
      html += `</body></html>`;
      
      closeCueExportDialog();
      openExportWindow(html, 'cue-liste-' + selectedTypes.join('-'));
    }
    
    // Bild als Base64 Data-URL aus IndexedDB laden
    async function getImageAsBase64(imageId) {
      if (!imageId) return null;
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve) => {
        const transaction = mediaBD.transaction([IMAGE_STORE_NAME], 'readonly');
        const store = transaction.objectStore(IMAGE_STORE_NAME);
        const request = store.get(imageId);
        
        request.onsuccess = () => {
          if (request.result) {
            const blob = new Blob([request.result.data], { type: request.result.type });
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result); // data:image/...;base64,...
            reader.readAsDataURL(blob);
          } else {
            resolve(null);
          }
        };
        request.onerror = () => resolve(null);
      });
    }
    
    async function exportRequisitenList() {
      // Bilder als Base64 laden
      const bilderBase64 = {};
      for (const r of state.requisiten) {
        if (r.bilder) {
          for (const imgId of r.bilder) {
            if (!bilderBase64[imgId]) {
              bilderBase64[imgId] = await getImageAsBase64(imgId);
            }
          }
        }
      }
      
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Requisiten-Liste - ${state.projektMeta.titel}</title>
        <style>
          body{font-family:Arial,sans-serif;padding:20px;} 
          table{border-collapse:collapse;width:100%;} 
          th,td{border:1px solid #ddd;padding:8px;text-align:left;vertical-align:top;} 
          th{background:#f5f5f5;} 
          img{max-width:80px;max-height:80px;margin:2px;}
          @media print { .no-print{display:none;} }
        </style></head><body>`;
      html += `<div class="no-print" style="margin-bottom:20px;"><button onclick="window.print()" style="padding:10px 20px;font-size:16px;">üñ®Ô∏è¬è Als PDF drucken</button></div>`;
      html += `<h1>Requisiten-Liste: ${state.projektMeta.titel}</h1>`;
      html += `<p>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      html += `<table><tr><th>Name</th><th>Beschreibung</th><th>Zust√§ndig</th><th>Szenen</th><th>Bilder</th><th>Notizen</th></tr>`;
      
      state.requisiten.forEach(r => {
        const szenenNamen = r.szenen?.map(sId => state.szenen.find(s => s.id === sId)?.nummer).filter(Boolean).join(', ') || '‚Äì';
        let bilderHtml = '‚Äì';
        if (r.bilder?.length > 0) {
          bilderHtml = r.bilder.map(id => bilderBase64[id] ? `<img src="${bilderBase64[id]}">` : '').join('');
        }
        html += `<tr><td>${r.name}</td><td>${r.beschreibung || '‚Äì'}</td><td>${r.zustaendig || '‚Äì'}</td><td>${szenenNamen}</td><td>${bilderHtml}</td><td>${r.notizen || '‚Äì'}</td></tr>`;
      });
      
      html += `</table></body></html>`;
      openExportWindow(html, 'requisiten-liste');
    }
    
    async function exportBuehneList() {
      // Bilder als Base64 laden
      const bilderBase64 = {};
      for (const b of state.buehne) {
        if (b.bilder) {
          for (const imgId of b.bilder) {
            if (!bilderBase64[imgId]) {
              bilderBase64[imgId] = await getImageAsBase64(imgId);
            }
          }
        }
      }
      
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>B√ºhne - ${state.projektMeta.titel}</title>
        <style>
          body{font-family:Arial,sans-serif;padding:20px;} 
          .item{margin-bottom:30px;border:1px solid #ddd;padding:15px;page-break-inside:avoid;} 
          img{max-width:250px;max-height:250px;margin:5px;}
          .images{display:flex;flex-wrap:wrap;gap:10px;}
          @media print { .no-print{display:none;} }
        </style></head><body>`;
      html += `<div class="no-print" style="margin-bottom:20px;"><button onclick="window.print()" style="padding:10px 20px;font-size:16px;">üñ®Ô∏è¬è Als PDF drucken</button></div>`;
      html += `<h1>B√ºhne: ${state.projektMeta.titel}</h1>`;
      html += `<p>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      
      state.buehne.forEach(b => {
        html += `<div class="item"><h2>${b.name}</h2>`;
        html += `<p><strong>Kategorie:</strong> ${b.kategorie || 'Sonstiges'}</p>`;
        if (b.beschreibung) html += `<p>${b.beschreibung}</p>`;
        if (b.bilder?.length > 0) {
          html += `<div class="images">`;
          b.bilder.forEach(id => {
            if (bilderBase64[id]) html += `<img src="${bilderBase64[id]}">`;
          });
          html += `</div>`;
        }
        if (b.notizen) html += `<p><em>Notizen: ${b.notizen}</em></p>`;
        html += `</div>`;
      });
      
      html += `</body></html>`;
      openExportWindow(html, 'buehne');
    }
    
    // Export in neuem Fenster √∂ffnen (f√ºr Drucken als PDF)
    function openExportWindow(html, title) {
      // Direkt als HTML-Datei downloaden (Safari-kompatibel)
      downloadHTML(html, title + '.html');
      
      // Hinweis f√ºr User
      setTimeout(() => {
        alert('Die Datei wurde heruntergeladen.\n\n' +
              'üìÑ So erstellst du ein PDF:\n' +
              '1. √ñffne die heruntergeladene HTML-Datei\n' +
              '2. Dr√ºcke ‚åò+P (Drucken)\n' +
              '3. W√§hle "Als PDF sichern"');
      }, 500);
    }
    
    function downloadHTML(content, filename) {
      const blob = new Blob([content], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    // Import/Export
    // Datei-Import Handler
    let pendingImportData = null;
    
    function handleImportFile(input) {
      const file = input.files[0];
      if (!file) return;
      
      document.getElementById('import-file-name').textContent = file.name;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          pendingImportData = e.target.result;
          document.getElementById('import-btn').disabled = false;
        } catch (err) {
          alert('Fehler beim Lesen der Datei.');
          pendingImportData = null;
        }
      };
      reader.readAsText(file);
    }
    
    function doImportFile() {
      if (!pendingImportData) {
        alert('Bitte zuerst eine Datei ausw√§hlen.');
        return;
      }
      
      try {
        importFromDramera(pendingImportData);
        pendingImportData = null;
        closeModal('showImportModal');
      } catch (err) {
        alert('Fehler beim Import: ' + err.message);
      }
    }
    
    function downloadDrameraExport() {
      const exportData = exportToDramera();
      const json = JSON.stringify(exportData, null, 2);
      const filename = (state.projektMeta.titel || 'projekt').replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü]/g, '_') + '_dramera.json';
      
      const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      
      closeModal('showExportModal');
    }

    function saveFassung() {
      const name = document.getElementById('fassung-name').value.trim();
      neueFassungSpeichern(name);
      closeModal('showFassungModal');
      alert('‚úÖ Fassung gespeichert!');
    }
    
    function saveFassungAndExport() {
      const name = document.getElementById('fassung-name').value.trim();
      neueFassungSpeichern(name);
      closeModal('showFassungModal');
      
      // Kurz warten, dann Export starten
      setTimeout(() => {
        downloadDrameraExport();
        alert('‚úÖ Fassung gespeichert UND Backup heruntergeladen!');
      }, 100);
    }

    // ============================================
    // LOGO BASE64
    // ============================================
    const NINA_LOGO_BASE64 = '/9j/4AAQSkZJRgABAQAASABIAAD/4QCgRXhpZgAATU0AKgAAAAgABQEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAEyAAIAAAAUAAAAWodpAAQAAAABAAAAbgAAAAAAAABgAAAAAQAAAGAAAAABMjAyMTowMToyOSAxMToyNjo1MwAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAEgqADAAQAAAABAAADwQAAAAD/4QtCaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA2LjAuMCI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9IkRpc3BsYXkiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjEtMDEtMjlUMTE6MjY6NTMrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIxLTAxLTI5VDExOjI2OjUzKzAxOjAwIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFmZmluaXR5IERlc2lnbmVyIChOb3YgIDYgMjAyMCkiIHN0RXZ0OmFjdGlvbj0icHJvZHVjZWQiIHN0RXZ0OndoZW49IjIwMjEtMDEtMjlUMTE6MjY6NTMrMDE6MDAiLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/eHBhY2tldCBlbmQ9InciPz4A/8AAEQgDwQSCAwERAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAgICAgICAwICAwUDAwMFBgUFBQUGCAYGBgYGCAoICAgICAgKCgoKCgoKCgwMDAwMDA4ODg4ODw8PDw8PDw8PD//bAEMBAgMDBAQEBwQEBxALCQsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEP/dAAQAkf/aAAwDAQACEQMRAD8A/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//Q/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//R/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//S/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//T/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//U/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//V/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgDL1bW9H0Gyk1PXL6DT7SIZea4kWKNQPVmIFa06U6kuWmm35ESnGKvJ2R8seMv23fgH4Ud4LHVpfEdxHkFNMi85Mj/ps5SL8mNfVYfhrH1dZRUV5v9NWeTUzPDw2d/Q+ftY/4KRaejMvh/wADTSqDw13epHkf7sccn869+nwe/wDl5W+5f5s8+Wcr7MPxOTk/4KQ+Ky4MXgmxVO4a8lJ/MRD+Vdi4Qo9ar+5f5mLzmfSC+89G+GH7d/iL4i+OtE8DQ+BIvtGs3CwCSK/Y+WuCzyEGD7qKCx5rzsZwvSw9Cdd1naKvt/wTpo5rOpNQ5N/M/SEHIzjFfmx9MLQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH/9b9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAydX17RfD9m+o65fQafaxglpbiRYkGBk8sQK2p0p1JctOLb8tSJTjFXk7HyD8Qv26/gx4Q8y18OTTeLL1MjbYrtgDehnkwvX+7mvr8JwxjKutW0F57/cjxq2aUYaQ95+R8mzf8FEviS/iWG/h8PadHoiEh7HfI00inoftHG1h2whHrX1i4TwvsnFzfN30/L/gnkPN6vNflVu3/AAT6l8Gft8fBXxAscfiY3fhe4bAP2qLzYQe/72HcMfUCvlsRwtjaetK015aP7merTzahL47o+t/Cnjjwh4508ar4P1i11i1OMyW0qyAE9mA5U/UV8liMLWw8uWtBxfmexTqwqK8Hc1Na13RvDmm3Gs69ew6fY2ql5Z53EcaKPVm4/DqaypUp1ZKFNXb6IuU4xXNJ2R+b3xj/AOCgVnZSXGifBmyS+dcr/at4p8j6wwcM/sXKqfev0jL+FW7Txrt/dX6v/I+axGbJe7QXzZ+bXjf4ieN/iRqJ1XxxrNxrE5OVE75iT/rnEP3aD/dUfWv0bDYWjho8lCCivL/PdnzNWrOo71Hc4wlj94k/U5rsMRKACgD9Jf8Agnl8NTf+Itb+Kl/FmHTU/s6yJHBmmG6dgfVUwp/3q/OuLMZy0oYWL1er9Ft+P5H0mUUbzdV9NEfrXX5IfYBQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH//X/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAK9zd21lC9zdyrDDGCzu5CooHUljgAfU1UYuTstxNpK7Pln4i/tl/A/wD51pBrH/AAkOpR5H2fTB54DD+9N/qgPoxPtX1WE4dx1ezceVd3p+G55NbMqFPRO78j4V+IP/AAUC+J3iDzbTwJp1t4YtWyBK4F3dYPHVsRqfotfc4ThXC07OvJzf3L/M8Gtm1WWlNWX3s+LfFPjPxb43vW1HxhrF1rNwxyWupWkAPsh+UfgK+zo0KVCPLRioryPEnUlN3m7nNZJ6npXQZiUAKCRypI+lAHe/DT4keJ/hT4us/GHhO4MFzbOpliyRFcxZ+aKZR95WGRnqOoOa4cZhKWKoujVV0/w80b0a06U1ODN/4s/HD4ifGfVTf+M9RL2sbEwWMOUtIB2Cx/xH/afLH2rDA5bh8HDlox16vqzWviqlZ3m/l0PIiSTk8mvVOMKACgAoAu6bpt/rOo2uj6VA11e30qQQRIMtJJIdqqB6kmplKMIuUnZIpJtpLc/or+CHw1tvhL8MdD8Dw7Xnsod11Io/1t1Kd8z+43kgf7IFfzxmeNeMxU6/R7ei2P0bC0fY0o0/6uesV5B2BQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH/0P38oAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA878ffFj4dfDCx+3+OtettKUjKRyPunk9o4VzI5+imvSwmAxOKl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J7s+9SSVkWqgYUAFABQAUAeC/tD/ABt0n4H+AbjX59s+r3e6DTbUn/XXBHU/9M0HzOfTjqa9/KMtnjsQqa+Fat9l/m+h5+MxSoU+br0PwB8Qa/rHinW77xH4gunvtS1GVpriZzlndup9gOgHYACv3ylShSgqdNWS0R+fTm5ycpbsx61ICgAoAKACgAoAKACgAoA3vC3hvVfGPiTS/CmhxmS/1a5itoR23ysFyfYZyT2ArGtVjSpyqz2SuzSEHOShHdn9IngPwfpXgHwbo/g3RVC2ej20dvGcYL7B8zn3dssfc1/OOLxE8RWnXnvJ3/r0P0qlTVOChHoddXGbBQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAf/Q/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgBrKrja4DA9jzQBmf2Ho3nfaPsMHm/wB7yk3fnjNbe1qWtzP72RyR7Goqqo2qAAOwrEsWgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA/Kj/go94evf7R8F+K1LNaeXdWLDJKrJlZVOOgJGRnvX6rwjVjyVaXXR/ofJZzB80J/I/Mav0s+YCgAoAKACgAoAKACgAoAKAP0q/4J9fCL+0Na1H4waxBm304PY6buHW4cDz5V/3EwgPqzdxX5xxVj+SnHBwestX6dF83r8j6XKcPeTrS6aI/WavyY+vCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP/0f38oAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAC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rH8Ufr94Y8U+HfGeiWviTwrqEOp6ZervingbcjDv9COhB5B4Ir8hr0KlCbp1Y2kujPsqdSNSPNB3Rv1zmgUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH/9f9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgBruqAsxwAMk+gp2A+aPih+1r8GfhgZbK71cazq0eR9h07E8oI7O+fLT/AIE1fTYLIcbirSUeWPd6f8Fnl18woUtL3fZH59/ET9v74peJPNs/A1nbeFbNsgSYF3eEeu58RoforY9a+/wnC2FpWddub+5f5nz1bNas9Ie6vvZ8YeJ/GHirxpeHUPF2r3Wszk5DXczzY/3VYlV/4CBX2VGhSox5aMVFeSseJOpKbvN3OcJJ6kn610GYlABQAUAFAHqHwY+Id18LPiboHjaByIbG4VbpQcB7SX5J1P8AwE7h7ivNzDCLFYadB9Vp69Dqw9V0qsai6fkf0cWlzDeW0V3btvimRXRv7ysMg/iDX85yi4tp7n6SndXRYqRhQAUAFAHxX+2R+0G3wo8JDwj4YuAninxDE6xupy1pa/defHZiflj98ntX23D2VLFVfbVV7kfxfb/M8PMcX7KHJD4n+CPxEZixLMSSSSSTkknqST1J7mv2o+HEoAKACgAoAKACgAoAKACgAoAKACgAoAKAPevgP+0D4w+BfiIXukub3Rbtwb7TpGIjmXgF0J4SYDo+OejZHTw8zyqjjqfLPSS2fb/geR34XFzoSvHbqj93vh18Q/C/xS8J2XjLwjdC6sLwdDxJFIv34pF/hdDwR+I4xX4VjMHVwtV0ays1+PmvI++o1oVYKcNjuK4DcKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgA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AoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD/9P9/KACgAoAKACgAoAKACgAoAKACgDxX40/HbwR8EPD51bxNP5t7OGFnYREG4uXHZR/CgP3nPA9zxXt5dldfHVOWktFu+i/4PkcOJxdOhG8t+x+IHxl+O3jz43a5/aPim58nT4HLWmnQki2th2IH8cmOrtz6YFftuX5ZQwVPkpLXq+r/wCB5Hw2JxVSvK83p2PGK9g4goAKACgAoAKACgAoAKACgAoAKACgAoA/TH/gnBBqia941uhbSf2dJbWaGfH7vz0eQhM922tnA6DGeor824vcfZUVfW7+6yPpsnUueb6WR+r9flB9cFAH57/8FBviKdB+Hum/D6xm23PieffOoPP2S1wxBHo0hX/vmv0LhTCc+IliJLSC09X/AMD8z53N63LTVNdf0Px3r9ePjQoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgA57UAfrh/wT1+Jh1Pwpq/wvv5C0+hy/bLME8/Zbg4dR7JJk/Rq/J+LMHy1IYqP2tH6rb70fXZRWvGVJ9NT9IK/Nz6YKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD/9T9/KACgAoAKACgAoAKACgAoAKAPlr9pD9pvw18DdKOm2uzU/Fl5Hm1sQ3yxKeBNcEHKx+g+8/QcZI+qyfJamOlzy0prd9/Jef5Hk43GxoKy1l/W5+H3jTxt4o+IfiO78V+MdQk1HU7w5eR+Aq9kjUcIi9lXgV+24fD0sPTVKjG0V/X3nw1SpKpJzm7s5WukyCgAoAKACgAoAKACgAoAKACgAoAKACgD3L4F/Abxf8AHPxMul6J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AFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQB//9P9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA5fxp4v0TwD4W1Pxh4jm8jTtKgeeVu5CjhVHdmbCqO5IFdWGw88RVjRprVuxlVqRpwc5bI/nc+K/xK1z4t+PNU8da8dst8+IYQcrb26ZEUK9OFXqe7Fm71/Q2CwdPCUI0Key/F9X8z84r1pVqjqS6nnVegc4UAFABQAUAFABQAUAFABQAUAFABQAUAFABQBasb690y7iv9NuJLS5hOY5YXMciEd1ZSCD9DUyipLlkroabTuj68+GP7bPxm8GX9haeJdVXxHoiSxi4S+jD3CwbhvKTpsfcFzjfv5618njOHMFXi3Tjyy6W2v6bfkevRzKvTa5ndeZ+4drcwXttFeWriSGdFkRh0ZWGVI+oOa/D5RcW4vdH3aaauiepGeJftJWT3/wE8e20YyTo923/fCFz/KvcyaSjj6Lf8yODGq+HmvI/nc681/Qh+dBQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAbvhvwx4i8YavDoPhXTZ9V1Gc/JBboZHPucfdHqTgCsatWnSg6lWSS7suEJTfLBXZ+lXwW/4J/qfI17403m4ghhpFm/HHae4U8/7seP9/sPzjMeKkr08Ev8At5/ov8/uPpsNlP2q7+X/AAT9LvD3hzQvCekW+g+G7CHTdPtV2xwQII41HsB3Pcnk96/M61apWm6lWTbfVn08IRhHlgrI26wNAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA/9T9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA/Ib9vX43Pr/AIgi+Dugzg6fozrPqTIeJLvB8uEn0iU5I/vnn7or9d4Xy32dN4yotZaL07/P8j47NcTzS9jHZb+v/APzor9DPnAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAEIDfKeh4P40Af0bfAS+udS+CXgS9uyTNLolgWJ6kiBRk/lX875rFRx1ZL+Z/mfo+EbdCDfZHrdeOdp4t+0F438I+B/hP4iu/GFz5VrqFncWMcS/NLPLcxtGsca92O7J7AZJ4Fe3lOGrV8XTVFapp+iTvc4cZVhToyc+qsfzrICEUHqBX9DH5yOpAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQBf0zStT1q/h0vR7Sa+vbg7YoII2llcn+6qgn8eg7monOMIuU3ZLqxpNuyP0A+Dn7A3ivxGYdY+LN03h+wOG+w25V72RfR35WHj03NXweYcUUaV4YVcz79P8Agn0OGyqc/eraLt1/4B+oHw9+FvgT4W6QNE8D6RDpkBA8xkG6WUgdZJGyzn6nHoBX5fi8diMVPnryv+S9EfU0cPTorlpqx6DXnHSFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAf/9X9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgDxz48/FK0+D3wx1fxnMQbqFPJsozz5t3L8sS4PUA/MfYGvZyvAvGYqNFbbv0W5xYuuqNJz69PU/ne1HUL7VtQudV1OZrm8vZXnnlY5aSWRizsT7k1/QsYxjFRirJH5y227sp1QgoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKANPRdG1HxHrFj4e0iIzX2pzx20CKMlpZmCIPzIrOdSNOLqTei1fyKjFyait2f0teD/D0HhLwpo3ha1O6HR7O3s0PTIgjWMH8cZr+bMRWdatOs/tNv72fptOHJBQXRWOiY7RmuY1Pwh/bF+Ll18Tfi3f6VaXBfQfC7tZWiA/I8q8XE3HBLP8oP91RX7vkGAWFwkZNe9PV/ovu/E+BzDEOrWa6LRfqfJ1fUnkhQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQBf0zStT1u/h0vRrSa/vbltsUFvG0srt6KiAk/lUTnGCcpuyXcpJydlufefwi/YH8ceJ2g1X4oXX/CMac2G+yxbJb9xwcN96OHPuWYegNfC4/ijD0rxwy55d9l/m/61Pew+VVJ61fdX4n6dfDT4LfDf4R2P2PwPo0VlI6gS3LfvLqbHeSZssfpnHtX5ljcyxOLd687rtsl8j6ihhaVFWpr/ADPVK8k7AoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP/W/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA/GL9vT4rnxZ8RYPh1ps2/TfCgzOAfle/mXLfUxIQvsWNfs/DGB9jhniJL3p/kv8AM+KzXEc9X2a2j+Z8GV9yeAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAfon+wP8ABZvEHimf4u67b503QS0GnhxxLesPnkAI5EKHAP8Afb1Xj8+4ozH2dFYSD96W/p/wfyXmfR5VhuaftpbLb1/4B+voAAwK/ID7E4z4ieI18IeBPEHihm2f2VYXNyp/2o42K/8Aj2K7cHR9tXhS7tL8TCtPkpyn2R/NLLcTXcr3dwxaW4ZpXJ6lpDuP6mv6Tsloj8yvfUZQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAGvoXh/XfFGpxaL4a0641W/mOEgtYmmkJ/wB1QcfU8VnUqQpx56kkl3ehcYyk+WKuz75+E3/BP/xfrzw6p8Vr8eH7FsN9itSs14w9HfDRRZ9t7DpgGvg8dxVQp3jhVzPu9F/m/wAD3sPlNSWtV2X4n6X/AA2+DHw2+Etl9k8DaJDYyMoWS5I8y6l/66TPlz9M49BX5pjMyxOLd687rtsl8j6ihhqVFWpr/M9RryjrCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//1/38oAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA84+LnxAsfhd8Odd8c3540u2Z4k7yTt8sSD3ZyBXpZfhJYrEwoR6v8Ov4HLiKypUpVH0P5xdU1K/1nU7vV9VmNxe300k88hOS8srbnb8SfywK/ouEIwioRVktj83k222yhVkhQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAaWjaTf67q9jomlpvvNQnit4F9ZZnCJ+GSCfaonOMIuctlqyopyait2f0i/DXwNpXw28C6L4I0ZAttpNskOR1eQDMkjHuzuSxPcmv5xxuKnia86892/+GXyP0qhSVKmqceh3NcB0Hzf+11etYfs5+OJkYqz2axAj/prMiH9DX0uQR5sxorz/RnmZi7YaZ+ABGCR6cflX72fnwlABQAUAFABQAUAFABQAUAFABQAUAFABQAUAABJwOTQB23gj4ceOfiRqA0zwNotzrE2cMYU/dR+8kpwiAe5z7Vx4jFUcNHnrzUV5/5G1OlOo7QVz9C/hV/wT0kcxal8XtXwv3jp+mt/47JcEfnsH41+f47iyKvHBwv5v9F/mfRUMoe9Z/Jf5n6KeBfhl4E+GunDS/BGi22kwYwxiT95J/10kOXf/gTGvzvFY3EYmXNXm3/XRbH0lKhTpK1NWO7rzzoCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP/Q/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD8rf+Ch/wATme70P4S6dMdsQGqX6qf4iStsh+mHfHrtNfqfCeCtGeLkv7q/X9F958nm9fWNFer/AEPzBr9NPlwoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD6P/AGR9Jt9Z/aH8G290oeOCee52kZBaCBmX8mIP4V89ns3DLqzXa33s9LARUsTBM/oAUYAFfgB+hC0AfKH7bTlP2bvFWP4jaD87mOvrOG/+RjT+f5HkZn/u0vl+Z+D7ffb6n+dfuh8EJQAUAFABQAUAFABQAUAFABQAUAFABQAZABJ4A70Ae/fDL9mX4xfFYxXPh/Q3tNMkx/p99/o1tj1Tdl5P+AKR714eNzjB4TSrP3uy1f8AwPmd9HBVq2sI6d3sfop8L/2Avh34b8rUPiNdyeKr1cMYBut7EEdjGCXk/wCBNj2FfneN4qxFS8cNHkXfd/5I+joZTTjrVd/yPubRPD2h+G9Pj0rw/YQadZwgKkNvGscYA6fKoFfDVa1SrJzqSbfdnvwhGC5YqyNisCwoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP/R/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAKl9e22m2U+oXsght7WNpZXbgKiDczH2ABNXGLlJRjuxNpK7P5u/it48u/id8Rdf8AHd2T/wATa6eSJT/yzt1ASFP+Axqo+uT3r+jsFhlhsPChH7K/Hr+J+aV6rq1JVH1PPq7znCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPcv2afEsPhP47eC9YuW2wfbxbyH/Zu0MH/oTLXi5vRdXA1oLe1/u1O7BzUK8JPv8Amf0Or05r+eT9GFoA+Vv21ITN+zd4tx/Atq35XMdfV8Nv/hSp/P8AJnk5n/u0v66n4NN99vqf51+6nwI2gAoAKACgAoAKACgAoAKACgAoA1tE0HXPEuox6R4d0+41S9lICQ20bSyMT2AUGs6lSFOPPUaS7vQuMZSdoq7Ptn4a/sDfFLxT5V947uofCdi2CYmxc3pH/XND5af8CkyPSvi8ZxRhKN40E5v7l97/AMj2qOVVp6z91fifob8Mf2Tvgt8MPJvLHRhq+qxYP27UiLmUN6orDy4+emxQfc9a/Psbn+NxN4uXLHtHT8d2fR0MvoUtUrvuz6TVQo2qMAdq+YPUFoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP/0v38oAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD5C/bZ+Io8D/AAP1LS7SXy9Q8UOumRbThhFJ81w30EQK/VhX2HDeE9vjoza0hr8+n4/keNmdb2dBpbvT/M/Cyv3A+ECgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgDqfBPhjXfGfi3SPC3hlWOqalcxxW5X+B9wPmH0EYG8n0Fc2Irwo0pVanwpXf8AXnsa04SnJQjuz+lrToJ7XT7a2upvtE0USI8pGPMZVALY7ZPNfzXNpybSsj9NirJJl2oKPmr9sCLzv2b/ABwuMlbSNh/wGeM19Lw+7ZjR9X+TPMzFf7NP+up+ArfeP1NfvZ+fCUAFABQAUAFABQAUAFAAeMA8bjgZ7n2Hf8KAPevhx+zP8ZvigUn8P+H5bawbGby//wBFgAOORvG9+ucKprw8Zm+DwulWpr2Wr/r1O6jg61X4I6d2ffXw2/4J6+ENJeK++Jury69MvLWtpm2tcjsX/wBa4/75r4PGcWVZXjhYcq7vV/dsfQ0Moitarv6H3b4R8A+C/AWnjS/BujWuj2wABW2iEZbHd2HzOfdia+ExGLr4iXNWm5PzPfp0YU1aCsdfXEbBQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQB//0/38oAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD8X/APgoB48bxB8V7HwVbyFrXwvaKXXOR9qvMSP+Ij8sV+z8LYX2eEdZ7zf4LT87nxObVeasodv1Pg+vuTwQoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA/Wf9gn4HNpGly/GbxFb4utVjaDSlcfNHak/vJsHoZSML/sD3r8p4ozLmksFTei1l69F8vzPrcqw1l7eXXY/SmvzU+nCgDC8T+GdC8ZaBfeF/E1mmoaXqUZiuIJM7ZEPODjnqAQR0NdFCvUo1FVpO0lszOpTjOLhNXTPzU+KH/BPIu82pfCTWhGDkjT9SJKj/AGY7hQWHtvVvrX6VguLFpHFw+cf1X+R8xXyh70X8n/mfCfjX4D/F/wCHski+KfCt9bxR9Z4ozc25HqJYQy4+uD7V91hsywmI/g1E/K9n9z1PAq4atT+OLR5FldxTcNw6rkZ/LrXq2OUk8qXr5bY/3TU3Q7MPKl/55t/3yaLoLDGxH/rCE/3jt/nT9BGvpGga7r8wt9B0261ORuAtrBJOf/IatWc5wpq82l66fmVGLlpFXPoPwd+yD8ffGRSSDw02k2zf8ttSlW1Uf9s8NKf++RXgYjPsvo71Lvstf+B+J6NPAYie0beuh9beCf8AgnPax+Xc/EPxU87YBa202IRpn0Msu5j9QBXyWJ4u6Yel85P9EevSyfrUl9x9neAf2bvgv8N9k3hrwxbfbEH/AB9XI+03BPr5ku7B+mK+NxWc43E6VKjt2Wi/A9qlgqFL4Y6/ee4KioMKMY4rwj0B1IAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//1P38oAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAKWo3tvp1jcX92/lwW0bSyN6JGCzH8gauEXKSjHdkyaSbZ/NV4+8V3fjrxvr3jG9bdLrF7Ncn2VmwgHsFAA9q/pPDUFQowox2ikj8yqzdScpvqcjXUZBQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH0f+zJ8Crz44+Po7K7R4/DeklJ9TnA4KZ+SBT03ykY9lDHtXz2cZnHA4fmXxvSK/X0R6WCwrr1LPZbn77WNla6bZQafYxLBb2yLFFGgwqIgwqqOwAGBX4HOTlJyk7tn6CkkrIt1AwoAKACgBpVWBBGQetAHE698Mvhz4p3HxH4Y03Ui/U3FpFIx/FlzXoUsdiqX8KrJejZzzoUp/FFP5Hmlz+yn+zpdsXl8AaWrN1KRGP/ANBIr01n2ZL/AJfM5Xl+Gf2EQw/sl/s4wkFfAWnPj++rP/6ExpvP8yf/AC+f4CWX4ZfYR2ekfAv4M6CyyaR4I0e2dejLZQlh/wACKk1xVM1x1TSdaX3s3jhKEfhgvuPS7WxsrGNYbK3jt414CxoEUfQACvLlOUneTudaSWyLQAHSoGLQAUAFABQAUAFAATgZoA+VPGX7Y3wY8C+KdU8H69eXkeo6RMYJ1Szd1DgBuGBwRgjmvqMPw/jq9KNanFWeq1PKqZhQhNwk9V5HNf8ADePwB/5/r7/wAk/+Krp/1YzH+Vf+BGf9qYfu/uD/AIbx+AP/AD/X3/gBJ/8AFUf6sZj/ACr/AMCD+1MP3f3B/wAN4/AH/n+vv/ACT/4qj/VjMf5V/wCBB/amH7v7j034V/tN/Cf4wa9N4Z8I6jIdSihM6w3EDW7SIpw5j3E7iuQWA5AOema83G5Ni8HBVK0dNtHc6aGNo1pcsHqfQdeAegFABQAUAFABQAUAFAHyHrf7bXwN0DWdQ0HUL29W6024ltpgtlIwEkLbWAIPIyOtfWU+HMfUhGcYqzV/i7nkSzKhGTi29PIy/wDhvH4A/wDP9ff+AEn/AMVWv+rGY/yr/wACJ/tTD939wh/by+AIGft1/wAf9OEn/wAVR/qxmP8AKv8AwL/gB/amH7v7j6G+FnxW8JfGDw7L4o8GyyzWMNzJasZojC3mRY3Da3OOetfP43A1sHU9lWWtr6O56FCvCtHnhsel15x0hQAUAFAHzB4//a4+D/w28Xah4K8TXd3HqWmmMTLHaPIgMsayLhgcH5WFfS4XIcZiaUa1JLlfmeZVx9GnNwk9V5HHf8N4/AH/AJ/r7/wAk/8Aiq7P9WMx/lX/AIEY/wBqYfu/uD/hvH4A/wDP9ff+AEn/AMVR/qxmP8q/8CD+1MP3f3H0N8K/ir4S+MPhp/FfgyWWawS4ktS00RhbzIgpYbWJOMMOa+fxuBrYOp7KurO19Hc9ChXhWjzw2PSq846QoAKAEJwCT2oA+W/HP7X/AMHPh74s1HwZ4ju7uPUtLdUmWOzeRAzKGGGBweDX02GyHG4ilGtSiuV7anl1cwoU5uEnqvI5T/hvH4A/8/19/wCAEn/xVdf+rGY/yr/wIy/tTD939wf8N4/AH/n+vv8AwAk/+Ko/1YzH+Vf+BB/amH7v7g/4bx+AP/P9ff8AgBJ/8VR/qxmP8q/8CD+1MP3f3Ho/wv8A2ovhH8WvEh8J+FNSl/tMwtNHFcwNb+aseN4jLEhmUHJUc4yegOPOxmS4zCU/a1orl8nc6KONo1ZckHqfRNfPnohQAUAFABQAUAFABQB8leJf20vgl4U8Ran4X1e8vUvtIuZbScJZO6iWFijAMG5GR1r6qjw7jqtONWEVaSute55M8xoQk4tu68jE/wCG8fgD/wA/19/4ASf/ABVb/wCrGY/yr/wIj+1MP3f3B/w3j8Af+f6+/wDACT/4qj/VjMf5V/4EH9qYfu/uPffhP8YPBvxm0O78QeCppprSzuTayGaFoWEgRZMAMTkbXHNeDjsvr4Oap10k2r6O530MRCtFyhsep15h1BQAUAFABQAUAFABQAUAfI/iH9tf4FeHNd1Dw/ealcy3GmzyW0jQWjyxGSJir7HBAYBgRkccV9XS4cx9SEakYqzV9XY8meZYeMnFvbyMf/hvH4A/8/19/wCAEn/xVbf6sZj/ACr/AMCI/tTD939wH9vL4AgE/br849LCT/4qj/VjMf5V/wCBB/amH7v7j690TWdN8RaPY6/o063VhqMEdxBKnKvFKoZGH1BFfJ1Kcqc3TmrNOzPXjJSSlHZmnWRQUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQB/9X9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD5m/a88bHwP8AATxLdQSmO81ONdOt8HBL3bbG/wDIe419Pw/hvb4+mnstX8v+CeXmFXkw8vPT7z8CMBRtXovA+gr95Pz8KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA7HwB4D8SfEvxZp/gvwpb/aNQ1B9q5+5Gg5eWQ/wog5Y/QDkgVyYnE08NSlWqu0V/VvVm1KlKrNQhuz+gv4OfCfw78GvA1j4N0BA5hHmXNywAkublv9ZK+PU8KP4VwvavwDMcfUxtd1qnyXZdv66n6HhsPGhTUInqleSdYUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFACN90/SmB/PL+05/wAnB+Pv+wo//ouOv6CyX/kX0fT9WfnWN/3ifqeFV7pwBQAUAbfhrxHrfhDX7DxP4cumstT0yZZ4Jk6q65HI7ggkMDwQSDwTWFajCtTlSqK8XozSE5QkpxeqP6BfgD8a9E+OHgO28S2RSDU4MQajaA5Nvcgcgdyj43RnuvHUGvwHNMunga7pS1W6fdf59z9CwmJjXp8y36nuFeIdwUAFABQAUAFACHpTA/mu+K3/ACVDxj/2GtQ/9HtX9I4H/daX+FfkfmmI/jT9WcDXccwjfdb6GmB+03/BPn/kimof9hy+/wDZa/F+K/8Afo/4Ufb5T/Afqz7rr4Y90KACgAPSgD8C/wBsf/k5Dxl/v2X/AKSRV+9cPf8AItpfP82fn+Y/7zP5fkfMdfTHlhQB+1H/AAT3/wCSFXP/AGGr3/0XDX4vxV/vy/wr9T7fKf4HzZ90V8Oe6FABQA1/uN9DTW4H8/X7Wf8AycV42/6+Yv8A0SlfvuQ/8i6j6fqz88x/+8zPnavojzgoAKANTRNa1Xw5q9lr+h3L2eoafKk8EyHDJIhypH9R3HFZVKcKkHTqK6ejLhJxkpReqP37/Z0+OelfHLwLDrMYS21mx2walaqf9VPjO9R18uT7yH6jqK/A83yyeBruD1i9U+6/zXU/QcHilXp83XqfQNeAegFABQAUAFABQAHpTA/nF+O3/JbPHv8A2HdQ/wDR71/RWWf7lQ/wx/I/NsV/Hn6s8pr1TkCgD9jP+CdP/JJ/EX/Ybf8A9JYK/H+Lf97p/wCH9WfZ5P8AwZev6I/QSvz8+hCgAoAKACgAoAKACgD5k/av+Mh+Dvwru7zTJxFr+tE2OnAfeWRx+8mHI/1SZIP94rnrX0uR5f8AXMUoyXux1f8Al83+FzzMfiPY0m1u9EfgVz3JJ9TyT9TX72fnwUAFAH61/wDBP74xHV9Bvfg9rU+brRQ11pu48taOwEkQz/zychh/sv6LX5NxVl/JUWMgtJaP16P5r8j6/KcRzRdGXTb0P0lr84PpQoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//W/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA/LP/go34u+fwj4EgbBbz9SnAPUDEMeR9ckV+pcI4fSrXfkl+bPlM4qfDT+Z+Xdfpx8sFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQBqaJomreJNXs9B0K1kvtQv5FhggiG55JG6Ko/UnoBycCs6lSFOLnN2S3KjFyajFan7ufsx/s7aZ8DPCxmvvLu/FOqopv7leVQDkW8RPPloep/jYbj2A/DM6zeWOq2jpTjsu/m/P8AI+9wODWHjd/E9/8AI+oK+WPVCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAEb7p+lMD+eX9pz/k4Px9/2FH/9Fx1/QWS/8i+j6fqz86xv+8T9TwqvdOAKACgAoA9p+A/xn1r4H+PLfxTp+6406fEGo2gOBcWxOTj0kQ/Mh9eOhNeLmmXQx1B0paPdPs/8n1O7C4mVCpzrbqf0EeFvE2i+MfD9h4n8O3S3unalCs0EydHRv5EdCOoIINfgFajOjUlSqKzWjP0KE4zipx2Zv1gaBQAUAFABQAh6UwP5rvit/wAlQ8Y/9hrUP/R7V/SOB/3Wl/hX5H5piP40/VnA13HMI33W+hpgftN/wT5/5IpqH/Ycvv8A2Wvxfiv/AH6P+FH2+U/wH6s+66+GPdCgAoAD0oA/Av8AbH/5OQ8Zf79l/wCkkVfvXD3/ACLaXz/Nn5/mP+8z+X5HzHX0x5YUAftR/wAE9/8AkhVz/wBhq9/9Fw1+L8Vf78v8K/U+3yn+B82fdFfDnuhQAUANf7jfQ01uB/P1+1n/AMnFeNv+vmL/ANEpX77kP/Iuo+n6s/PMf/vMz52r6I84KACgAoA9c+Cfxe174K+O7Txho2Zrf/U31rnC3VqTlk9Nw+8h7N7E15GZYCnjaDoz36Ps/wCtzsw2IlQqKa+Z/Qd4O8XaD478M6f4s8M3S3mm6lEssUi+h6qw7MpyGB5BBBr+f8RQqUKkqVVWaP0OnUjUipxejOmrmNQoAKACgAoAD0pgfzi/Hb/ktnj3/sO6h/6Pev6Kyz/cqH+GP5H5tiv48/VnlNeqcgUAfsZ/wTp/5JP4i/7Db/8ApLBX4/xb/vdP/D+rPs8n/gy9f0R+glfn59CFABQAUAFABQAUANZgqlj2pgfgV+1f8YX+L3xWvJrCcy6DoO+w0/B+Vwjfvph/11cZB/uhR2r95yLL/qmFSkvelq/0XyPz/H4j21W62WiPmavpjywoAKAO0+HfjnV/hr420fxxohP2nSZ1lKZwJY+kkZ9nQkGuLF4WGJoSoT2kv+GZvRqulUVSPQ/o48H+KNI8aeGNL8V6FMJ7DVbeO4hYHPySDOD7joR2IIr+dcRRnRqypVFqnZn6TTmpxU47M6SuY0CgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA/9f9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAEJwM0Afgr+2Z4rHir9oLxCIm3QaMtvpsfOQDCm6TH/A3/Sv3nh+h7LL6feV39//AAD4DManPiJeWh8tV9OeUFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAFzT9PvtWv7fS9Mt3u7y8kWKGGJS0kkjnCqqjkkmplJRTlJ2SGk27I/bf8AZS/Zgsvg7pKeLPFUaXPjLUIsOeGSxifkwRHu5/5aOOvQcDn8Uz3OpYyfsaL/AHa/8m835dkfcYDAqiuefxP8D7Nr4w9sKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAEb7p+lMD+eX9pz/k4Px9/wBhR/8A0XHX9BZL/wAi+j6fqz86xv8AvE/U8Kr3TgCgAoAKACgD7s/Yv/aKPw48RJ8OPF11t8Ma3L/o8rn5bK8kIAPtFMcBuythuhNfC8RZT9Yp/WaK9+O/mv8ANfke/luM9nL2U37r/B/8E/aMEEZFfjJ9qLQAUAFABQAh6UwP5rvit/yVDxj/ANhrUP8A0e1f0jgf91pf4V+R+aYj+NP1ZwNdxzCN91voaYH7Tf8ABPn/AJIpqH/Ycvv/AGWvxfiv/fo/4Ufb5T/Afqz7rr4Y90KACgAPSgD8C/2x/wDk5Dxl/v2X/pJFX71w9/yLaXz/ADZ+f5j/ALzP5fkfMdfTHlhQB+1H/BPf/khVz/2Gr3/0XDX4vxV/vy/wr9T7fKf4HzZ90V8Oe6FABQA1/uN9DTW4H8/X7Wf/ACcV42/6+Yv/AESlfvuQ/wDIuo+n6s/PMf8A7zM+dq+iPOCgAoAKACgD7a/Y4/aMPwp8Tf8ACEeK7nb4T16Zf3jn5bG7fgTZ7RycLJ2Bw/HzZ+J4hyj61S9vRX7yP4rt6rp93Y93LsZ7KXs5/C/wZ+2oIIBHINfip9uLQAUAFABQAHpTA/nF+O3/ACWzx7/2HdQ/9HvX9FZZ/uVD/DH8j82xX8efqzymvVOQKAP2M/4J0/8AJJ/EX/Ybf/0lgr8f4t/3un/h/Vn2eT/wZev6I/QSvz8+hCgAoAKACgAoAKAPjv8AbR+MR+GXwuk0XSLjyte8U77O32n5ooMf6RN7bVO0e7V9fw7l/wBaxSnNe7DV+vRHjZlifZUuWO7PwyAAAA4A4FfuJ8ILQBJ5UnlGfYfKDbN2Dt3Yztz0zjnHpSur2HYjpiCgD9Sf+CfPxfBXUfg3rM/zR77/AEsseqH/AI+IRx/CcOB6E1+XcV4DWOMgvKX6P9D6vKcRvRl6r9T9R6/MD6kKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//Q/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgCpf3UVjZT303+rt42lbtwgLH+VXCLlJRXUTdlc/mY8Va3J4m8Tav4ilO5tUvLi6z7TSM6/+OkV/S1GmqVONNdEl9yPzCcuaTl3MGtzMKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAs2dnd6hdwWFhC9zc3LrFFFGpZ5JHOFVVHJJJwBSbSTk3ZIaTbsj9ov2Tv2VbX4VWMPjrxvCs/jC7Q7Izhk0+NxzGvYykffft90dyfxrPc8eKbw9B/u1/5N/wO33n2mAwCpL2lT4vy/4J9y18Ke+FABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAjfdP0pgfzy/tOf8nB+Pv8AsKP/AOi46/oLJf8AkX0fT9WfnWN/3ifqeFV7pwBQB9mfs/8AwEs/jj8HPHUNgscPibSNQtpdNuGGNx+z5a3dv+ecvv8AdbB9a+NzXNJYHGUXL4JJ3Xz39Ue3hMIsRQml8Sen3bHx7fWN7pl7cabqUD2t3aSNFNFINrxyIdrIwPQgjBr7CMoyipRd0zxWmnZlWqEGAeCMg9Qe4oA/ZD9ij9o4+O9FT4WeMrvd4h0eH/QppD817aRgDBPeWEYDd2XDdd1fjvEeUewn9aor3Jb+T/yf5n2mW4z2kfZT3X4o/QCvgT6AKACgAoAQ9KYH813xW/5Kh4x/7DWof+j2r+kcD/utL/CvyPzTEfxp+rOBruOYRvut9DTA/ab/AIJ8/wDJFNQ/7Dl9/wCy1+L8V/79H/Cj7fKf4D9WfddfDHuhQAUAB6UAfgX+2P8A8nIeMv8Afsv/AEkir964e/5FtL5/mz8/zH/eZ/L8j5jr6Y8sKAP2o/4J7/8AJCrn/sNXv/ouGvxfir/fl/hX6n2+U/wPmz7or4c90KACgBr/AHG+hprcD+fr9rP/AJOK8bf9fMX/AKJSv33If+RdR9P1Z+eY/wD3mZ87V9EecFAH2R+zd8CtN+Ofw2+IWloEt/EGmS2c+l3TcbZfLkzE5/55S4Ab0OGHQg/G5xmcsDiqEvsO/MvmtfVf8A9rB4VV6VRdVax8j6rpWpaFqd3ous2z2d/YyvBPBKNrxyxnaysPUH/63FfXU6kakVODunqmePKLi3GSs0Z9aEiEAgg8g8fnQB+vP7EX7R//AAlGmRfCDxrdFtZ02P8A4lc8jZa6tUHMJJ6yQgcd2jx3Uk/kfEmUeyl9bor3Xuuz7+j/AD9T7HLMZzr2M3qtj9GK/Oz6MKACgAoAD0pgfzi/Hb/ktnj3/sO6h/6Pev6Kyz/cqH+GP5H5tiv48/VnlNeqcgUAfsZ/wTp/5JP4i/7Db/8ApLBX4/xb/vdP/D+rPs8n/gy9f0R+glfn59CFABQAUAFABQBDPPDbQvcXDrFFGpZmY4CqBkkk9gKaTbshN21P57v2kPi3L8Y/inqfiSCQtpFoTZ6YvOBawsQHAPQytlz7Yr+gcnwH1PCxpv4nq/V/5bH55jcR7aq5LboeDV7x54Zxzgn2HU+w9zQB+tmn/sqeb+yA/hlrfHi26UeIOR8wvVQtHBj/AK4/u/qa/JZ53/wse1v+7Xu/Lv8AfqfYLA/7Hyfa3+Z+SfI+8Cp7g9QR1B9weK/Wj48KAOm8G+LNX8C+KtK8YaC+y/0e4S5i9GKHlD7OuVP1rmxFCFelKjU2krGtOpKnNTjuj+jj4f8AjXRviJ4N0nxnoEgkstVt0mUd0JHzow7MjZUj1FfzpisPPD1pUam8XY/SaVSNSCnHZnZVxmwUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAf/0f38oAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA8T/aO8Snwl8DPG2uI+yWLTJ44z/00mXy1/Vq9zJ6PtcdRh5r8NThxs+TDzl5H87ewRARDpGAn/fPH9K/oTfU/ObW0CgAoAKACgAoAKACgAoAKACgAoAKACgAoAKALVlZXmpXkGn6fA9zdXLrHFFGpd5Hc4VVUckk8ACplJRTlJ2SGk27I/Z79lH9lC0+FtpB488dwpceL7hMxRHDJpyOMFVPQzEffftnavGSfxzPc9eJbw+HdqfX+9/wP+HZ9pgMB7Je0qfF+X/BPuivhD3woAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgBG+6fpTA/nl/ac/5OD8ff9hR/wD0XHX9BZL/AMi+j6fqz86xv+8T9TwqvdOAKAP1l/4Jv/8AIq+OP+wjaf8ApPX5Rxf/ABaPo/zPrsm+Cfr+hU/bk/Zz/tC3m+NXgy1LXdso/tmCNcmWFQAt0AB96MDEnqvzfwnNcNZvytYKs9H8L8+3z6eegszwd17eC16/5n5S1+qnyQUAa+ga9q/hfWrHxFoF09lqWnTJPbzJ96ORDkH0I7EHgjIPBNY1aUKsHTqK6ejLhOUJKUXqj9/v2efjjo/xy8CQa7bhbfWLMLDqdop/1NxjOV7+XJyyH0yDyDX4Hm2WzwNd03rF6p91/mup+hYTEqvT5lv1Pe68E7woAKAEPSmB/Nd8Vv8AkqHjH/sNah/6Pav6RwP+60v8K/I/NMR/Gn6s4Gu45hG+630NMD9pv+CfP/JFNQ/7Dl9/7LX4vxX/AL9H/Cj7fKf4D9WfddfDHuhQAUAB6UAfgX+2P/ych4y/37L/ANJIq/euHv8AkW0vn+bPz/Mf95n8vyPmOvpjywoA/aj/AIJ7/wDJCrn/ALDV7/6Lhr8X4q/35f4V+p9vlP8AA+bPuivhz3QoAKAGv9xvoaa3A/n6/az/AOTivG3/AF8xf+iUr99yH/kXUfT9WfnmP/3mZ87V9EecFAH6n/8ABNv/AI8/Hv8A12sP/QJK/LOL/joekv0Pq8m2n8jpP24f2cz4l06X4x+DLUtqumxf8TWCJctc2sY4nVRyZIRw2OWT3UVz8NZv7KX1Os/dfwvs+3o/z9TXM8Hzr20Fqtz8jP19x0r9bPjwoA0NJ1bUtB1S01vRrl7O/sJUngnjOHjkjOVYH2P51nUpxqQcJq6e6KjJxalHdH76fs1/HjTfjl4Gj1GQx2+v6bth1K1XjZLjiVB18uQcqexyvavwXOMrnga/LvF6p/p6o/QcHilXp36rc+jK+dPRCgAoAD0pgfzi/Hb/AJLZ49/7Duof+j3r+iss/wByof4Y/kfm2K/jz9WeU16pyBQB+xn/AATp/wCST+Iv+w2//pLBX4/xb/vdP/D+rPs8n/gy9f0R+glfn59CFABQAUAFABQB8L/t0fGMeBvh0vgLR7jbrPi0PE+0/PDYL/r39jJxGv1JHQ19xw1l/t8R7ea92H4vp9254WaYj2dP2a3l+R+K/Wv2g+ICgD6a/ZL+FA+K3xg062v4fN0XQsahfZHyssR/dRH/AK6SYyP7oavmc+x31XBycX70tF+r+SPUy+h7Wsr7LVn757MJtB59fevwY/QD8GP2v/hR/wAKu+MN89hD5ej+IwdRs9owqtIxE8Q7DY/IH91hX7tw/jvrWDipP3o6P9H9x8DmOH9lWdtnqfLNfUnkhQB+lv8AwT9+MY07Vb/4Oa3Pi31Ate6XuPAnAzcQj/fUeYo9Q9fmvFWX80VjILVaP06P9PuPp8pxFm6MvVfqfrHX5SfWhQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQB/9L9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPh79v3Xm0v4HLpKtg61qdrAeeSsW6cj6Hy+a+44Vpc2Oc/5Yv8AHT9Tws2nahbuz8UPev2g+ICgAoAKACgAoAKACgAoAKACgAoAKACgAoAuafp99qt9b6ZplvJd3l26xQwxKXkkdjhVVRySTUykoxcpOyQ0m3ZH7RfsqfsoWXwptIfG/jmGO68YTrmNOHj09GGCqHoZSPvv2+6vGSfxrPM9eKboUHamv/Jv+B2X3n2uAwCpL2lT4vy/4J9xV8Me8FABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFACN90/SmB/PL+05/ycH4+/wCwo/8A6Ljr+gsl/wCRfR9P1Z+dY3/eJ+p4VXunAFAH6y/8E3/+RV8cf9hG0/8ASevyji/+NR9H+Z9dk3wT9f0P0nlijnieGZBJHICrKwyCDwQQeoNfm6bWqPpj8L/2tv2eJfgz4v8A7c8O25/4RDXZGa1IGVtJz8zWrHHA6tFnqg29V5/cchzZYyj7Oo/3kd/Nd/8APzPhMwwnsZ80V7r/AA8v8j5Dr648YKAPX/gh8Yde+Cfju18W6RumtHxDf2gOBc2pOWX03r95D2PsTXj5ll8MbQdKe/R9n/W52YXESoVOdfM/oM8IeLNC8c+G9P8AFfhq6W803U4lmhkXurdiOzKeGHUEEV+AYihOhUlSqKzW5+h06kakVOL0Z0tcxqFACHpTA/mu+K3/ACVDxj/2GtQ/9HtX9I4H/daX+FfkfmmI/jT9WcDXccwjfdb6GmB+03/BPn/kimof9hy+/wDZa/F+K/8Afo/4Ufb5T/Afqz7rr4Y90KACgAPSgD8C/wBsf/k5Dxl/v2X/AKSRV+9cPf8AItpfP82fn+Y/7zP5fkfMdfTHlhQB+1H/AAT3/wCSFXP/AGGr3/0XDX4vxV/vy/wr9T7fKf4HzZ90V8Oe6FABQA1/uN9DTW4H8/X7Wf8AycV42/6+Yv8A0SlfvuQ/8i6j6fqz88x/+8zPnavojzgoA/VD/gm3/wAefj3/AK7WH/oElflnF/x0PSX6H1mTbT+R+nzokiNG4DKwIIIyCD2Ir8zTsfUH4gfthfs7t8JPFf8Awlvhe2K+EtelYoqjK2V02WaA46I/3os9OV7Cv2zh/NvrdL2NV/vI/iu/r3+8+GzHB+xnzw+F/gfGFfZniBQB6p8G/ix4g+DXjqy8ZaETIkZ8q7tScJdWzH5427ZHVCfusB2zXl5hgKeNoOjU+T7Pv/mdeGryoVFOP/Dn9CHgfxr4f+IfhXTvGHhe5F1pupxCWN+jD+8jj+F0OVYHoRX8/YnD1MPVlRqqzR+iUqkakFOD0Z1lchqFAAelMD+cX47f8ls8e/8AYd1D/wBHvX9FZZ/uVD/DH8j82xX8efqzymvVOQKAP2M/4J0/8kn8Rf8AYbf/ANJYK/H+Lf8Ae6f+H9WfZ5P/AAZev6I/QSvz8+hCgAoAKACgClqWo2Oj6fdatqcy21nZRPPNK5wsccalnZj2AUEmrhCU5KMVdsltJNs/nY+OXxRvPjD8TdY8bTlltZ5PJsYm/wCWVnCSsK47EjLt/tMa/obLMEsHhoUFv1829/8AL5H5ziq7rVXPp09DyOvXOMDwMnigD9z/ANiv4Tf8K4+EVrrepQmLWvFZW/uAwwyQEH7NER7Rncf9pyOwr8N4ix/1nFuEX7sNF69X9/5H3mW4f2VFN7vX/I+wa+RPYPkP9tD4Tv8AEn4QXep6bB5useFt2o2wUZd4kX/SIh/vRjcB3ZAO9fW8O476tjFGT92ej/R/f+Z5GY0Pa0W1utf8z8KwQRkHIPQ1+5nwQUAbHh/X9W8K67p/iXQpjb6jpc8dzbyD+GSI7lz6qcYYd1JFY1aUKtOVKorpqzLhNwkpx3R/Rr8KviLpHxV8A6P450Y4i1KENJHkEwzqdssTY7o4I9xg9CK/nXHYSeFxE6E+n4roz9JoVlVpqpHqeh1550BQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH/9P9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPy+/wCCkWslbXwN4dDffkvbxl/65qkSn/yIa/UOEKetap6L82fLZzL4I+p+WFfqB8oFABQAUAFABQAUAFABQAUAFABQAUAFAF/StK1LXNStdG0a1kvr+9kWKCCFS8kkjHAVVHUmonOMIuc3ZLdlJOTSW5+137Lf7KWl/B+yj8W+MI477xlcp94EPFYIw5jhPdyPvyd+i4Gc/i+d57LFt0aOlNf+Teb8uy+8+2wOAVH35/F+R9p18Ue4FABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAjfdP0pgfzy/tOf8nB+Pv8AsKP/AOi46/oLJf8AkX0fT9WfnWN/3ifqeFV7pwBQB+sv/BN//kVfHH/YRtP/AEnr8o4v/jUfR/mfXZN8E/X9D9K6/Nj6Y4n4ieAfDnxN8Iaj4M8UwefYahHtOPvxuOUljPZ0bBU+tduExVTDVo1qTs1/VjGtSjVg4TWjP56vir8MvEXwj8bX/gnxIh861O6GcDCXNux/dzJ7MOo/hbIr+gsDjaeMoRr0+u67PsfnWIoSo1HTl/w551XonMFAH3B+xr+0Wfhd4kHgPxbckeFdclHlu7fLY3bnAk56RScBx2bDetfEcQ5R9ap/WKK9+P4r/NdD3cuxnspezn8L/Bn7XqwZQw6GvxY+3FoAQ9KYH813xW/5Kh4x/wCw1qH/AKPav6RwP+60v8K/I/NMR/Gn6s4Gu45hG+630NMD9pv+CfP/ACRTUP8AsOX3/stfi/Ff+/R/wo+3yn+A/Vn3XXwx7oUAFAAelAH4F/tj/wDJyHjL/fsv/SSKv3rh7/kW0vn+bPz/ADH/AHmfy/I+Y6+mPLCgD9qP+Ce//JCrn/sNXv8A6Lhr8X4q/wB+X+Ffqfb5T/A+bPuivhz3QoAKAGv9xvoaa3A/n6/az/5OK8bf9fMX/olK/fch/wCRdR9P1Z+eY/8A3mZ87V9EecFAH6of8E2/+PPx7/12sP8A0CSvyzi/46HpL9D6zJtp/I/UCvzI+oOR8deCfD/xE8Kaj4O8T2wutO1OIxSKeq5+66Hs6HDKexFdeGxNTD1Y1qTs0ZVacakHCa0Z/Pb8YfhT4h+Dfjq98F6+DIIv3trcgYS6tnPySr7/AMLjswIr+gcvx1PGUFWp/Ndn2PzvEYeVCo4SPL69Q5AoA+zv2Pv2in+Efin/AIRLxRckeEtelUSM5+Wyumwq3Az0RuFlA9n7MT8ZxBlP1ul7akv3kfxXb17fce3l2M9jPkn8L/Bn7gI6SIskbBlYAgg5BB6EGvxNq2jPuR1IAPSmB/OL8dv+S2ePf+w7qH/o96/orLP9yof4Y/kfm2K/jz9WeU16pyBQB+xn/BOn/kk/iL/sNv8A+ksFfj/Fv+90/wDD+rPs8n/gy9f0R+glfn59CFABQAUAFAH54/t8/GUeHPCFt8J9En26l4jAlvipwY7BGOF/7bSLj/cVs/eFfoXC2Xe1rPFzWkdvX/gL8bHzua4nlh7KO739D8fa/Xj40KAPdv2b/hU3xg+LWj+F7iMvpUDG81EjoLSDBZSexlcrGP8AeJ7V4WcY76nhJVV8T0Xq/wDLc9DBUPbVlF7bv0P6F440hjWKJQiIMAAYAA6AAdhX8+3vufog+kAyRFljaN1DKwIIPIIPY+xpp2A/no/aR+Fcnwg+Les+GIYyml3DfbdOPY2lwzFVB/6ZMGjP+6D3Ff0Fk+O+uYSFVv3lo/Vf57n51jaHsazj03XoeE17pwBQB+hv7Avxk/4RrxZd/CbWp8af4iJnsNx+WO+RfnQZOAJkA/4Go/vV+e8U5f7SksXBax0fp/wH+Z9HlOI5ZujLZ7ev/BP2DByMivyE+xCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP/9T9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPxx/wCCiepG4+LHh/TN2RZaNvx6Ge4b+kdfsXCULYScu8vyX/BPi83d60V5fqfn7X3x8+FABQAUAFABQAUAFABQAUAFABQAUAXdN03UNY1C20rSraS8vbyRYoYYl3SSSOcKqjuSen+FTKUYxcpOyQ0m3ZH7b/ssfstab8HNLTxT4sijvPGV6nzP99LGNhzDCf7x/wCWjjr0GFHP4pnmdyxkvY0Xamvx835dkfcYDAqiuefxfkfZlfGHthQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFACN90/SmB/PL+05/ycH4+/7Cj/8AouOv6CyX/kX0fT9WfnWN/wB4n6nhVe6cAUAfrL/wTf8A+RV8cf8AYRtP/Sevyji/+NR9H+Z9dk3wT9f0P0rr82PpgoA+Xf2pPgBafG/wSx01Ej8UaOry6dMeN5Iy9u5/uS4wM/dbB9a+nyTNXga/vfBLf/P1R5eOwirw0+JbH4NXtleadeT6dqEL211ayNFNFINrxyIdrKw7EEYNfu8ZKUVKLumfAtNOzK1USBGQQeQeD7g9aAP2B/Yk/aO/4S/So/hL40uy+u6ZHnTp5Gy13aRjmMk8mWEDvyyYPUGvyHiTKPYz+t0V7r3XZ/5P8z7LLMZzr2M91t5r/gH6H1+en0Qh6UwP5rvit/yVDxj/ANhrUP8A0e1f0jgf91pf4V+R+aYj+NP1ZwNdxzCN91voaYH7Tf8ABPn/AJIpqH/Ycvv/AGWvxfiv/fo/4Ufb5T/Afqz7rr4Y90KACgAPSgD8C/2x/wDk5Dxl/v2X/pJFX71w9/yLaXz/ADZ+f5j/ALzP5fkfMdfTHlhQB+1H/BPf/khVz/2Gr3/0XDX4vxV/vy/wr9T7fKf4HzZ90V8Oe6FABQA1/uN9DTW4H8/X7Wf/ACcV42/6+Yv/AESlfvuQ/wDIuo+n6s/PMf8A7zM+dq+iPOCgD9UP+Cbf/Hn49/67WH/oElflnF/x0PSX6H1mTbT+R+oFfmR9QFAHzf8AtL/AXTvjj4GksrdUh8R6Zum0y5bgCT+KFz/zzlAwfQ4btz9Hk+aSwNfmfwPdfr6o83G4VV6duq2PwN1PTNQ0XUrrR9Xt3s76yleGeGUbXjkjOGVh2INfvUJxnFTg7p7H5/KLi3GS1RRqyQoA/Wn9h79o7+3LGD4MeM7ndqVih/si4kbme3QZNuSeS8QyUz96MY6rz+T8S5R7OTxlFe6/iXZ9/R9fM+vyzGcy9jPfp/kfpPX5ufSgelMD+cX47f8AJbPHv/Yd1D/0e9f0Vln+5UP8MfyPzbFfx5+rPKa9U5AoA/Yz/gnT/wAkn8Rf9ht//SWCvx/i3/e6f+H9WfZ5P/Bl6/oj9BK/Pz6EKACgAoAwvE/iLS/CXh/UPEuty+RYaZBJcTP/AHUjXccep7Adzit6NKdWpGnBXbdiJzUIuUtkfzmfFP4h6p8VfH+s+PNWJD6nMWijJyIbdflhiHsqAA+pye9f0VgcJHC4eFCHT8X1Z+bV6zrVHUfU8/rvOcMZ4FAH7T/sIfCgeDfhk/jzUodmqeLmWaPcMMlhGSIB7b8tIf8AeA7V+L8T4722K9hF+7D8+v3bH2+V0OSl7R7y/LofdNfDnuhQAUAfCP7efwpPjD4aReP9Mh36l4QLSylR8z2EuPOHv5ZCyfQNjrX3PDGO9jifYSfuz/Pp9+x4Oa0Oel7Rbx/I/F4ggkHtxX7OfEiUAXtM1LUNG1G11fSZ2tb6xlSeCVDho5Y2DIwPsQKicIzi4TV09GVGTi1Jbo/on+B/xRsfjB8NtI8bWgWOa5j8u6iU/wCpuovllT2GfmX/AGSK/njMsFLB4mVCXTbzXQ/R8NXVakqi/pnrdeSdYUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH/9X9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPw+/b1vDc/tB3UGc/ZdL0+Mf8C89/61+38MRtl6fdy/Q+FzR3xL9F+p8YV9ieKFABQAUAFABQAUAFABQAUAFABQBJDDNcTJb26NLLKwREQFmZmOAqgckk8AetF0tWB+037JP7LUHws06Lx345tll8XXseYomww06Jx9xe3nMPvsOn3QcAk/jOfZ28VJ4eg/3a3f83/A7fefbZfgfZL2lRe9+X/BPuavhT3goAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoARvun6UwP55f2nP+Tg/H3/YUf8A9Fx1/QWS/wDIvo+n6s/Osb/vE/U8Kr3TgCgD9Zf+Cb//ACKvjj/sI2n/AKT1+UcX/wAaj6P8z67Jvgn6/ofpXX5sfTBQAhAIwehoA/MT9uX9nM3UE/xr8F2n763TOtQRj78aji7A/vIOJcdVw38LV+m8NZvytYKs9H8L/T/I+XzTB3/fwXr/AJn5V1+pnyYUAaWjazqvh3VrPXtDunstR0+VJ7eeM4eOVDlWH0PY8EZB4JrKpThUg6c1dPRoqMnFqUXqj9+/2cfjrpfx18CR6woW21zTtsGp2qn/AFcxHDp/0zlA3L6cr1Uk/gmb5ZLA1+TeL1T8v811P0LB4pV6fN1W59BHpXgHoH813xW/5Kh4x/7DWof+j2r+kcD/ALrS/wAK/I/NMR/Gn6s4Gu45hG+630NMD9pv+CfP/JFNQ/7Dl9/7LX4vxX/v0f8ACj7fKf4D9WfddfDHuhQAUAB6UAfgX+2P/wAnIeMv9+y/9JIq/euHv+RbS+f5s/P8x/3mfy/I+Y6+mPLCgD9qP+Ce/wDyQq5/7DV7/wCi4a/F+Kv9+X+Ffqfb5T/A+bPuivhz3QoAKAGv9xvoaa3A/n6/az/5OK8bf9fMX/olK/fch/5F1H0/Vn55j/8AeZnztX0R5wUAfqh/wTb/AOPPx7/12sP/AECSvyzi/wCOh6S/Q+sybafyP1Ar8yPqAoAKAPzc/bi/Z0Ov2E3xn8G22dSsIx/a8EY5uLeMYFwoHV4l4fuyAd0AP6Nw1m/s5fU6z91/C+z7ej/P1PmszwfMvbwWq3/zPySr9aPkAoAu6bqWoaNqNrq+k3D2l7ZSpNBNGdrxyxsGVlPqCM1E4RnFwmrp6MqMnFprdH72/sx/HzT/AI4+B0ubx0g8S6Xth1K3HHz4+WdB/wA85eox91sr6Z/B85yuWBr2XwPZ/p6o+/wWKVend7rc+lj0r5s9M/nF+O3/ACWzx7/2HdQ/9HvX9FZZ/uVD/DH8j82xX8efqzymvVOQKAP2M/4J0/8AJJ/EX/Ybf/0lgr8f4t/3un/h/Vn2eT/wZev6I/QSvz8+hCgAoAKAPzH/AOCgXxjNpYWXwZ0aXEt8EvNUKnkQKcwwn/row3n2UV+mcK5feUsZNbaR9er+R8xm2IslQj13Pyn+tfqh8kFAHq3wT+Gt18W/ibofgeFW+z3k2+8df+WdnF807exIwo92HpXlZljFhMLOu91t6vY7MLR9tVVP7/Q/ovsLG10yxt9OsYxDb2saxRoowFRBtVR9AK/neUnJuT3Z+jpJKyLdQMKACgClqNhaarp9zpl/EJ7a7jeKWNhkOjgqwI9wauEnGSlHdCaTVmfzk/GP4cXvwm+JGt+BbtSI9Pmzauf+WlpLloHB7/J8p/2lNf0Vl+MWLw0K63e/r1PzbE0XRqyp9vy6HmVemcoUAfdf7CnxibwR8QpPh5q023SfFjKIdx+WK/RTsI9PNX5T7gV8LxNl/tsOsRBe9Df0/wCAe/leI5Kns3tL8z9pRyM1+Mn2oUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH/9b9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPwe/bamM37R3iQE/wCqg09Pyg3f+zV+7cOK2XU/n+Z8DmTviZfL8j5Qr6o8kKACgAoAKACgAoAKACgAoAKADgDJ4FAH6yfsW/swHRIrT4w/EGzxqM6CTSLSUc20bDIuXU9JHB+QH7q89SMflXEedc18Hh3p9p9/L07/AHH1uW4G1q1Ra9F+p+lg44r80PpwoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAEb7p+lMD+eX9pz/k4Px9/wBhR/8A0XHX9BZL/wAi+j6fqz86xv8AvE/U8Kr3TgCgD9Zf+Cb/APyKvjj/ALCNp/6T1+UcX/xqPo/zPrsm+Cfr+h+ldfmx9MFABQBFPDDcwyW9wiyxSqVdGAZWUjBBB4II6imm07oTVz8Kf2s/2epvgt4y/tXQISfCWvSO9kRki1l5Z7ViSThRzET1TI6qc/uWRZssbR5Kj/eR3813/wA/M+Ex+D9hPmj8L/Dy/wAj5Kr608cKAPV/gv8AFvXvgv48s/GWiFpYVxFe2obat1ascvGfcfeQ/wALAH1rysxwFPG0HRnv0fZ9/wDM7MNiJUKinH5n9B3gvxloHj/wvp3i/wAMXIutN1OJZYn6HBOCrDsynIYdiK/n/EYeph6sqNVWaP0OnUjUgpx2Z/Ox8Vv+SoeMf+w1qH/o9q/ofA/7rS/wr8j85xH8afqzga7jmEb7rfQ0wP2m/wCCfP8AyRTUP+w5ff8Astfi/Ff+/R/wo+3yn+A/Vn3XXwx7oUAFAAelAH4Fftjkf8NIeMuv37Lsf+fSKv3rh7/kW0vn+bPz/Mf95n8vyPmPI9/yNfTnlhke/wCRoA/aj/gnvz8Crn/sNXv/AKLhr8W4r/35f4V+p9tlP8D5s+6a+HPeCgAoAa/3G+hprcD+fr9rP/k4rxt/18xf+iUr99yH/kXUfT9WfnmP/wB5mfO1fRHnBQB+qH/BNv8A48/Hv/Xaw/8AQJK/LOL/AI6HpL9D6zJtp/I/UCvzI+oCgAoAa6JIhjkAZWGCDyCD2Ipgfhx+19+zw3wg8Xf8JN4ZtyvhLXpSYVUfLZXLctbn0RvvRe2V7Cv27IM2+t0vZVX+8j+K7/5/efC5hg/Yz54fC/w8j44r7E8UKAPTPhF8UvEPwe8dWHjbw829rc+Xc25OEurZv9ZC/wBeqn+FgDXm4/BU8ZQdCp8n2fc6sPXlRqKpH/hz+hLwB468PfEnwjp3jPwxcC40/UohIh/iRujxuOzo2VYeor+fsVhqmGrSo1VZo/RKVWNSCnDZn8+/x2/5LZ49/wCw7qH/AKPev37LP9yof4Y/kfnmK/jz9WeU16pyBQB+xn/BOn/kk/iL/sNv/wCksFfj/Fv+90/8P6s+zyf+DL1/RH6CV+fn0IUAFAHJ+OvGOkfD/wAIat4y12QR2OkW73Eh7naOFHuxwo9zXXhsPPEVo0ae8nYyq1I04Octkfzj+OvGOsfEHxhq/jXX23X2sXDTyDtGDwka/wCzGoCj6Z71/RWFw8MPRjRp7RVv+D8z82q1HUm6kt2cnXWYhQBPBdXNo5ktZpIHIxujdkOPTKkHFS4p6NXGm1sW/wC2dZ/6CN1/4ES//FVHsofyr7kVzS7h/bOs/wDQRuv/AAIl/wDiqPZQ/lX3IOaXcP7Z1n/oI3X/AIES/wDxVHsofyr7kHNLuH9s6z/0Ebr/AMCJf/iqPZQ/lX3IOaXcP7Z1n/oI3X/gRL/8VR7KH8q+5BzS7lOe5ubp/NupnncDG6R2dsDtliTirUUtEiW29yGqEFAE1tcT2dxFd2srQTwOskciHDI6MGVgfUEAik0mrPZjTs7o/oY/Z2+LEHxj+F2l+K2ZRqUa/ZdQjH/LO7hAEnHo3Dr7Gv57zbAvB4qVLpuvR/1Y/RcHiPbUlPr19T3KvEO4KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP//X/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD8E/2z8/8ADR/izP8A04/l9ljr964f/wCRbS+f5s+AzH/eZ/L8kfLdfTHlBQAUAFABQAUAFABQAUAFABQB98fsZfs0j4iatH8TfG1ru8NaXL/ocEg4vrmMg7iD1hiPXs7fL0Vq+F4hzn6tD6tRfvvd9l/m/wAN+x7+XYL2r9rP4V+L/wAj9l1UKoUdq/GT7UWgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAEb7p+lMD+eX9pz/AJOD8ff9hR//AEXHX9BZL/yL6Pp+rPzrG/7xP1PCq904AoA/WX/gm/8A8ir44/7CNp/6T1+UcX/xqPo/zPrsm+Cfr+h+ldfmx9MFABQAUAcN8SPh94d+KHg3UvBXieATWWoxldw+/FIOUljPZ0bkH8OhruwmKqYWtGtSeq/q3ozCtSjVg4T2Z/PX8U/hr4i+EvjbUPBPiZP9Js23RzKMR3ED58uZPZh1H8LZXtX9A4HGU8XRjXpbP8H2PzuvRlRqOEjzyvROYKAPtL9jz9ohvhP4pXwZ4nnI8Ka/OgZmPy2V05CrMOwjc4WT8G7Gvi+IMp+tUvbUl+8ivvXb17HuZdjPYy9nP4X+DPmn4qOr/E/xe6MGVtZ1AgqQQQZ2wQRwR6EV9Ngf91pf4V+R5eI/iz9WcHXcc4jfdb6GmB+03/BPn/kimof9hy+/9lr8X4r/AN+j/hR9vlP8B+rPuuvhj3QoAKACgDCu/DHh2/uHu73TLWeaTG55II3Y4GBlmUk8VvGtUirKTt6shwi9Wiv/AMIb4T/6A1l/4DQ//EVXt6v8z+9i9nDsH/CG+E/+gNZf+A0P/wARR7er/M/vYezh2Niw03T9LgNtpttFaxEltkSLGuT1OFAGaxlOUneTuWklsXagYUAFADX+430NNbgfz9ftZ/8AJxXjb/r5i/8ARKV++5D/AMi6j6fqz88x/wDvMz52r6I84KAP1Q/4Jt/8efj3/rtYf+gSV+WcX/HQ9JfofWZNtP5H6gV+ZH1AUAFABQBx3j7wNoHxH8Jal4M8TW4uNP1OIxuP4lPVXQ9nRsMp7EV2YXE1MNVjWpOzRjVpRqQcJ7M/nt+L3ws8QfB3x1f+CvEAMhgPmW1zjCXVs5/dyr9Rww/hYEV/QOAx1PGUI1qfzXZ9j87xFCVGo4S/4c8yr0zlCgD7A/ZH/aIk+Dni3/hH/Ek5/wCER12QC5ySRZ3B4W5Uf3T92X1GG6qc/IZ9lP1yl7Skv3kdvNdv8vuPZy/Gexnyy+F/h5/5niPxwlin+M/jueF1kjk1vUGVlIZWUzsQQRwQR0Ir28tVsFRT/lX5HDiv482u7PLa9Q5AoA/Yz/gnT/ySfxF/2G3/APSWCvx/i3/e6f8Ah/Vn2eT/AMGXr+iP0Er8/PoQoAKAPyl/4KBfGM3V/Y/BnRZ8xWvl32qbT1kPzW8J/wB0fvGHrsr9U4Vy+yljJrfSP6v9PvPk82xN2qEfV/ofmTX6YfLhQAUAFABQAUAFABQAUAFABQAUAFAH2f8AsS/GFvh18UI/Cmqz7NE8XMlq+4/LHej5baT0G7/VE+6+lfGcSZf9YwvtoL3oa/Lqv1PbyzEezq8j2l+Z+4NfiR9yFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH//Q/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD8Hv22YfK/aO8SE/8ALSHT3/O3x/7LX7vw475bT+f5nwOZK2Jl8vyPlCvqTyQoAKACgAoAKACgAoAKACgD3T9nz4K6p8cPiDbeGoN8GlWoFxqV0o/1NsGxhT08yQ5VPfLdFrxc1zCGBw7qvd6Jd3/kup3YTDuvUUFt19D+gbQtD0nw1o1l4f0K1Sy0/ToUgghjGFjjjGFUD2Ffz/VqzqzdSo7t6tn6HCEYRUYqyRrViWFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAI33T9KYH88v7Tn/ACcH4+/7Cj/+i46/oLJf+RfR9P1Z+dY3/eJ+p4VXunAFAH6y/wDBN/8A5FXxx/2EbT/0nr8o4v8A41H0f5n12TfBP1/Q/SuvzY+mCgAoAKACgD5Z/ao/Z/tfjb4JM2lIkXinRleXTpTgeZnl7Zz/AHZMcf3WwfWvqMkzV4Kt73wS3/z+X5HlY7CKvDT4lt/kfg7dWtzY3U1lewvb3Fu7RyRyDa6OhwysD0IIwa/doyUkpRd0z4Fpp2ZXqhBQAUAFACN91voaYH7Tf8E+f+SKah/2HL7/ANlr8X4r/wB+j/hR9vlP8B+rPuuvhj3QoAKACgDkPGfj7wZ8O9JbXPG2sW2jWS5AkuHC72HO1F5Z2/2VBPtXXh8LWxE/Z0YuT8v60MalWFOPNN2R8l6l/wAFAPgXY3DW9tHq2oKpx5sFmqoR6jzJVb81FfWQ4Vx0ld8q9X/kjyZZth07av5HceBv2zfgN44vk01dbbRLmYhY01SMWoYnt5u5owfQFhntmuHE8PY+hHm5OZeWv4bm9LMcPUdr29dD6pR0kUPGwZWAIIOQQehr5dqx6o6kAUAFADX+430NNbgfz9ftZ/8AJxXjb/r5i/8ARKV++5D/AMi6j6fqz88x/wDvMz52r6I84KAP1Q/4Jt/8efj3/rtYf+gSV+WcX/HQ9JfofWZNtP5H6gV+ZH1AUAFABQAUAfNf7TfwEsfjj4Fe0s0SHxJpQefTLg4Hz4+aB2/55y9D/dbDdiD9Jk2aSwNe7+B6Nfr6o8zG4VV6dlutj8ENS02/0fUbrSNVt3tL2yleCeGQFXjljYq6MDyCCCK/eYTjOKnB3T2PgJRcW4vdFKrJCgAoAKACgD9jP+CdP/JJ/EX/AGG3/wDSWCvx/i3/AHun/h/Vn2eT/wAGXr+iP0Er8/PoQoA8/wDin8QdK+FvgDWvHesHMOlwF0jzgzTMQsUS+8jlV/HNd+Cws8ViIUIbt/cur+SOevVVKm6kuh/OT4k8Q6t4t1/UfFGvTG41HVZ3ubiQ/wAUkhycewGAo7AAdq/oqjRhRpxpU1ZJWR+bzm5ycpbsxa3MwoA/Rj9lT9kXwr8UvAM/jv4jLdiG/uGj06O3maDMMPyvKxA+bfJlV9ApPevzrPc+rYXEKhhmtFrdX1fT7vzPpcBl8KtP2lXrsfT/APwwN8Bf+eOp/wDge/8AhXy/+tGYd4/+Anq/2Vh/P7w/4YG+Av8Azx1P/wAD3/wo/wBaMw7x/wDAQ/srD+f3h/wwN8Bf+eOp/wDge/8AhR/rRmHeP/gIf2Vh/P7w/wCGBvgL/wA8dT/8D3/wo/1ozDvH/wABD+ysP5/eH/DA3wF/546n/wCB7/4Uf60Zh3j/AOAh/ZWH8/vD/hgb4C/88dT/APA9/wDCj/WjMO8f/AQ/srD+f3h/wwN8Bf8Anjqf/ge/+FH+tGYd4/8AgIf2Vh/P7z5j/ao/ZC8L/DHwBH47+G6XRi02dV1GO4mac+RKQiyrnoEcgN7HPY19Pkef1cTiPYYm2q0sra9jy8fl8KVP2lLpufnJX6MfMhQA5HeNg8bFWUggg4IIOQQexBGQfWgZ/QH+y58Xl+MXwn0/WL2YSa3pmLHUxn5jcRKMS49JkKyD3JHavwHOsB9TxcoRXuvVenb5bH6FgcR7aipPdaM+i6+dPRCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP//R/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD8NP27YPJ/aI1OQ/8ALbTtNf8AJZl/pX7lwy75dH1l+h8Jmi/2l+iPjqvrjxgoAKACgAoAKACgAoAKALNnaXV/dwWNjC1xc3MiRRRIMtJI5Cqo92JAFTJpJtuyGld2R/QH+zX8FbL4J/Di10WRVfW9QC3OqTgffuGUfID12RD5V/E9TX4HnOZPG4lzXwrSPp3+Z+hYLDKhTt1e59CV86eiFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFACN90/SmB/PL+05/ycH4+/7Cj/8AouOv6CyX/kX0fT9WfnWN/wB4n6nhVe6cAUAfrL/wTf8A+RV8cf8AYRtP/Sevyji/+NR9H+Z9dk3wT9f0P0rr82PpgoAKACgAoACAeDQB+Xf7c/7OjSrcfG/wbbDdGF/tq3jXllGFW7AA6qOJfYB+zGv0/hrN7WwNZ/4X+n+X3Hy2aYP/AJfwXr/mflnX6ifKBQAUAFACN91voaYH7Tf8E+f+SKah/wBhy+/9lr8X4r/36P8AhR9vlP8AAfqz7rr4Y90KACgDiviN430v4beBtb8dawC1potrJcMikBpGUYSNc/xOxCj3NduEw0sTXhQhvJ2Ma1VUqbqS2R/PL8Tfib4w+LPiu58WeMrw3F1KSsUSk+TbRZ4ihU52ovT1Y/M2Sa/oPB4KjhKSpUVp+L82fnVevOtPnm/+AefV6BzAeQQeh60Afoj+xD+0Nr2jeKrL4N+J7trzRdW3JprTMWa0uACwiVjk+VJ0CfwtyOCRX55xJlNOdJ4ykrSW9uq7+qPpMsxklNUZvR7eR+vwOQCO9fkR9gLQAUANf7jfQ01uB/P1+1n/AMnFeNv+vmL/ANEpX77kP/Iuo+n6s/PMf/vMz52r6I84KAP1Q/4Jt/8AHn49/wCu1h/6BJX5Zxf8dD0l+h9Zk20/kfqBX5kfUBQAUAFABQAUAfmp+3J+zn/bFlN8avBltm/skH9s28a8zW6DAugAMl4hgSesYz1Xn9I4azfkksFWej+F9n2+fTz9T5rNMHzL28N+v+Z+TVfrB8gFABQAUAFAH7Gf8E6f+ST+Iv8AsNv/AOksFfj/ABb/AL3T/wAP6s+zyf8Agy9f0R+glfn59CFAH4+/t9/GL/hI/Ftp8JtFn3af4eIuL/a2VkvpF+RDg4/cxn8GcjqK/XuFsv8AZ0ni5rWWi9P+C/wR8dm2I5pqjHZb+p+eNfoR84FAHa/DjwNqnxK8c6J4F0fi41i5SEvjIii+9LKR6Rxhm/DHeuLGYmOGoTrz2iv+GXzZvRpOrUjTj1P6PvDPhzSvCPh7TvC+hxeTp+lW8VtAnGRHEoUZwBknGSe5JNfznWrTrVJVZvVu7+Z+lQgoRUY7I3awLCgAoAKACgAoAKAMfxDoWm+J9Dv/AA7rMIuLDU4JLaeNujRSqVYfkePetqVWVKaqQdmndETipRcXsz+cb4pfD7VPhZ4/1rwHq2Wl0qcpHIRgTQOA8Mo9nQg+xyO1f0XgsXHFYeFeHVfc+qPzavRdKpKnLocBXec4UAfVv7H3xh/4VV8V7az1S48rQfE5SxvNzYSORm/0ec8gfI52knorNXynEGX/AFvCOUV78NV+q/rsevl2I9lWs9np/kfvEDkZr8KPvRaACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA/9L9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPxR/wCCgVsYfjvBPji40Wzb8UluF/wr9q4Vd8BbtJ/kj4fNl/tF/JfqfDtfbHhhQAUAFABQAUAFABQAUAfoN+wV8Gl8UeL7j4qa5Bv07w6xisVcZWS+deX54PkoePRiK+B4nzH2NFYWD96e/p/wT6HKsNzz9rLZfn/wD9igABgV+On2YUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFACN90/SmB/PL+05/ycH4+/wCwo/8A6Ljr+gsl/wCRfR9P1Z+dY3/eJ+p4VXunAFAH6y/8E3/+RV8cf9hG0/8ASevyji/+NR9H+Z9dk3wT9f0P0rr82PpgoAKACgAoAKAIbi3gu4JLW6jWWGVSjo4DKysMFWB4II4IPUVSbTuhNX0Pwj/au/Z7n+CfjP7focTN4T1x2eybBIt5er2rH1X70fqnHVTX7nkWbLG0eWo/3kd/Pz/z8/U+Dx+E9hO8fhf9WPlGvqzyAoAKAEb7rfQ0wP2m/wCCfP8AyRTUP+w5ff8Astfi/Ff+/R/wo+3yn+A/Vn3XXwx7oUAFAHzX+154d1TxN+zz4vsdIR5bi3hhvPLTkvHZzpPIAO52ISB6gV9JkNaFLMKUp7Xa+9WPMzCDnhpqP9WPwD47HI7EdCOxH1r98Pz4KACgD3/9lvw7qXiT4++DINORm+wXy30zD+CC2BZ2J7dh9TivAzutGngKrl1Vl6s9HAwcsRC3R3P6EFzgZ4r+fj9DFoAKAGv9xvoaa3A/n6/az/5OK8bf9fMX/olK/fch/wCRdR9P1Z+eY/8A3mZ87V9EecFAH6of8E2/+PPx7/12sP8A0CSvyzi/46HpL9D6zJtp/I/UCvzI+oCgAoAKACgAoAjlijmjaKVQ6OCCrDIIPBBB7GmnZ3A/DX9rr9niT4PeLj4j8N25HhHXpWNvtHy2dw2We2J6BTy0Xtlf4Rn9wyDNljKPsqj/AHkd/Nd/8/vPhcwwnsZ88fhf4eX+R8e19eeKFABQAUAfsZ/wTp/5JP4i/wCw2/8A6SwV+P8AFv8AvdP/AA/qz7PJ/wCDL1/RH6CV+fn0J5F8cvijp/wg+GuseNbsq9xbR+XaQsf9ddy/LCmO43fM3+yDXr5bgpYzExoLZ7+S6nHiq6o0nN/0z+dnUtRv9Y1G61fVJ2ub29leeeVzlnkkYszEnk5Jr+hoQjCKhBWS0R+cyk5Nye5SqyQoA/VX/gnt8JBBZap8Y9WixJcl9O03cP8AlkhBuJR/vOPLBHZW/vV+V8V4+8o4OD21fr0X3an1mUYeydZ+i/U/TuvzM+oCgAoAKACgAoAKACgAoA/N7/goH8If7X8O2Hxf0mEG50TbZ6jtHLWkr/upW/65SMQf9lyf4a/RuFcfyVJYOb0lqvXqvmvyPms2w/NFVo9N/Q/JDnvwa/Wj5AKAD9PpQB+8X7IHxiHxW+FNrDqk4fXvD22wvgTlnCL+5mPf94mMn+8rV+E5/l/1TFPlXuy1X6r5M++y/E+2oq+60Z9XV8qesFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQB//T/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD8dv8AgotaGL4p+G73HFxo7Ln3iuD/APF1+w8JSvhKi7S/Q+Nzhfvovy/U/Pivvz50KACgAoAKACgAoAKAL2mabfazqVpo+mRGe8vpUghRRktJIwVQB9TUSlGEXOT0W5STbsj+jf4QfDzTvhX8OtE8D6cARpsAWaQf8tbhvmmkPrucnGe2BX865hjJYvEzry6vT06fgfpGHoqlSVNdD0uvMOoKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgBG5BFAH4u/Hr9mT46+LfjN4w8TeHfCU97pmpX7TW86z2qiSMog3APMrDkHqBX7Nlec4Glg6VOpVSklqrP/ACPicVgsROtOUYaN+X+Z5J/wyF+0f/0JFx/4E2f/AMfr1/7fy3/n8vuf+Ryf2fif5Py/zD/hkL9o/wD6Ei4/8CbP/wCP0f2/lv8Az+X3P/IP7PxP8n5f5n6K/sP/AAp+IPws8PeK7Px/o0mjzahe20sCySRSeYiQ7WI8p3AweOcV+d8SY7D4qpSlh58ySd9+/mfSZZQqUoyVRWuz7pr4Y90KACgAoAKACgAoA4T4lfDzw98U/Bmo+CPE0W+z1BMB1x5kMq8xyxk9HRsEH8OhruweLqYWtGvSeq/Hy+ZhWpRqwcJbM/FHXP2M/wBoTS9YvdNsPC76pbW0rxxXcE9skU6A/LIqvMrKGH8JGQcj3P7VS4hy+cFKVSzfRp6eWx8RPLsQpNKN/u/zMr/hkL9o/wD6Ei4/8CbP/wCP1r/b+W/8/l9z/wAiP7PxP8n5f5h/wyF+0f8A9CRcf+BNn/8AH6P7fy3/AJ/L7n/kH9n4n+T8v8xG/ZC/aPKkf8IRccg/8vNn/wDH6P7fy3/n8vuf+Qf2fif5Py/zP1I/Yz+HnjP4afCy80Dxzpb6TqEuq3dwsTvG5MUm3a2Ymdeceufavy7iHF0cTi1UoSuuVL+rn1WXUp0qTjUVndn1vXyZ64UAFADXRZEZHAZWBBBGQQexoA/Lb49fsG31xqV34q+CzxeVcMZZNHmby9jNkt9llPy7Sekb4A6KwHFfqGV8URUVSxvT7S/Vfqj5XFZU23Oh93+R8Jat8CPjRody1pqXgfWEkU7f3dnJOpPs8IdT+Br7qnmmCqK8a0fvS/Ox4MsJXi7OD+47bwR+yd8ePG95HBB4Yn0e2Y4a61QfZYkHqVb9630VOfUda4sTnuAoLWopPtHX/gG9LAYib+G3qfrp+z3+zh4W+AujTraS/wBqa9qIUXmoOgQsF5EUSc7IlPOMkk8sTxj8kzbN6uPmrq0Vsv1fmfX4TBww8dNW92fR1fOnpBQAUANcEowHcGmtwPxt/aL/AGavjj40+NnirxR4Y8KT3+l388bwTrPbKrqIlUkB5lYcjuBX7DlGcYGjgadKrVtJLVWff0Pi8Zgq868pwjdP0/zPFf8AhkL9o/8A6Ei4/wDAmz/+P17f9v5b/wA/l9z/AMji/s/E/wAn5f5h/wAMhftH/wDQkXH/AIE2f/x+j+38t/5/L7n/AJB/Z+J/k/L/ADP0F/Yc+EfxG+Fdt4vj+IGiSaO2pSWbW4kkhk8wRq4bHlO+MEjrivz7iXH4fFSpPDz5rJ338u59FlmHqUlP2itex9818Ge+FABQAUAFABQAUAcZ8QPAnh74leEtR8GeKIPtGn6lGUcDh0bqsiH+F0OCp9a7MLiamGqxrUnZoxq0o1YOE9mfif4k/Yw+P+j69f6ZpPhuTWLK2mZIL2Ge2RLiLPyuFeZWUkdQRwc9q/aqPEWAnTjKdTlb3Vnp+B8PPLcRGTUY3Xy/zMT/AIZC/aP/AOhIuP8AwJs//j9b/wBv5b/z+X3P/Ij+z8T/ACfl/mH/AAyF+0f/ANCRcf8AgTZ//H6P7fy3/n8vuf8AkH9n4n+T8v8AMP8AhkL9o/8A6Ei4/wDAmz/+P0f2/lv/AD+X3P8AyD+z8T/J+X+Z+mf7E/w08c/C/wCHetaN490l9IvbrVWuI45JIpC0Rt4UDZidx95SOTnjpX5pxHjKGKxEJ0JcyUbde77n0+W0alKk41FZ3PsuvjT2j80P2y/h98e/i94tsNC8G+Fbi88MaHH5iTLPbItzdzD532vMrYjXCDI65Ir9K4exWAwlKVStVSnLyei+7qfM5jSxFaajCPur03+8+MP+GQv2j/8AoSLj/wACbP8A+P19n/b+W/8AP5fc/wDI8T+z8T/J+X+Yf8MhftH/APQkXH/gTZ//AB+j+38t/wCfy+5/5B/Z+J/k/L/Mu6b+xz+0Re6ja2dz4SmsYbiWON7iS4tWSFHYBpGCzEkIuWwBk4xUT4gy6MXJVbvtZ6/gOOXYltJxt93+Z+5PgrwlpPgPwnpPg7Q08ux0i2jtoh3IjXBY+7HknuTX4diK869WVae8nc+7p01TgoR2R1FcxqFABQAUAFABQAUAFABQBjeItB03xRoWoeHNZhFxYanBJbTxt0aOVSrD8jW1KrKlONSDs07oicVKLjLZn4Z+Iv2M/j7pWvahpuj+GJtVsLWeSO3u0ntVW4hU/JJteZWBZcZBAwc9sV+40eIcBOnGU6lm1qrPR9tj4SeW4hSajG6+X+Zjf8MhftH/APQkXH/gTZ//AB+tv7fy3/n8vuf+RH9n4n+T8v8AMP8AhkL9o/8A6Ei4/wDAmz/+P0f2/lv/AD+X3P8AyD+z8T/J+X+Z9FfswfCT9o74NfFKz1jUfB10mg6mPsepAXFowWFjlZtqzkkxPg8DJGRXzudY/LsZhXCNVcy1Wj+7bqelgcPiaNVNw0e+3+Z+ulfkh9eFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQB//9T9/KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPyl/wCCkdiRrHgXUwOHgv4Cfo0Lj+tfq3CEv3daPmn+Z8lnK96D9f0PzJr9KPmAoAKACgAoAKACgAoA+2/2D/hyvjD4wN4svYt9j4QgNyMjKm7nzHB+Kje491FfF8TYv2OD9knrN2+S1f8Al8z28ro89fne0fz6H7a1+Jn3IUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAf/V/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD81v8AgpBYb/CvgrVMf6rULmHP/XSAt/7JX6TwhL97Wj5L8z5nOY+7B+bPyYr9XPkQoAKACgAoAKACgAwTwOtAH7efsI+BY/DHwQt/Ec0e278U3Mt6SevkRsYYB9Nqlx/v1+KcUYn2uN9ktoK3zer/AMvkfcZVS5aHN3PtSvij3AoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA//1v38oAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA+BP+Ch1oJ/hDo1zjJtdZiOfQPBKn9a++4TlbFzj3j+qPn83X7mL8/wBGfjVX7EfFhQAUAFABQAUAFAFzT9Pu9Vv7bS7BS9zeSpBEo5JklYKoH1JFTKSinKWyGk27I/pf8G+HbTwh4T0bwrYAC30i0gtE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ACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAEPQ0wPwN/bG/wCTjvF31s//AEQK/eeHv+RbS+f5n59mH+9T+X5H2V/wTc/5FTxz/wBhGz/9I0r47i/+LR9H+Z7mT/BP1X5H6U1+bH0oUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAf//U/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgBCMjFAH5G/tN/sh+ONQ+K41z4U6Ob/AE3xS7TTIjLHHZXY5lMjNgLHJ98H+9kDrX67k2fUFhOTFTtKGnqulvNbHx+Oy+o63NSV0/wZ7d8Ev2DvCPhJ4PEHxTmTxLqsZDrZqCNPiYf3gQGnP+9hP9k9a8TMuKKtW9PCLlXfr/wPzO7DZVCHvVtX26f8E/QCGGG2hjt7dFjiiUKiKAqqqjAAA4AA6AV+fNtu7PoUraIlpDCgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAQ9DTA/A79sZWP7R3i7Ck82fY/88BX7xw9/wAi2l8/zPz7MP8Aep/L8j7K/wCCboI8KeOcgj/iY2fUY/5dEr47i/8Ai0fR/me5k/wT9V+R+lFfm59KFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAH//V/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAMUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAYF54W8O6hcveXum2s80mNzyW8TsccDLMpJ/Ot41qkVZSdvVkOEW7tF3TdH0rR0kj0u0htFlILCGNIwxAwCQgGePWonUlPWTuOMVHZGlWZQUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAf//W/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//X/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//Q/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//R/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//S/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//T/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//U/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//V/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//W/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//X/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//Q/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//R/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//S/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//T/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//U/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//V/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//W/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//X/fygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgD//Z';

    // ============================================
    // INIT
    // ============================================
    document.addEventListener('DOMContentLoaded', async () => {
      // IndexedDB initialisieren
      try {
        await initAudioDB();
      } catch (e) {
        console.warn('IndexedDB nicht verf√ºgbar:', e);
      }
      
      // Projekt laden
      initProjekt();
      
      // Audio-URLs wiederherstellen
      try {
        await restoreAudioUrls();
      } catch (e) {
        console.warn('Audio-Wiederherstellung fehlgeschlagen:', e);
      }
      
      render();
      updateStorageInfo();
      
      // Cloud-Auth pr√ºfen
      checkCloudAuth();
      
      // Format-Indikator bei Cursor-Bewegung aktualisieren
      document.addEventListener('selectionchange', updateFormatIndicator);
    });
    
    // Format der aktuellen Zeile erkennen und anzeigen
    function updateFormatIndicator() {
      const indicator = document.getElementById('format-indicator');
      if (!indicator) return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      // Finde das aktuelle Element
      let node = selection.anchorNode;
      if (!node) return;
      
      // Zum Element-Node navigieren
      while (node && node.nodeType !== 1) {
        node = node.parentNode;
      }
      if (!node) return;
      
      // Format-Klasse finden
      let currentFormat = 'standard';
      let checkNode = node;
      
      while (checkNode && checkNode.id !== 'text-editor') {
        const classList = checkNode.classList;
        if (classList) {
          if (classList.contains('format-dialog')) currentFormat = 'dialog';
          else if (classList.contains('format-regieanweisung')) currentFormat = 'regieanweisung';
          else if (classList.contains('format-szene-titel')) currentFormat = 'szeneTitel';
          else if (classList.contains('format-akt-titel')) currentFormat = 'aktTitel';
          else if (classList.contains('format-lied')) currentFormat = 'lied';
          else if (classList.contains('format-vers')) currentFormat = 'vers';
          else if (classList.contains('format-pause')) currentFormat = 'pause';
          else if (classList.contains('format-standard')) currentFormat = 'standard';
          
          if (currentFormat !== 'standard' || classList.contains('format-standard')) break;
        }
        checkNode = checkNode.parentNode;
      }
      
      // Alle Format-Items aktualisieren
      const items = indicator.querySelectorAll('.format-item');
      items.forEach(item => {
        if (item.dataset.format === currentFormat) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
    }
  </script>
</body>
</html>
