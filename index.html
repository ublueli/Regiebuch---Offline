<!DOCTYPE html>
<html lang="de-CH">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>N!NA-Rebu v2.4 - Regiebuch mit KI N!NA-Rebu v2.4 - Regiebuch mit KI, Cloud & NINA-Exchange v2.0 NINA-Exchange v2.0 (Stand-alone)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <!-- Supabase entfernt f√ºr Stand-alone Version -->
  <script>
    // PDF.js Worker konfigurieren
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    
    :root {
      --nina-primary: #3b82f6;
      --nina-primary-dark: #1e3a5f;
      --nina-success: #10b981;
      --nina-warning: #f97316;
      --nina-danger: #ef4444;
      --nina-purple: #8b5cf6;
      --nina-blue: #4169b2;
    }
    
    /* ============================================ */
    /* KI-ASSISTENT PANEL                         */
    /* ============================================ */
    .ki-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 400px;
      height: 100vh;
      background: white;
      box-shadow: -4px 0 20px rgba(0,0,0,0.15);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
    }
    .ki-panel.open { right: 0; }
    
    .ki-panel-header {
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      padding: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .ki-panel-header h3 { margin: 0; font-size: 1.1rem; display: flex; align-items: center; gap: 0.5rem; }
    .ki-panel-header button { background: rgba(255,255,255,0.2); border: none; color: white; width: 28px; height: 28px; border-radius: 4px; cursor: pointer; }
    .ki-panel-header button:hover { background: rgba(255,255,255,0.3); }
    
    .ki-messages {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .ki-message {
      padding: 0.75rem 1rem;
      border-radius: 12px;
      max-width: 90%;
      line-height: 1.5;
      font-size: 0.9rem;
    }
    .ki-message.user {
      background: #3b82f6;
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .ki-message.assistant {
      background: #f3f4f6;
      color: #1f2937;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .ki-message.assistant strong { color: #3b82f6; }
    .ki-message.loading {
      background: #f3f4f6;
      color: #9ca3af;
    }
    .ki-message p { margin: 0.25rem 0; }
    .ki-message p:first-child { margin-top: 0; }
    .ki-message p:last-child { margin-bottom: 0; }
    
    .ki-input-area {
      padding: 1rem;
      border-top: 1px solid #e5e7eb;
      background: #f9fafb;
    }
    .ki-input-area textarea {
      width: 100%;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      padding: 0.75rem;
      font-size: 0.9rem;
      resize: none;
      min-height: 60px;
    }
    .ki-input-area textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.15); }
    .ki-input-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .ki-toggle-btn {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(59,130,246,0.4);
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .ki-toggle-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(59,130,246,0.5);
    }
    .ki-toggle-btn.has-key { background: linear-gradient(135deg, #10b981, #3b82f6); }
    .ki-toggle-btn.panel-open { opacity: 0; pointer-events: none; }
    
    .typing-indicator {
      display: inline-block;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }
    
    /* API Key Status */
    .api-key-row { display: flex; gap: 0.5rem; align-items: center; }
    .api-test-btn { padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; cursor: pointer; border: 1px solid #d1d5db; background: white; transition: all 0.15s; }
    .api-test-btn:hover { border-color: #3b82f6; color: #3b82f6; }
    .api-test-btn.testing { background: #fef3c7; border-color: #f59e0b; color: #92400e; }
    .api-test-btn.success { background: #d1fae5; border-color: #10b981; color: #065f46; }
    .api-test-btn.error { background: #fee2e2; border-color: #ef4444; color: #991b1b; }
    .api-status { padding: 0.5rem; border-radius: 0.375rem; font-size: 0.875rem; margin-top: 0.5rem; }
    .api-status.success { background: #d1fae5; color: #065f46; }
    .api-status.error { background: #fee2e2; color: #991b1b; }
    .api-status.neutral { background: #f3f4f6; color: #6b7280; }

    /* Sidebar */
    .sidebar { background: linear-gradient(180deg, #1e3a5f 0%, #0f172a 100%); }
    .nav-section { color: #60a5fa; font-size: 0.65rem; font-weight: 700; letter-spacing: 0.1em; text-transform: uppercase; }
    .nav-item { transition: all 0.15s; border-left: 3px solid transparent; cursor: pointer; }
    .nav-item:hover { background: rgba(255,255,255,0.1); }
    .nav-item.active { background: rgba(59, 130, 246, 0.3); border-left-color: #3b82f6; }
    
    /* Buttons */
    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.15s; border: none; }
    .btn-primary { background: #3b82f6; color: white; }
    .btn-primary:hover { background: #2563eb; }
    .btn-success { background: #10b981; color: white; }
    .btn-success:hover { background: #059669; }
    .btn-danger { background: #ef4444; color: white; }
    .btn-danger:hover { background: #dc2626; }
    .btn-orange { background: #f97316; color: white; }
    .btn-orange:hover { background: #ea580c; }
    .btn-purple { background: #8b5cf6; color: white; }
    .btn-purple:hover { background: #7c3aed; }
    .btn-outline { background: white; border: 1px solid #d1d5db; color: #374151; }
    .btn-outline:hover { background: #f3f4f6; border-color: #3b82f6; color: #3b82f6; }
    .btn-outline-light { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #93c5fd; }
    .btn-outline-light:hover { background: rgba(255,255,255,0.1); }
    .btn-sm { padding: 0.375rem 0.75rem; font-size: 0.75rem; }
    .btn-xs { padding: 0.25rem 0.5rem; font-size: 0.65rem; }
    
    /* Form Elements */
    input, select, textarea { padding: 0.5rem 0.75rem; border: 1px solid #d1d5db; border-radius: 0.5rem; font-size: 0.875rem; transition: all 0.15s; width: 100%; background: white; }
    input:focus, select:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.15); }
    
    /* Cards */
    .card { background: white; border-radius: 0.75rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border: 1px solid #e5e7eb; }
    
    /* ============================================ */
    /* SCHREIBFL√ÑCHE - Word-√§hnlicher Editor       */
    /* ============================================ */
    .editor-container { 
      background: white; 
      border: 1px solid #e5e7eb; 
      border-radius: 0.5rem; 
      min-height: 500px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    
    .editor-content {
      padding: 2.5rem 3rem;
      min-height: 500px;
      outline: none;
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 12pt;
      line-height: 1.6;
      color: #1f2937;
    }
    
    /* WICHTIG: Alle importierten Styles √ºberschreiben! */
    .editor-content * {
      font-family: inherit !important;
      font-size: inherit !important;
      line-height: inherit !important;
      background: transparent !important;
    }
    
    /* Farbe nur f√ºr Elemente ohne Format-Klasse */
    .editor-content *:not([class*="format-"]):not(.figur-name):not(.dialog-text):not(.cue-marker):not(.cue-badge) {
      color: inherit !important;
    }
    
    /* Nur explizite Formatklassen d√ºrfen Styles √§ndern */
    .editor-content strong, 
    .editor-content b { font-weight: bold !important; }
    .editor-content em, 
    .editor-content i { font-style: italic !important; }
    .editor-content u { text-decoration: underline !important; }
    .editor-content s, 
    .editor-content .gestrichen { text-decoration: line-through !important; }
    
    .editor-content:empty:before {
      content: 'Hier schreiben oder Text einf√ºgen...';
      color: #9ca3af;
      font-style: italic;
    }
    
    /* ============================================ */
    /* FORMATVORLAGEN                              */
    /* ============================================ */
    
    /* Standard */
    .format-standard {
      margin: 0.25rem 0;
      text-indent: 0;
    }
    
    /* Dialog: FIGURENNAME: Text - mit Tab-Einr√ºckung (v1.2) */
    .format-dialog {
      margin: 0.3rem 0;
      display: grid;
      grid-template-columns: 7rem 1fr;
      gap: 0.75rem;
      align-items: baseline;
    }
    
    .format-dialog .figur-name {
      font-weight: bold;
      justify-self: start;
      white-space: nowrap;
    }
    
    .format-dialog .dialog-text {
      font-weight: normal;
    }
    
    /* Regieanweisung: (kursiv, einger√ºckt) */
    .format-regieanweisung {
      font-style: italic !important;
      color: #4b5563 !important;
      margin: 0.5rem 0;
      margin-left: 9.5rem;
    }
    
    /* Szenen-Titel: fett, gr√∂sser, mit Linie */
    .format-szene-titel {
      font-weight: bold !important;
      font-size: 14pt !important;
      margin-top: 2rem;
      margin-bottom: 1rem;
      padding-bottom: 0.25rem;
      border-bottom: 2px solid #d1d5db;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
    }
    
    /* Lied: kursiv, stark einger√ºckt, blau */
    .format-lied {
      font-style: italic !important;
      margin: 0.15rem 0;
      margin-left: 4rem;
      color: #1e40af !important;
    }
    
    /* Versma√ü: Monospace, einger√ºckt */
    .format-vers {
      margin: 0.15rem 0;
      margin-left: 3rem;
      font-family: 'Courier New', Courier, monospace !important;
      white-space: pre-wrap;
    }
    
    /* Akt-/Struktur-Titel (v1.4) */
    .format-akt-titel {
      font-size: 1.5rem !important;
      font-weight: bold;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      margin: 2rem 0 1.5rem;
      padding: 1rem 0;
      border-top: 2px solid #374151;
      border-bottom: 2px solid #374151;
      color: #1f2937;
    }
    
    /* Pause-Markierung (v1.4) */
    .format-pause {
      font-size: 1.1rem;
      font-weight: bold;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.3em;
      margin: 2rem 0;
      padding: 0.75rem 0;
      color: #6b7280;
      background: #f3f4f6;
      border-radius: 4px;
    }
    
    /* Gestrichen (v1.2) */
    .format-gestrichen {
      text-decoration: line-through;
      color: #9ca3af;
      background: #fef2f2;
    }
    
    /* NEU: Erg√§nzung (v1.4) */
    .format-ergaenzung {
      background: #dbeafe;
      color: #1e40af;
      border-bottom: 2px solid #3b82f6;
    }
    
    /* Musik-Einsatz (v1.5) üéº */
    .format-musik {
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 12pt;
      font-style: italic !important;
      margin: 0.5rem 0;
      margin-left: 9.5rem;
      padding: 6pt 10pt;
      line-height: 1.4;
      color: #7c3aed !important;
      border-left: 3px solid #7c3aed;
      background: #f5f3ff !important;
    }
    
    /* Sound-Effekt (v1.5) üîä */
    .format-sound {
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 12pt;
      font-style: italic !important;
      margin: 0.5rem 0;
      margin-left: 9.5rem;
      padding: 6pt 10pt;
      line-height: 1.4;
      color: #059669 !important;
      border-left: 3px solid #059669;
      background: #ecfdf5 !important;
    }
    
    /* Regie-Notiz (v1.5) üìù - wird NICHT gedruckt */
    .format-notiz {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
      font-size: 10pt !important;
      font-style: italic !important;
      color: #92400e !important;
      background: #fef3c7 !important;
      padding: 8pt 12pt;
      border-left: 3px solid #fbbf24;
      margin: 0.75rem 0;
      border-radius: 0 4px 4px 0;
    }
    @media print {
      .format-notiz { display: none !important; }
    }
    
    /* Nebentext (v1.5) üìÑ */
    .format-nebentext {
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 10pt !important;
      font-style: italic !important;
      margin: 0.5rem 0;
      line-height: 1.5;
      color: #6b7280 !important;
    }
    
    /* Ansicht: Streichungen ausblenden */
    .hide-streichungen .format-gestrichen {
      display: none;
    }
    
    /* Ansicht: √Ñnderungsmarkierungen ausblenden (f√ºr Schauspieler-Ansicht) */
    .hide-aenderungen .format-gestrichen {
      display: none;
    }
    .hide-aenderungen .format-ergaenzung {
      background: transparent;
      color: inherit;
      border-bottom: none;
    }
    
    /* Auto-Diff Darstellung (√Ñnderungen-Ansicht) */
    .diff-deleted {
      text-decoration: line-through;
      color: #dc2626;
      background: #fef2f2;
      padding: 1px 2px;
      border-radius: 2px;
    }
    .diff-inserted {
      color: #1d4ed8;
      background: #dbeafe;
      padding: 1px 2px;
      border-radius: 2px;
      border-bottom: 2px solid #3b82f6;
    }
    .diff-info-bar {
      background: #f0fdf4;
      border: 1px solid #bbf7d0;
      border-radius: 8px;
      padding: 10px 16px;
      margin-bottom: 16px;
      font-size: 12px;
      color: #166534;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .diff-info-bar select {
      font-size: 12px;
      padding: 2px 6px;
      border: 1px solid #bbf7d0;
      border-radius: 4px;
      background: white;
    }
    .diff-no-ref {
      background: #fef3c7;
      border: 1px solid #fde68a;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #92400e;
      font-size: 13px;
    }
    .diff-no-changes {
      background: #f0fdf4;
      border: 1px solid #bbf7d0;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #166534;
      font-size: 13px;
    }
    .diff-view .format-dialog,
    .diff-view .format-regieanweisung,
    .diff-view .format-standard,
    .diff-view .format-szenen-titel,
    .diff-view .format-akt-titel,
    .diff-view .format-musik,
    .diff-view .format-sound,
    .diff-view .format-nebentext,
    .diff-view .format-notiz {
      /* Beibehalten der Grundformatierung in Diff-Ansicht */
    }
    .diff-stats {
      font-size: 11px;
      color: #6b7280;
      margin-left: auto;
    }
    .diff-stats .del-count { color: #dc2626; font-weight: 600; }
    .diff-stats .ins-count { color: #1d4ed8; font-weight: 600; }
    @media print {
      .diff-deleted { display: none !important; }
      .diff-inserted { background: transparent; color: inherit; border-bottom: none; }
      .diff-info-bar { display: none !important; }
    }
    
    /* Ansicht: Cues ausblenden (f√ºr Schauspieler-Ansicht) */
    .hide-cues .cue-inline-marker {
      display: none;
    }
    
    /* Inline Cue-Marker im Text */
    .cue-inline-marker {
      display: inline-flex;
      align-items: center;
      gap: 2px;
      padding: 1px 6px;
      margin: 0 2px;
      border-radius: 3px;
      font-size: 0.7rem;
      font-weight: 600;
      vertical-align: middle;
      cursor: pointer;
    }
    .cue-inline-marker.cue-lx { background: #fef3c7; color: #92400e; border: 1px solid #f59e0b; }
    .cue-inline-marker.cue-q { background: #dbeafe; color: #1e40af; border: 1px solid #3b82f6; }
    .cue-inline-marker.cue-v { background: #ede9fe; color: #5b21b6; border: 1px solid #8b5cf6; }
    .cue-inline-marker:hover { transform: scale(1.05); }
    
    /* ============================================ */
    /* TOOLBAR                                      */
    /* ============================================ */
    .toolbar { 
      background: #f8fafc; 
      border-bottom: 1px solid #e5e7eb; 
      padding: 0.5rem 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: nowrap;
      align-items: center;
      overflow-x: auto;
    }
    
    .toolbar-group {
      display: flex;
      gap: 0.25rem;
      align-items: center;
    }
    
    .toolbar-btn {
      padding: 0.375rem 0.625rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background: white;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.15s;
      min-width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .toolbar-btn:hover {
      background: #e5e7eb;
      border-color: #9ca3af;
    }
    
    /* Icon-only buttons with label on hover */
    .toolbar-btn.toolbar-icon-only {
      position: relative;
    }
    .toolbar-btn.toolbar-icon-only .toolbar-label {
      display: none;
      margin-left: 0.25rem;
    }
    .toolbar-btn.toolbar-icon-only:hover .toolbar-label {
      display: inline;
    }
    
    .toolbar-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    
    .toolbar-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .toolbar-divider {
      width: 1px;
      height: 24px;
      background: #d1d5db;
      margin: 0 0.5rem;
    }
    
    .format-select {
      padding: 0.375rem 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background: white;
      font-size: 0.8rem;
      width: 150px;
      cursor: pointer;
    }
    
    .format-select:hover {
      border-color: #3b82f6;
    }
    
    /* ============================================ */
    /* SZENEN-LISTE                                 */
    /* ============================================ */
    .szene-item {
      padding: 0.6rem 0.75rem;
      border-radius: 0.375rem;
      cursor: pointer;
      transition: all 0.15s;
      border-left: 3px solid transparent;
      margin-bottom: 0.25rem;
    }
    
    .szene-item:hover {
      background: #f3f4f6;
    }
    
    .szene-item.active {
      background: #dbeafe;
      border-left-color: #3b82f6;
    }
    
    /* ============================================ */
    /* CUE-BADGES                                   */
    /* ============================================ */
    .cue-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.125rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    
    .cue-lx { background: #fef3c7; color: #92400e; }
    .cue-q { background: #d1fae5; color: #065f46; }
    .cue-v { background: #e0e7ff; color: #3730a3; }
    .cue-r { background: #fce7f3; color: #9d174d; }
    .cue-u { background: #fed7aa; color: #9a3412; }
    
    /* ============================================ */
    /* MODAL                                        */
    /* ============================================ */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .modal-content {
      background: white;
      border-radius: 0.75rem;
      max-width: 600px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
    }
    
    .modal-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      background: white;
      z-index: 10;
    }
    
    .modal-body {
      padding: 1.5rem;
    }
    
    /* ============================================ */
    /* DETAILS PANEL                                */
    /* ============================================ */
    .details-panel {
      border-left: 1px solid #e5e7eb;
      background: #fafafa;
    }
    
    .detail-section {
      border-bottom: 1px solid #e5e7eb;
      padding: 1rem;
    }
    
    .detail-section:last-child {
      border-bottom: none;
    }
    
    .detail-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #6b7280;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }
    
    /* Format-Indikator */
    .format-item {
      color: #6b7280;
      transition: all 0.15s ease;
    }
    .format-item.active {
      background: #1e40af;
      color: white;
      font-weight: 600;
    }
    .format-item.active span {
      color: #93c5fd;
    }
    
    /* ============================================ */
    /* FIGUREN BADGES                               */
    /* ============================================ */
    .figur-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.25rem 0.5rem;
      background: #eff6ff;
      border: 1px solid #bfdbfe;
      border-radius: 9999px;
      font-size: 0.75rem;
      color: #1e40af;
    }
    
    .figur-avatar {
      width: 1.5rem;
      height: 1.5rem;
      border-radius: 9999px;
      background: #3b82f6;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: 600;
    }
    
    /* Checkbox */
    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.375rem 0;
      cursor: pointer;
    }
    
    .checkbox-item:hover {
      background: #f3f4f6;
      margin: 0 -0.5rem;
      padding-left: 0.5rem;
      padding-right: 0.5rem;
      border-radius: 0.25rem;
    }
    
    .checkbox-item input[type="checkbox"] {
      width: auto;
      margin: 0;
    }
    
    /* Quick Insert Bar */
    .quick-insert-bar {
      background: linear-gradient(to right, #f0f9ff, #eff6ff);
      border-bottom: 1px solid #bfdbfe;
      padding: 0.5rem 1rem;
      display: flex;
      gap: 0.375rem;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .quick-insert-btn {
      padding: 0.25rem 0.5rem;
      background: white;
      border: 1px solid #bfdbfe;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 500;
      color: #1e40af;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .quick-insert-btn:hover {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    
    /* Kost√ºme Cards */
    .kostuem-card {
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      overflow: hidden;
      background: white;
    }
    
    .kostuem-card:hover {
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }
    
    /* Text-Clamp f√ºr Zusammenfassungen */
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    /* Lightbox */
    .lightbox-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: zoom-out;
    }
    
    .lightbox-content {
      max-width: 90vw;
      max-height: 90vh;
      object-fit: contain;
    }
    
    .lightbox-close {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      font-size: 2rem;
      cursor: pointer;
      z-index: 1001;
    }
    
    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      color: white;
      font-size: 3rem;
      cursor: pointer;
      padding: 20px;
      user-select: none;
    }
    
    .lightbox-nav.prev { left: 10px; }
    .lightbox-nav.next { right: 10px; }
    
    .lightbox-counter {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 0.875rem;
    }
    
    /* Thumbnail Grid */
    .image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 8px;
    }
    
    .image-thumb {
      aspect-ratio: 1;
      object-fit: cover;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    .image-thumb:hover {
      transform: scale(1.05);
    }
    
    .add-image-btn {
      aspect-ratio: 1;
      border: 2px dashed #d1d5db;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #9ca3af;
      font-size: 1.5rem;
    }
    
    .add-image-btn:hover {
      border-color: #9333ea;
      color: #9333ea;
    }
  </style>
  
  <!-- ============================================ -->
  <!-- GOOGLE DRIVE MODULE (wiederverwendbar)       -->
  <!-- ============================================ -->
  <script>
    const GDRIVE_CLIENT_ID = '442649097645-159rgo1mpu0ptdkiq8up8tdc8dl5mvo2.apps.googleusercontent.com';
    const GDRIVE_SCOPE = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email';
    const GDRIVE_API = 'https://www.googleapis.com/drive/v3';
    const GDRIVE_UPLOAD_API = 'https://www.googleapis.com/upload/drive/v3';
    
    // State
    let gdriveToken = null;
    let gdriveUser = null;
    let gdriveFolderId = localStorage.getItem('nina_gdrive_folder_id') || null;
    let gdriveFolderName = localStorage.getItem('nina_gdrive_folder_name') || null;
    let gdriveTokenClient = null;
    
    // ---- AUTH ----
    function gdriveInitAuth() {
      if (!window.google?.accounts?.oauth2) {
        console.warn('Google Identity Services not loaded yet');
        return false;
      }
      gdriveTokenClient = google.accounts.oauth2.initTokenClient({
        client_id: GDRIVE_CLIENT_ID,
        scope: GDRIVE_SCOPE,
        callback: (response) => {
          if (response.error) {
            console.error('GDrive auth error:', response);
            alert('‚ùå Google-Anmeldung fehlgeschlagen: ' + (response.error_description || response.error));
            return;
          }
          gdriveToken = response.access_token;
          console.log('GDrive: Token erhalten');
          
          // User-Info holen (non-blocking)
          fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
            headers: { 'Authorization': 'Bearer ' + gdriveToken }
          }).then(r => {
            if (r.ok) return r.json();
            throw new Error('Status ' + r.status);
          }).then(info => {
            gdriveUser = { name: info.name || '', email: info.email || '', picture: info.picture || '' };
            localStorage.setItem('nina_gdrive_user', JSON.stringify(gdriveUser));
            console.log('GDrive: User info geladen:', gdriveUser.email);
            if (typeof render === 'function') render();
          }).catch((err) => {
            console.warn('GDrive: Userinfo nicht verf√ºgbar:', err);
            gdriveUser = { name: '', email: 'Verbunden', picture: '' };
          });
          
          // Sofort UI aktualisieren (nicht auf Userinfo warten)
          if (typeof render === 'function') render();
          if (typeof gdriveOnConnected === 'function') gdriveOnConnected();
        }
      });
      // Restore cached user info
      try {
        const cached = localStorage.getItem('nina_gdrive_user');
        if (cached) gdriveUser = JSON.parse(cached);
      } catch(e) {}
      return true;
    }
    
    function gdriveSignIn() {
      if (!gdriveTokenClient) {
        if (!gdriveInitAuth()) {
          alert('‚è≥ Google-Dienst wird noch geladen. Bitte kurz warten und nochmal versuchen.');
          return;
        }
      }
      gdriveTokenClient.requestAccessToken();
    }
    
    function gdriveSignOut() {
      if (gdriveToken) {
        google.accounts.oauth2.revoke(gdriveToken);
      }
      gdriveToken = null;
      gdriveUser = null;
      localStorage.removeItem('nina_gdrive_user');
      if (typeof render === 'function') render();
    }
    
    function gdriveIsConnected() {
      return !!gdriveToken;
    }
    
    // ---- API HELPERS ----
    async function gdriveFetch(url, options = {}) {
      if (!gdriveToken) throw new Error('Nicht angemeldet');
      const resp = await fetch(url, {
        ...options,
        headers: { 'Authorization': 'Bearer ' + gdriveToken, ...(options.headers || {}) }
      });
      if (resp.status === 401) {
        gdriveToken = null;
        gdriveUser = null;
        localStorage.removeItem('nina_gdrive_user');
        throw new Error('Sitzung abgelaufen ‚Äì bitte erneut anmelden');
      }
      if (!resp.ok) {
        const err = await resp.text();
        throw new Error('Drive-Fehler: ' + resp.status + ' ' + err);
      }
      return resp;
    }
    
    // ---- FOLDER ----
    async function gdriveCreateFolder(name, parentId) {
      const metadata = {
        name: name,
        mimeType: 'application/vnd.google-apps.folder',
        ...(parentId ? { parents: [parentId] } : {})
      };
      const resp = await gdriveFetch(GDRIVE_API + '/files', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(metadata)
      });
      return await resp.json();
    }
    
    async function gdriveListFolders() {
      try {
        const q = "mimeType='application/vnd.google-apps.folder' and trashed=false";
        const resp = await gdriveFetch(GDRIVE_API + `/files?q=${encodeURIComponent(q)}&fields=files(id,name,modifiedTime)&orderBy=modifiedTime desc&pageSize=20`);
        const data = await resp.json();
        console.log('GDrive: Ordner gefunden:', data.files?.length || 0);
        return data.files || [];
      } catch(e) {
        console.warn('GDrive: Ordner-Suche fehlgeschlagen:', e);
        return [];
      }
    }
    
    async function gdriveListProjectFolders(parentId) {
      const q = `mimeType='application/vnd.google-apps.folder' and '${parentId}' in parents and trashed=false`;
      const resp = await gdriveFetch(GDRIVE_API + `/files?q=${encodeURIComponent(q)}&fields=files(id,name,modifiedTime)&orderBy=name`);
      return (await resp.json()).files || [];
    }
    
    async function gdriveSetFolder(id, name) {
      gdriveFolderId = id;
      gdriveFolderName = name;
      localStorage.setItem('nina_gdrive_folder_id', id);
      localStorage.setItem('nina_gdrive_folder_name', name);
      if (typeof render === 'function') render();
    }
    
    // ---- FILE OPERATIONS ----
    async function gdriveSaveFile(fileName, jsonData, folderId) {
      const targetFolder = folderId || gdriveFolderId;
      if (!targetFolder) throw new Error('Kein Ordner ausgew√§hlt');
      
      // Check if file already exists in folder
      const q = `name='${fileName}' and '${targetFolder}' in parents and trashed=false`;
      const searchResp = await gdriveFetch(GDRIVE_API + `/files?q=${encodeURIComponent(q)}&fields=files(id)`);
      const existing = (await searchResp.json()).files || [];
      
      const content = JSON.stringify(jsonData, null, 2);
      const blob = new Blob([content], { type: 'application/json' });
      
      if (existing.length > 0) {
        // Update existing file
        const fileId = existing[0].id;
        const resp = await gdriveFetch(GDRIVE_UPLOAD_API + `/files/${fileId}?uploadType=media`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: blob
        });
        return await resp.json();
      } else {
        // Create new file (multipart upload)
        const metadata = { name: fileName, parents: [targetFolder] };
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', blob);
        
        const resp = await fetch(GDRIVE_UPLOAD_API + '/files?uploadType=multipart', {
          method: 'POST',
          headers: { 'Authorization': 'Bearer ' + gdriveToken },
          body: form
        });
        if (!resp.ok) throw new Error('Upload fehlgeschlagen: ' + resp.status);
        return await resp.json();
      }
    }
    
    async function gdriveListFiles(folderId) {
      const targetFolder = folderId || gdriveFolderId;
      if (!targetFolder) return [];
      const q = `'${targetFolder}' in parents and trashed=false and mimeType='application/json'`;
      const resp = await gdriveFetch(GDRIVE_API + `/files?q=${encodeURIComponent(q)}&fields=files(id,name,modifiedTime,size)&orderBy=modifiedTime desc`);
      return (await resp.json()).files || [];
    }
    
    async function gdriveLoadFile(fileId) {
      const resp = await gdriveFetch(GDRIVE_API + `/files/${fileId}?alt=media`);
      return await resp.json();
    }
    
    // Init on load
    window.addEventListener('load', () => {
      setTimeout(() => gdriveInitAuth(), 500);
    });
  </script>
</head>
<body class="bg-gray-100">
  <div id="app"></div>

  <script>
    // ============================================
    // N!NA STORAGE KEYS
    // ============================================
    const STORAGE_PREFIX = 'nina_';
    const KEYS = {
      projekte: STORAGE_PREFIX + 'projekte',
      aktuellesProjekt: STORAGE_PREFIX + 'aktuelles_projekt',
      textbuch: (id) => `${STORAGE_PREFIX}textbuch_${id}`,
      fassungen: (id) => `${STORAGE_PREFIX}fassungen_${id}`,
      cues: (id) => `${STORAGE_PREFIX}cues_${id}`,
      requisiten: (id) => `${STORAGE_PREFIX}requisiten_${id}`,
      kostueme: (id) => `${STORAGE_PREFIX}kostueme_${id}`,
      medien: (id) => `${STORAGE_PREFIX}medien_${id}`,
      figuren: (id) => `${STORAGE_PREFIX}figuren_${id}`,
      szenen: (id) => `${STORAGE_PREFIX}szenen_${id}`,
      buehne: (id) => `${STORAGE_PREFIX}buehne_${id}`,
      projektMeta: (id) => `${STORAGE_PREFIX}projekt_meta_${id}`,
      // v3.0
      konzept: (id) => `${STORAGE_PREFIX}konzept_${id}`,
      beziehungen: (id) => `${STORAGE_PREFIX}beziehungen_${id}`,
      rechercheMaterial: (id) => `${STORAGE_PREFIX}recherche_material_${id}`,
      musikkonzept: (id) => `${STORAGE_PREFIX}musikkonzept_${id}`,
      ensemble: (id) => `${STORAGE_PREFIX}ensemble_${id}`,
      team: (id) => `${STORAGE_PREFIX}team_${id}`,
      probeplan: (id) => `${STORAGE_PREFIX}probeplan_${id}`,
    };

    // ============================================
    // SUPABASE CLOUD - DEAKTIVIERT (Stand-alone Version)
    // ============================================
    const SUPABASE_URL = '';
    const SUPABASE_ANON_KEY = '';
    // Dummy-DB f√ºr Stand-alone Version
    const db = { 
      from: () => ({ 
        select: () => ({ eq: () => ({ single: () => Promise.resolve({ data: null, error: null }), order: () => Promise.resolve({ data: [], error: null }) }), order: () => Promise.resolve({ data: [], error: null }) }),
        insert: () => Promise.resolve({ data: null, error: null }), 
        upsert: () => Promise.resolve({ data: null, error: null }), 
        update: () => ({ eq: () => Promise.resolve({ error: null }) }), 
        delete: () => ({ eq: () => Promise.resolve({ error: null }) })
      }), 
      auth: { 
        getSession: () => Promise.resolve({ data: { session: null } }),
        getUser: () => Promise.resolve({ data: { user: null }, error: null }), 
        signInWithPassword: () => Promise.resolve({ error: { message: 'Cloud deaktiviert in Stand-alone Version' } }), 
        signUp: () => Promise.resolve({ error: { message: 'Cloud deaktiviert' } }), 
        signOut: () => Promise.resolve({}) 
      } 
    };
    
    let cloudUser = null;
    let cloudProjects = [];
    let currentCloudProjectId = null;
    let isCloudMode = false;

    // ============================================
    // UTILITIES
    // ============================================
    const save = (key, data) => localStorage.setItem(key, JSON.stringify(data));
    const load = (key, def = null) => { try { return JSON.parse(localStorage.getItem(key)) || def; } catch { return def; } };
    const genId = () => 'id_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    // HTML-Zeichen escapen f√ºr sichere Anzeige in Attributen
    const escapeHtml = (str) => {
      if (!str) return '';
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    };
    
    // v1.2: Datum MIT Uhrzeit formatieren
    const formatDate = (d) => {
      const date = new Date(d);
      return date.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit', year: 'numeric' });
    };
    
    const formatDateTime = (d) => {
      const date = new Date(d);
      const datePart = date.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit', year: 'numeric' });
      const timePart = date.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
      return `${datePart}, ${timePart}`;
    };

    // ============================================
    // INDEXEDDB F√úR MEDIEN-SPEICHERUNG (v1.3)
    // ============================================
    let mediaBD = null;
    const MEDIA_DB_NAME = 'NinaRebuMediaDB';
    const AUDIO_STORE_NAME = 'audioFiles';
    const IMAGE_STORE_NAME = 'imageFiles';
    
    // IndexedDB initialisieren
    function initAudioDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(MEDIA_DB_NAME, 2); // Version 2 f√ºr Images
        
        request.onerror = () => {
          console.error('IndexedDB Fehler:', request.error);
          reject(request.error);
        };
        
        request.onsuccess = () => {
          mediaBD = request.result;
          console.log('‚úÖ Medien-Datenbank bereit');
          resolve(mediaBD);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(AUDIO_STORE_NAME)) {
            db.createObjectStore(AUDIO_STORE_NAME, { keyPath: 'id' });
            console.log('‚úÖ Audio-Speicher erstellt');
          }
          if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
            db.createObjectStore(IMAGE_STORE_NAME, { keyPath: 'id' });
            console.log('‚úÖ Bild-Speicher erstellt');
          }
        };
      });
    }
    
    // Audio-Datei speichern
    async function saveAudioToDB(mediumId, file) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const transaction = mediaBD.transaction([AUDIO_STORE_NAME], 'readwrite');
          const store = transaction.objectStore(AUDIO_STORE_NAME);
          
          const audioData = {
            id: mediumId,
            data: reader.result, // ArrayBuffer
            type: file.type,
            name: file.name,
            size: file.size,
            savedAt: new Date().toISOString()
          };
          
          const request = store.put(audioData);
          request.onsuccess = () => {
            console.log('‚úÖ Audio gespeichert:', file.name, '(' + (file.size / 1024 / 1024).toFixed(2) + ' MB)');
            resolve(audioData);
          };
          request.onerror = () => reject(request.error);
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsArrayBuffer(file);
      });
    }
    
    // Audio-Datei laden
    async function loadAudioFromDB(mediumId) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const transaction = mediaBD.transaction([AUDIO_STORE_NAME], 'readonly');
        const store = transaction.objectStore(AUDIO_STORE_NAME);
        const request = store.get(mediumId);
        
        request.onsuccess = () => {
          if (request.result) {
            const blob = new Blob([request.result.data], { type: request.result.type });
            const url = URL.createObjectURL(blob);
            resolve({ url, data: request.result });
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Audio-Datei l√∂schen
    async function deleteAudioFromDB(mediumId) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const transaction = mediaBD.transaction([AUDIO_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(AUDIO_STORE_NAME);
        const request = store.delete(mediumId);
        
        request.onsuccess = () => {
          console.log('‚úÖ Audio gel√∂scht:', mediumId);
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Alle Audio-URLs beim Start wiederherstellen
    async function restoreAudioUrls() {
      if (!mediaBD) await initAudioDB();
      
      for (const medium of state.medien) {
        if (medium.type === 'audio' && medium.source === 'local') {
          try {
            const result = await loadAudioFromDB(medium.id);
            if (result) {
              medium.localFileUrl = result.url;
              medium.audioStored = true;
              console.log('‚úÖ Audio wiederhergestellt:', medium.name);
            }
          } catch (e) {
            console.warn('Audio nicht gefunden:', medium.name);
          }
        }
      }
    }
    
    // Speicherplatz-Info
    async function getAudioStorageInfo() {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve) => {
        const transaction = mediaBD.transaction([AUDIO_STORE_NAME], 'readonly');
        const store = transaction.objectStore(AUDIO_STORE_NAME);
        const request = store.getAll();
        
        request.onsuccess = () => {
          const files = request.result || [];
          const totalSize = files.reduce((sum, f) => sum + (f.size || 0), 0);
          resolve({
            count: files.length,
            totalSize: totalSize,
            totalSizeMB: (totalSize / 1024 / 1024).toFixed(1)
          });
        };
        request.onerror = () => resolve({ count: 0, totalSize: 0, totalSizeMB: '0' });
      });
    }
    
    // ============================================
    // BILD-SPEICHERUNG (f√ºr Kost√ºme/Masken)
    // ============================================
    
    // Bild in IndexedDB speichern
    async function saveImageToDB(imageId, file) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const transaction = mediaBD.transaction([IMAGE_STORE_NAME], 'readwrite');
          const store = transaction.objectStore(IMAGE_STORE_NAME);
          
          const imageData = {
            id: imageId,
            data: reader.result, // ArrayBuffer
            type: file.type,
            name: file.name,
            size: file.size,
            savedAt: new Date().toISOString()
          };
          
          const request = store.put(imageData);
          request.onsuccess = () => {
            console.log('‚úÖ Bild gespeichert:', file.name, '(' + (file.size / 1024).toFixed(0) + ' KB)');
            resolve(imageData);
          };
          request.onerror = () => reject(request.error);
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsArrayBuffer(file);
      });
    }
    
    // Bild aus IndexedDB laden
    async function loadImageFromDB(imageId) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const transaction = mediaBD.transaction([IMAGE_STORE_NAME], 'readonly');
        const store = transaction.objectStore(IMAGE_STORE_NAME);
        const request = store.get(imageId);
        
        request.onsuccess = () => {
          if (request.result) {
            const blob = new Blob([request.result.data], { type: request.result.type });
            const url = URL.createObjectURL(blob);
            resolve({ url, data: request.result });
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Bild aus IndexedDB l√∂schen
    async function deleteImageFromDB(imageId) {
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve, reject) => {
        const transaction = mediaBD.transaction([IMAGE_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(IMAGE_STORE_NAME);
        const request = store.delete(imageId);
        
        request.onsuccess = () => {
          console.log('‚úÖ Bild gel√∂scht:', imageId);
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    // Tempor√§rer Cache f√ºr geladene Bild-URLs
    const imageUrlCache = {};
    
    // Bild-URL aus Cache oder DB laden
    async function getImageUrl(imageId) {
      if (!imageId) return null;
      if (imageUrlCache[imageId]) return imageUrlCache[imageId];
      
      try {
        const result = await loadImageFromDB(imageId);
        if (result) {
          imageUrlCache[imageId] = result.url;
          return result.url;
        }
      } catch (e) {
        console.warn('Bild nicht gefunden:', imageId);
      }
      return null;
    }

    // ============================================
    // FORMATVORLAGEN DEFINITION
    // ============================================
    const FORMATVORLAGEN = {
      standard: { 
        name: 'Standard', 
        class: 'format-standard', 
        description: 'Normaler Text',
        icon: '¬∂'
      },
      dialog: { 
        name: 'Dialog', 
        class: 'format-dialog', 
        description: 'FIGUR: Sprechtext',
        icon: 'üí¨'
      },
      regieanweisung: { 
        name: 'Regieanweisung', 
        class: 'format-regieanweisung', 
        description: '(Handlungsanweisung)',
        icon: 'üé¨'
      },
      szeneTitel: { 
        name: 'Szenen-Titel', 
        class: 'format-szene-titel', 
        description: '1.1 √úberschrift',
        icon: 'üîç'
      },
      lied: { 
        name: 'Lied', 
        class: 'format-lied', 
        description: 'Gesungener Text',
        icon: 'üéµ'
      },
      vers: { 
        name: 'Versma√ü', 
        class: 'format-vers', 
        description: 'Gebundene Sprache',
        icon: 'üìú'
      },
      aktTitel: { 
        name: 'Akt-/Struktur-Titel', 
        class: 'format-akt-titel', 
        description: 'ERSTER AKT',
        icon: 'üèõÔ∏è'
      },
      pause: { 
        name: 'Pause', 
        class: 'format-pause', 
        description: '‚Äî PAUSE ‚Äî',
        icon: '‚è∏Ô∏è'
      },
      musik: { 
        name: 'Musik', 
        class: 'format-musik', 
        description: 'Musik-Einsatz',
        icon: 'üéº'
      },
      sound: { 
        name: 'Sound', 
        class: 'format-sound', 
        description: 'Sound-Effekt',
        icon: 'üîä'
      },
      notiz: { 
        name: 'Notiz', 
        class: 'format-notiz', 
        description: 'Regie-Notiz (nicht drucken)',
        icon: 'üìù'
      },
      nebentext: { 
        name: 'Nebentext', 
        class: 'format-nebentext', 
        description: 'Erl√§uternder Text',
        icon: 'üìÑ'
      },
    };

    // ============================================
    // CUE-TYPEN DEFINITION
    // ============================================
    const CUE_TYPEN = {
      lx: { name: 'Licht', prefix: 'LX', class: 'cue-lx', icon: 'üí°' },
      q: { name: 'Ton', prefix: 'Q', class: 'cue-q', icon: 'üîä' },
      v: { name: 'Video', prefix: 'V', class: 'cue-v', icon: 'üì∫' },
      r: { name: 'Requisite', prefix: 'R', class: 'cue-r', icon: 'üé≠' },
      u: { name: 'Umbau', prefix: 'U', class: 'cue-u', icon: 'üîÑ' },
    };
    
    // Gruppen/Akte: Nur noch frei editierbare Liste in state.projektMeta.eigeneGruppen
    // z.B. ['Erster Akt', 'Zweiter Akt', 'Dritter Akt'] oder ['Teil 1']

    // ============================================
    // APP STATE
    // ============================================
    let state = {
      currentView: 'textbuch',
      projektId: null,
      projektMeta: {
        titel: 'Neues Projekt',
        untertitel: '',
        autor: '',
        tagline: '',
        logline: '',
        copyright: '',
        titelbild: '',
        fassung: 'Arbeitsfassung',
        fassungsDatum: new Date().toISOString(),
        // v2.0: Flexibles Struktur-System (nur freie Gruppen)
        eigeneGruppen: ['Erster Akt'], // Frei editierbare Liste der Gruppen/Akte
        premiere: '',
        spielort: ''
      },
      figuren: [],
      szenen: [],
      aktiveSzene: null,
      textbuch: {},
      cues: [],
      fassungen: [],
      requisiten: [],
      kostueme: [],
      medien: [],
      buehne: [], // v1.3: B√ºhnenbilder/Pl√§ne
      // v3.0: Konzept-Modul
      konzept: {
        treatment: [],        // [{id, titel, text, sortOrder}] ‚Äì Geschichte in Prosa, kapitelweise
        fundament: {          // Kern der Inszenierung
          kern: '',           // Was ist der Kern?
          logline: '',        // (referenziert projektMeta.logline)
          unaussprechliches: '', // Was nicht gesagt werden kann
          emotionalerBogen: '', // Emotionaler Bogen der Inszenierung
          konflikt: ''        // Zentraler Konflikt
        },
        werte: [],            // [{id, wert1, wert2, wert3, wert4, figurIds}] ‚Äì Wertequadrate
        motive: []            // [{id, name, bedeutung, betrachtungen}]
      },
      // v3.0: Figurenbeziehungen
      beziehungen: [],        // [{id, figur1Id, figur2Id, art, beschreibung, richtung}]
      // v3.0: Recherche-Material (Werkbank-Import + eigene)
      rechercheMaterial: [],   // [{id, typ:'text'|'bild'|'link'|'idee', titel, inhalt, url, bildData, szeneIds[], tags[]}]
      // v3.0: Musikkonzept
      musikkonzept: {
        text: '',              // Freitext: Konzept-Beschreibung
        stuecke: []            // [{id, titel, kuenstler, szeneIds[], einsatz, notizen}]
      },
      // v3.0: Team & Proben (read-only, aus Propla-Import)
      ensemble: [],            // [{id, name, email, telefon, adresse, rolleIds[], notizen}]
      team: [],                // [{id, name, funktion, email, telefon, adresse, notizen}]
      probeplan: [],           // [{id, datum, zeit, ort, szeneIds[], figurIds[], typ, notizen}]
      // v3.0: UI state
      medienTab: 'audio',       // 'audio' | 'material' | 'musik'
      konzeptTab: 'treatment',  // 'treatment' | 'fundament' | 'werte' | 'motive'
      teamProbenTab: 'ensemble', // 'ensemble' | 'team' | 'probeplan'
      dirty: false, // true wenn ungespeicherte √Ñnderungen seit letztem Export/Backup
      referenzFassungId: null, // ID der Fassung f√ºr √Ñnderungsverfolgung
      showGestrichenes: true,
      selectedFormat: 'dialog',
      // v1.4: Textansicht (schauspieler, technik, aenderungen)
      textAnsicht: 'technik',
      // v1.2: Undo-History
      undoStack: [],
      redoStack: [],
      // Modals
      showImportModal: false,
      showExportModal: false,
      showFassungModal: false,
      showFigurModal: false,
      showCueModal: false,
      showSzeneModal: false,
      showKostuemModal: false,
      showMediumModal: false,
      showRequisitenModal: false,
      showBuehneModal: false,
      showLightbox: false,
      showProjektModal: false,
      showProjektListeModal: false,
      editingFigur: null,
      editingCue: null,
      editingSzene: null,
      editingKostuem: null,
      editingMedium: null,
      editingRequisit: null,
      editingBuehne: null,
      // Lightbox
      lightboxImages: [],
      lightboxIndex: 0,
      // v1.3: Medien-Player State
      currentlyPlaying: null,
      playbackRate: 1.0,
      // v1.7: KI-Assistent
      kiPanelOpen: false,
      kiMessages: [],
      kiInput: '',
      kiLoading: false,
      // v2.0: Cloud
      showCloudModal: false,
    };
    
    // KI State (au√üerhalb von state wegen localStorage)
    let apiKeyStatus = 'idle'; // 'idle', 'testing', 'success', 'error'
    let apiKeyError = '';

    // ============================================
    // CLOUD FUNKTIONEN
    // ============================================
    
    // URL-Parameter auslesen (f√ºr Dashboard-Integration)
    function getUrlProjectId() {
      const params = new URLSearchParams(window.location.search);
      return params.get('project');
    }
    
    async function checkCloudAuth() {
      const { data: { session } } = await db.auth.getSession();
      if (session?.user) {
        cloudUser = session.user;
        isCloudMode = true;
        await loadCloudProjects();
        
        // Automatisch Projekt √∂ffnen wenn in URL angegeben
        const urlProjectId = getUrlProjectId();
        if (urlProjectId) {
          const cloudProject = cloudProjects.find(p => p.id === urlProjectId);
          if (cloudProject) {
            console.log('Auto-opening project from URL:', urlProjectId);
            await selectCloudProject(urlProjectId);
          }
        }
      }
      render();
    }
    
    async function cloudLogin(email, password) {
      const { data, error } = await db.auth.signInWithPassword({ email, password });
      if (error) { alert('Login fehlgeschlagen: ' + error.message); return; }
      cloudUser = data.user;
      isCloudMode = true;
      await loadCloudProjects();
      render();
    }
    
    async function cloudRegister(email, password, name) {
      const { data, error } = await db.auth.signUp({ 
        email, 
        password,
        options: { data: { full_name: name } }
      });
      if (error) { alert('Registrierung fehlgeschlagen: ' + error.message); return; }
      alert('Registrierung erfolgreich! Bitte E-Mail best√§tigen.');
    }
    
    async function cloudLogout() {
      await db.auth.signOut();
      cloudUser = null;
      cloudProjects = [];
      currentCloudProjectId = null;
      isCloudMode = false;
      render();
    }
    
    async function loadCloudProjects() {
      const { data, error } = await db.from('projects')
        .select('*')
        .or('app_type.eq.rebu,app_type.is.null')
        .order('updated_at', { ascending: false });
      if (!error && data) {
        cloudProjects = data.map(p => ({
          id: p.id,
          name: p.name,
          subtitle: p.subtitle,
          author: p.author,
          premiere: p.premiere_date,
          venue: p.venue
        }));
      }
    }
    
    async function selectCloudProject(cloudId) {
      currentCloudProjectId = cloudId;
      const cloudProject = cloudProjects.find(p => p.id === cloudId);
      if (!cloudProject) return;
      
      const localId = 'cloud_' + cloudId;
      let projekte = load(KEYS.projekte, []);
      let existingIdx = projekte.findIndex(p => p.id === localId);
      
      const projektData = { id: localId, cloudId: cloudId, name: cloudProject.name };
      
      // Pr√ºfe ob lokale Daten bereits existieren
      const existingMeta = load(KEYS.projektMeta(localId), null);
      const existingSzenen = load(KEYS.szenen(localId), null);
      const hasLocalData = existingMeta !== null || (existingSzenen !== null && existingSzenen.length > 0);
      
      if (existingIdx >= 0) {
        projekte[existingIdx] = projektData;
      } else {
        projekte.push(projektData);
      }
      save(KEYS.projekte, projekte);
      
      state.projektId = localId;
      save(KEYS.aktuellesProjekt, localId);
      
      // Nur beim ERSTEN Mal von Cloud syncen (wenn keine lokalen Daten)
      if (!hasLocalData) {
        console.log('Erstes Mal: Sync von Cloud...');
        await syncFromCloud(cloudId, localId);
      } else {
        console.log('Lokale Daten vorhanden, kein Sync n√∂tig');
        // IMMER den Projektnamen aus der Cloud √ºbernehmen
        const meta = load(KEYS.projektMeta(localId), {});
        meta.titel = cloudProject.name || meta.titel || 'Unbenannt';
        save(KEYS.projektMeta(localId), meta);
      }
      
      loadProjektDaten();
      render();
    }
    
    async function syncFromCloud(cloudId, localId) {
      console.log('syncFromCloud', cloudId, localId);
      
      // Projekt-Meta laden
      const { data: project, error: projectError } = await db.from('projects').select('*').eq('id', cloudId).single();
      if (project && !projectError) {
        const meta = {
          titel: project.name || 'Unbenannt',
          untertitel: project.subtitle || '',
          autor: project.author || '',
          tagline: project.tagline || '',
          logline: project.logline || '',
          copyright: project.copyright || '',
          titelbild: project.cover_image || '',
          fassung: project.version_name || 'Arbeitsfassung',
          fassungsDatum: project.version_date || new Date().toISOString(),
          strukturTyp: project.structure_type || 'akte',
          premiere: project.premiere_date || '',
          spielort: project.venue || ''
        };
        save(KEYS.projektMeta(localId), meta);
      }
      
      // Figuren laden
      const { data: figures, error: figuresError } = await db.from('figures').select('*').eq('project_id', cloudId).order('sort_order');
      if (!figuresError) {
        save(KEYS.figuren(localId), (figures || []).map(f => ({
          id: f.id, name: f.name || '', kuerzel: f.abbreviation || '',
          beschreibung: f.description || '', want: f.want || '', need: f.need || ''
        })));
      }
      
      // Szenen laden
      const { data: scenes, error: scenesError } = await db.from('scenes').select('*').eq('project_id', cloudId).order('sort_order');
      if (!scenesError) {
        const szenen = (scenes || []).map(s => ({
          id: s.id, nummer: s.number || '', titel: s.title || s.name || '',
          ort: s.location || '', zeit: s.time_of_day || '',
          gruppe: s.scene_group || '', zusammenfassung: s.summary || '',
          figuren: []
        }));
        
        // Scene-Figures laden (optional - bei Fehler ignorieren)
        const { data: sceneFigures } = await db.from('scene_figures').select('*').eq('project_id', cloudId);
        if (sceneFigures) {
          sceneFigures.forEach(sf => {
            const szene = szenen.find(s => s.id === sf.scene_id);
            if (szene && sf.figure_id) {
              if (!szene.figuren) szene.figuren = [];
              szene.figuren.push(sf.figure_id);
            }
          });
        }
        save(KEYS.szenen(localId), szenen);
      }
      
      // Textbuch laden (optional)
      const { data: sceneTexts } = await db.from('scene_texts').select('*').eq('project_id', cloudId);
      if (sceneTexts && sceneTexts.length > 0) {
        const textbuch = {};
        sceneTexts.forEach(st => { textbuch[st.scene_id] = st.content || ''; });
        save(KEYS.textbuch(localId), textbuch);
      }
      
      // Cues laden (optional - bei Fehler ignorieren)
      const { data: cues, error: cuesError } = await db.from('cues').select('*').eq('project_id', cloudId).order('cue_number');
      if (!cuesError && cues) {
        save(KEYS.cues(localId), cues.map(c => ({
          id: c.id, typ: c.cue_type || 'lx', nummer: c.cue_number || 0,
          szeneId: c.scene_id, beschreibung: c.description || '',
          dauer: c.duration || '', ankerText: c.anchor_text || ''
        })));
      }
      
      // Kost√ºme laden (optional)
      const { data: costumes } = await db.from('costumes').select('*').eq('project_id', cloudId);
      if (costumes) {
        const { data: costumeScenes } = await db.from('costume_scenes').select('*');
        save(KEYS.kostueme(localId), costumes.map(k => ({
          id: k.id, name: k.name || '', figur: k.figure_id,
          beschreibung: k.description || '', notizen: k.notes || '',
          szenen: (costumeScenes || []).filter(cs => cs.costume_id === k.id).map(cs => cs.scene_id)
        })));
      }
      
      // Requisiten laden (optional)
      const { data: props } = await db.from('props').select('*').eq('project_id', cloudId);
      if (props) {
        const { data: propScenes } = await db.from('prop_scenes').select('*');
        save(KEYS.requisiten(localId), props.map(r => ({
          id: r.id, name: r.name || '', beschreibung: r.description || '',
          szenen: (propScenes || []).filter(ps => ps.prop_id === r.id).map(ps => ps.scene_id)
        })));
      }
      
      // Medien laden (optional)
      const { data: media } = await db.from('media').select('*').eq('project_id', cloudId);
      if (media) {
        save(KEYS.medien(localId), media.map(m => ({
          id: m.id, name: m.name || '', typ: m.media_type || '',
          url: m.url || '', beschreibung: m.description || ''
        })));
      }
      
      // B√ºhnenbilder laden (optional)
      const { data: stageDesigns } = await db.from('stage_designs').select('*').eq('project_id', cloudId);
      if (stageDesigns) {
        save(KEYS.buehne(localId), stageDesigns.map(b => ({
          id: b.id, name: b.name || '', bild: b.image_url || '', beschreibung: b.description || ''
        })));
      }
      
      // Fassungen laden (optional)
      const { data: versions } = await db.from('script_versions').select('*').eq('project_id', cloudId).order('created_at', { ascending: false });
      if (versions) {
        save(KEYS.fassungen(localId), versions.map(v => ({
          id: v.id, name: v.name || '', datum: v.version_date || v.created_at,
          textbuch: v.content || {}
        })));
      }
    }
    
    async function createCloudProject() {
      const name = document.getElementById('cloud_projekt_name')?.value?.trim();
      if (!name) return alert('Projektname erforderlich!');
      if (!cloudUser) return alert('Bitte zuerst einloggen!');
      
      const { data: projectData, error } = await db.from('projects').insert({
        name: name,
        app_type: 'rebu',
        created_by: cloudUser.id,
        status: 'active'
      }).select().single();
      
      if (error) { alert('Fehler: ' + error.message); return; }
      
      await db.from('project_members').insert({
        project_id: projectData.id,
        user_id: cloudUser.id,
        role: 'owner'
      });
      
      await loadCloudProjects();
      await selectCloudProject(projectData.id);
    }
    
    async function uploadProjectToCloud() {
      if (!cloudUser) return alert('Bitte zuerst einloggen!');
      if (!state.projektId) return alert('Kein Projekt ausgew√§hlt!');
      
      const meta = state.projektMeta;
      const localId = state.projektId;
      
      // Projekt erstellen
      const { data: projectData, error } = await db.from('projects').insert({
        name: meta.titel || 'Unbenannt',
        subtitle: meta.untertitel || '',
        author: meta.autor || '',
        tagline: meta.tagline || '',
        logline: meta.logline || '',
        copyright: meta.copyright || '',
        cover_image: meta.titelbild || '',
        version_name: meta.fassung || 'Arbeitsfassung',
        version_date: meta.fassungsDatum || new Date().toISOString(),
        structure_type: meta.strukturTyp || 'akte',
        premiere_date: meta.premiere || null,
        venue: meta.spielort || '',
        app_type: 'rebu',
        created_by: cloudUser.id,
        status: 'active'
      }).select().single();
      
      if (error) { alert('Fehler: ' + error.message); return; }
      
      const cloudId = projectData.id;
      
      await db.from('project_members').insert({
        project_id: cloudId,
        user_id: cloudUser.id,
        role: 'owner'
      });
      
      // Figuren hochladen
      const figuren = load(KEYS.figuren(localId), []);
      console.log('Uploading', figuren.length, 'figures');
      for (let i = 0; i < figuren.length; i++) {
        const f = figuren[i];
        const { error } = await db.from('figures').insert({
          project_id: cloudId, name: f.name || '', abbreviation: f.kuerzel || '',
          description: f.beschreibung || '', want: f.want || '', need: f.need || '',
          sort_order: i, color: '#3b82f6'
        });
        if (error) console.error('Figure upload error:', error);
      }
      
      // Szenen hochladen
      const szenen = load(KEYS.szenen(localId), []);
      console.log('Uploading', szenen.length, 'scenes');
      for (let i = 0; i < szenen.length; i++) {
        const s = szenen[i];
        const { error } = await db.from('scenes').insert({
          project_id: cloudId, name: s.titel || '', number: s.nummer || '',
          title: s.titel || '', location: s.ort || '', time_of_day: s.zeit || '',
          scene_group: s.gruppe || '', summary: s.zusammenfassung || '',
          sort_order: i
        });
        if (error) console.error('Scene upload error:', error);
      }
      
      // Scene-Figures hochladen
      const { data: cloudScenes } = await db.from('scenes').select('id, number').eq('project_id', cloudId);
      const { data: cloudFigures } = await db.from('figures').select('id, name').eq('project_id', cloudId);
      
      for (const s of szenen) {
        const cloudScene = cloudScenes?.find(cs => cs.number === s.nummer);
        if (cloudScene && s.figuren) {
          for (const figurId of s.figuren) {
            const localFigur = figuren.find(f => f.id === figurId);
            const cloudFigur = cloudFigures?.find(cf => cf.name === localFigur?.name);
            if (cloudFigur) {
              await db.from('scene_figures').insert({
                project_id: cloudId, scene_id: cloudScene.id, figure_id: cloudFigur.id
              });
            }
          }
        }
      }
      
      // Textbuch hochladen
      const textbuch = load(KEYS.textbuch(localId), {});
      console.log('Uploading textbuch for', Object.keys(textbuch).length, 'scenes');
      for (const [szeneId, content] of Object.entries(textbuch)) {
        const localSzene = szenen.find(s => s.id === szeneId);
        const cloudScene = cloudScenes?.find(cs => cs.number === localSzene?.nummer);
        if (cloudScene) {
          const { error } = await db.from('scene_texts').insert({
            project_id: cloudId, scene_id: cloudScene.id, content: content
          });
          if (error) console.error('Textbuch upload error:', error);
        }
      }
      
      // Cues hochladen
      const cues = load(KEYS.cues(localId), []);
      console.log('Uploading', cues.length, 'cues');
      for (const c of cues) {
        const localSzene = szenen.find(s => s.id === c.szeneId);
        const cloudScene = cloudScenes?.find(cs => cs.number === localSzene?.nummer);
        const { error } = await db.from('cues').insert({
          project_id: cloudId, scene_id: cloudScene?.id || null,
          cue_type: c.typ || 'lx', cue_number: c.nummer || 0,
          description: c.beschreibung || '', duration: c.dauer || '',
          anchor_text: c.ankerText || ''
        });
        if (error) console.error('Cue upload error:', error);
      }
      
      // Kost√ºme hochladen
      const kostueme = load(KEYS.kostueme(localId), []);
      console.log('Uploading', kostueme.length, 'costumes');
      for (const k of kostueme) {
        const localFigur = figuren.find(f => f.id === k.figur);
        const cloudFigur = cloudFigures?.find(cf => cf.name === localFigur?.name);
        const { data: costumeData, error } = await db.from('costumes').insert({
          project_id: cloudId, figure_id: cloudFigur?.id || null,
          name: k.name || '', description: k.beschreibung || '', notes: k.notizen || ''
        }).select().single();
        if (error) console.error('Costume upload error:', error);
        
        // Costume-Scenes
        if (costumeData && k.szenen) {
          for (const szeneId of k.szenen) {
            const localSzene = szenen.find(s => s.id === szeneId);
            const cloudScene = cloudScenes?.find(cs => cs.number === localSzene?.nummer);
            if (cloudScene) {
              await db.from('costume_scenes').insert({
                costume_id: costumeData.id, scene_id: cloudScene.id
              });
            }
          }
        }
      }
      
      // Requisiten hochladen
      const requisiten = load(KEYS.requisiten(localId), []);
      console.log('Uploading', requisiten.length, 'props');
      for (const r of requisiten) {
        const { data: propData, error } = await db.from('props').insert({
          project_id: cloudId, name: r.name || '', description: r.beschreibung || ''
        }).select().single();
        if (error) console.error('Prop upload error:', error);
        
        if (propData && r.szenen) {
          for (const szeneId of r.szenen) {
            const localSzene = szenen.find(s => s.id === szeneId);
            const cloudScene = cloudScenes?.find(cs => cs.number === localSzene?.nummer);
            if (cloudScene) {
              await db.from('prop_scenes').insert({
                prop_id: propData.id, scene_id: cloudScene.id
              });
            }
          }
        }
      }
      
      // Medien hochladen
      const medien = load(KEYS.medien(localId), []);
      console.log('Uploading', medien.length, 'media');
      for (const m of medien) {
        const { error } = await db.from('media').insert({
          project_id: cloudId, name: m.name || '', media_type: m.typ || '',
          url: m.url || '', description: m.beschreibung || ''
        });
        if (error) console.error('Media upload error:', error);
      }
      
      // B√ºhnenbilder hochladen
      const buehne = load(KEYS.buehne(localId), []);
      console.log('Uploading', buehne.length, 'stage designs');
      for (const b of buehne) {
        const { error } = await db.from('stage_designs').insert({
          project_id: cloudId, name: b.name || '', image_url: b.bild || '',
          description: b.beschreibung || ''
        });
        if (error) console.error('Stage design upload error:', error);
      }
      
      // Fassungen hochladen
      const fassungen = load(KEYS.fassungen(localId), []);
      console.log('Uploading', fassungen.length, 'script versions');
      for (const f of fassungen) {
        const { error } = await db.from('script_versions').insert({
          project_id: cloudId, name: f.name || '', version_date: f.datum,
          content: f.textbuch || {}
        });
        if (error) console.error('Version upload error:', error);
      }
      
      // Lokales Projekt mit Cloud verkn√ºpfen
      let projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === localId);
      if (idx >= 0) {
        projekte[idx].cloudId = cloudId;
        save(KEYS.projekte, projekte);
      }
      
      currentCloudProjectId = cloudId;
      await loadCloudProjects();
      
      alert('‚úÖ Projekt in Cloud hochgeladen!');
      render();
    }
    
    // v2.2: √Ñnderungen zur Cloud synchronisieren (f√ºr bestehende Cloud-Projekte)
    let syncDebounceTimer = null;
    async function syncToCloud() {
      if (!cloudUser || !currentCloudProjectId || !isCloudMode) return;
      
      const cloudId = currentCloudProjectId;
      const meta = state.projektMeta;
      
      console.log('Syncing to cloud:', cloudId);
      
      // 1. Projekt-Meta updaten
      await db.from('projects').update({
        name: meta.titel || 'Unbenannt',
        subtitle: meta.untertitel || '',
        author: meta.autor || '',
        version_name: meta.fassung || 'Arbeitsfassung',
        structure_type: meta.strukturTyp || 'akte',
        premiere_date: meta.premiere || null,
        venue: meta.spielort || '',
        updated_at: new Date().toISOString()
      }).eq('id', cloudId);
      
      // 2. Figuren synchronisieren
      const localFiguren = state.figuren || [];
      const { data: cloudFigures } = await db.from('figures').select('*').eq('project_id', cloudId);
      
      // Neue Figuren hinzuf√ºgen
      for (let i = 0; i < localFiguren.length; i++) {
        const f = localFiguren[i];
        const existing = cloudFigures?.find(cf => cf.name === f.name);
        if (!existing) {
          await db.from('figures').insert({
            project_id: cloudId,
            name: f.name || '',
            abbreviation: f.kuerzel || '',
            description: f.beschreibung || '',
            want: f.want || '',
            need: f.need || '',
            sort_order: i,
            color: '#3b82f6'
          });
        } else {
          // Existierende Figur updaten
          await db.from('figures').update({
            abbreviation: f.kuerzel || '',
            description: f.beschreibung || '',
            want: f.want || '',
            need: f.need || '',
            sort_order: i
          }).eq('id', existing.id);
        }
      }
      
      // Gel√∂schte Figuren entfernen
      const localNames = localFiguren.map(f => f.name);
      for (const cf of (cloudFigures || [])) {
        if (!localNames.includes(cf.name)) {
          await db.from('figures').delete().eq('id', cf.id);
        }
      }
      
      // 3. Szenen synchronisieren
      const localSzenen = state.szenen || [];
      const { data: cloudScenes } = await db.from('scenes').select('*').eq('project_id', cloudId);
      
      // Neue Szenen hinzuf√ºgen
      for (let i = 0; i < localSzenen.length; i++) {
        const s = localSzenen[i];
        const existing = cloudScenes?.find(cs => cs.number === s.nummer);
        if (!existing) {
          await db.from('scenes').insert({
            project_id: cloudId,
            name: s.titel || '',
            number: s.nummer || '',
            title: s.titel || '',
            location: s.ort || '',
            time_of_day: s.zeit || '',
            scene_group: s.gruppe || '',
            summary: s.zusammenfassung || '',
            sort_order: i
          });
        } else {
          // Existierende Szene updaten
          await db.from('scenes').update({
            name: s.titel || '',
            title: s.titel || '',
            location: s.ort || '',
            time_of_day: s.zeit || '',
            scene_group: s.gruppe || '',
            summary: s.zusammenfassung || '',
            sort_order: i
          }).eq('id', existing.id);
        }
      }
      
      // Gel√∂schte Szenen entfernen
      const localNumbers = localSzenen.map(s => s.nummer);
      for (const cs of (cloudScenes || [])) {
        if (!localNumbers.includes(cs.number)) {
          await db.from('scenes').delete().eq('id', cs.id);
        }
      }
      
      console.log('Cloud sync completed');
    }
    
    // Debounced sync (wartet 2 Sekunden nach letzter √Ñnderung)
    function scheduleSyncToCloud() {
      if (syncDebounceTimer) clearTimeout(syncDebounceTimer);
      syncDebounceTimer = setTimeout(() => {
        syncToCloud();
      }, 2000);
    }
    
    // v2.0: Einfaches Cloud-Projekt erstellen (mit Prompt)
    async function createCloudProjectSimple() {
      if (!cloudUser) {
        state.showCloudModal = true;
        render();
        return alert('Bitte zuerst einloggen!');
      }
      
      const name = prompt('Name f√ºr neues Cloud-Projekt:');
      if (!name || !name.trim()) return;
      
      const { data: projectData, error } = await db.from('projects').insert({
        name: name.trim(),
        app_type: 'rebu',
        created_by: cloudUser.id,
        status: 'active'
      }).select().single();
      
      if (error) { alert('Fehler: ' + error.message); return; }
      
      await db.from('project_members').insert({
        project_id: projectData.id,
        user_id: cloudUser.id,
        role: 'owner'
      });
      
      await loadCloudProjects();
      await selectCloudProject(projectData.id);
      
      alert('‚òÅÔ∏è Cloud-Projekt "' + name.trim() + '" erstellt!');
    }
    
    // v2.0: Explizit von Cloud neu laden (√ºberschreibt lokale Daten)
    async function forceCloudSync() {
      if (!currentCloudProjectId) return alert('Kein Cloud-Projekt aktiv!');
      
      const confirm_msg = 'üîÑ Von Cloud neu laden?\n\nAlle lokalen √Ñnderungen werden mit den Cloud-Daten √ºberschrieben!';
      if (!confirm(confirm_msg)) return;
      
      const localId = state.projektId;
      await syncFromCloud(currentCloudProjectId, localId);
      loadProjektDaten();
      render();
      
      alert('‚úÖ Daten von Cloud geladen!');
    }
    
    // v2.0: Wrapper f√ºr uploadProjectToCloud
    async function uploadToCloud() {
      if (!cloudUser) {
        state.showCloudModal = true;
        render();
        return alert('Bitte zuerst einloggen!');
      }
      
      const projektName = state.projektMeta?.titel || 'Unbenannt';
      const confirm_msg = `‚¨ÜÔ∏è Projekt "${projektName}" in Cloud hochladen?\n\nDas Projekt wird mit der Cloud synchronisiert und auf allen Ger√§ten verf√ºgbar.`;
      if (!confirm(confirm_msg)) return;
      
      await uploadProjectToCloud();
    }
    
    async function deleteCloudProject(cloudId) {
      if (!confirm('Cloud-Projekt wirklich l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) return;
      
      const { error } = await db.from('projects').delete().eq('id', cloudId);
      if (error) { alert('Fehler: ' + error.message); return; }
      
      await loadCloudProjects();
      render();
    }

    // ============================================
    // PROJEKT MANAGEMENT
    // ============================================
    function initProjekt() {
      const projekte = load(KEYS.projekte, []);
      let projektId = load(KEYS.aktuellesProjekt);
      
      if (!projektId || projekte.length === 0) {
        projektId = genId();
        const neuProjekt = { id: projektId, name: 'Demo-Projekt', erstellt: new Date().toISOString() };
        save(KEYS.projekte, [neuProjekt]);
        save(KEYS.aktuellesProjekt, projektId);
        
        // Demo-Figuren
        const demoFiguren = [
          { id: genId(), name: 'MARTHE', kuerzel: 'MA', beschreibung: 'Die Marketenderin', want: '√úberleben', need: 'Liebe' },
          { id: genId(), name: 'MELK', kuerzel: 'ME', beschreibung: 'Ein K√∂hlerjunge', want: 'Das Geheimnis finden', need: 'Zugeh√∂rigkeit' },
          { id: genId(), name: 'GRIT', kuerzel: 'GR', beschreibung: 'Magd im Gasthaus', want: 'Freiheit', need: 'Anerkennung' },
        ];
        save(KEYS.figuren(projektId), demoFiguren);
        
        // Demo-Szenen
        const demoSzenen = [
          { id: genId(), nummer: '1.1', titel: 'Prolog', ort: 'Marktplatz', zeit: 'Morgen', figuren: [demoFiguren[0].id], gruppe: '1', zusammenfassung: 'Marthe beginnt ihren Tag. Wir ahnen, dass etwas nicht stimmt.' },
          { id: genId(), nummer: '1.2', titel: 'Die Ankunft', ort: 'Dorfplatz', zeit: 'Mittag', figuren: [demoFiguren[0].id, demoFiguren[1].id], gruppe: '1', zusammenfassung: 'Melk kommt an. Marthe scheint ihn erwartet zu haben.' },
          { id: genId(), nummer: '2.1', titel: 'Im Gasthaus', ort: 'Gasthaus zum Sternen', zeit: 'Abend', figuren: [demoFiguren[1].id, demoFiguren[2].id], gruppe: '2', zusammenfassung: 'Melk trifft auf Grit. Ein Geheimnis wird angedeutet.' },
        ];
        save(KEYS.szenen(projektId), demoSzenen);
        
        // v1.2: Demo-Textbuch mit neuem Dialog-Format (Grid)
        const demoTextbuch = {};
        demoTextbuch[demoSzenen[0].id] = `<p class="format-szene-titel">1.1 Prolog</p>
<p class="format-regieanweisung">(Der Marktplatz bei Sonnenaufgang. Nebel h√§ngt √ºber dem Dorf. MARTHE tritt langsam auf, einen Korb tragend.)</p>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">So fr√ºh schon wach, und doch zu sp√§t. Die Welt dreht sich, ob ich will oder nicht.</span></div>
<p class="format-regieanweisung">(Sie stellt den Korb ab und blickt zum Himmel.)</p>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">Was bringt der Tag? Nichts Gutes, f√ºrcht ich. Nichts Gutes seit langem.</span></div>
<p class="format-lied">üéµ Der Morgen graut, die Nacht vergeht,
und niemand weiss, wie's weitergeht.
Was gestern war, ist l√§ngst vorbei,
was morgen kommt ‚Äì wer ist dabei?</p>
<p class="format-regieanweisung">(MARTHE nimmt den Korb wieder auf und geht langsam ab.)</p>`;

        demoTextbuch[demoSzenen[1].id] = `<p class="format-szene-titel">1.2 Die Ankunft</p>
<p class="format-regieanweisung">(Dorfplatz. MARTHE wartet. MELK kommt von rechts, verstaubt und ersch√∂pft.)</p>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">Da bist du ja. Ich hab dich erwartet.</span></div>
<div class="format-dialog"><span class="figur-name">MELK:</span><span class="dialog-text">Mich? Woher wusstest du‚Äî</span></div>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">Ich weiss <span class="format-gestrichen">einiges</span><span class="format-ergaenzung">vieles</span>. Mehr als mir lieb ist.</span></div>
<p class="format-regieanweisung">(Sie mustert ihn von Kopf bis Fuss.)</p>
<div class="format-dialog"><span class="figur-name">MARTHE:</span><span class="dialog-text">Du siehst aus wie einer, der etwas sucht. Etwas, das er besser nicht finden sollte.</span></div>`;

        save(KEYS.textbuch(projektId), demoTextbuch);
        
        // Demo-Cues (mit Ankertexten)
        const demoCues = [
          { id: genId(), typ: 'lx', nummer: 1, szeneId: demoSzenen[0].id, beschreibung: 'Morgend√§mmerung - langsamer Fade up', dauer: '10s', ankerText: '(Der Marktplatz bei Sonnenaufgang. Nebel h√§ngt √ºber dem Dorf. MARTHE tritt langsam auf, einen Korb tragend.)' },
          { id: genId(), typ: 'q', nummer: 1, szeneId: demoSzenen[0].id, beschreibung: 'Vogelgezwitscher, leise', dauer: 'Loop', ankerText: '(Sie stellt den Korb ab und blickt zum Himmel.)' },
          { id: genId(), typ: 'lx', nummer: 2, szeneId: demoSzenen[1].id, beschreibung: 'Tageslicht - heller', dauer: '3s', ankerText: '(Dorfplatz. MARTHE wartet. MELK kommt von rechts, verstaubt und ersch√∂pft.)' },
        ];
        save(KEYS.cues(projektId), demoCues);
        
        // Demo-Kost√ºme
        const demoKostueme = [
          { id: genId(), name: 'Marthe - Grundkost√ºm', figur: demoFiguren[0].id, beschreibung: 'Einfaches Leinenkleid, Sch√ºrze, Kopftuch', szenen: [demoSzenen[0].id, demoSzenen[1].id], notizen: '' },
          { id: genId(), name: 'Melk - Wanderkleidung', figur: demoFiguren[1].id, beschreibung: 'Zerrissene Hose, Lederwams, Hut', szenen: [demoSzenen[1].id, demoSzenen[2].id], notizen: 'Muss verstaubt aussehen' },
        ];
        save(KEYS.kostueme(projektId), demoKostueme);
        
        // Projekt-Meta
        const meta = {
          titel: 'Brandboden',
          untertitel: 'oder Wie Melk die Kohle aus dem Feuer holt',
          autor: 'Ueli Blum',
          tagline: 'Ein sagenhaftes Wandertheater',
          logline: 'Ein K√∂hlerjunge sucht nach dem Geheimnis des kalten Herzens.',
          fassung: 'Arbeitsfassung',
          fassungsDatum: new Date().toISOString()
        };
        save(KEYS.projektMeta(projektId), meta);
      }
      
      state.projektId = projektId || projekte[0]?.id;
      loadProjektDaten();
    }

    function loadProjektDaten() {
      if (!state.projektId) return;
      
      // Cloud-ID setzen wenn das Projekt mit Cloud verkn√ºpft ist
      const projekte = load(KEYS.projekte, []);
      const projekt = projekte.find(p => p.id === state.projektId);
      if (projekt?.cloudId) {
        currentCloudProjectId = projekt.cloudId;
      } else if (state.projektId && state.projektId.startsWith && state.projektId.startsWith('cloud_')) {
        currentCloudProjectId = state.projektId.replace('cloud_', '');
      } else {
        currentCloudProjectId = null;
      }
      
      // Default-Werte f√ºr neues Projekt
      const defaultMeta = {
        titel: 'Neues Projekt',
        untertitel: '',
        autor: '',
        tagline: '',
        logline: '',
        copyright: '',
        titelbild: '',
        fassung: 'Arbeitsfassung',
        fassungsDatum: new Date().toISOString(),
        eigeneGruppen: ['Erster Akt'],
        premiere: '',
        spielort: ''
      };
      
      state.projektMeta = load(KEYS.projektMeta(state.projektId), defaultMeta);
      state.figuren = load(KEYS.figuren(state.projektId), []);
      state.szenen = load(KEYS.szenen(state.projektId), []);
      state.textbuch = load(KEYS.textbuch(state.projektId), {});
      state.cues = load(KEYS.cues(state.projektId), []);
      state.fassungen = load(KEYS.fassungen(state.projektId), []);
      state.requisiten = load(KEYS.requisiten(state.projektId), []);
      state.kostueme = load(KEYS.kostueme(state.projektId), []);
      state.medien = load(KEYS.medien(state.projektId), []);
      state.buehne = load(KEYS.buehne(state.projektId), []);
      // v3.0
      state.konzept = load(KEYS.konzept(state.projektId), {
        treatment: [], fundament: { kern: '', logline: '', unaussprechliches: '', emotionalerBogen: '', konflikt: '' },
        werte: [], motive: []
      });
      state.beziehungen = load(KEYS.beziehungen(state.projektId), []);
      state.rechercheMaterial = load(KEYS.rechercheMaterial(state.projektId), []);
      state.musikkonzept = load(KEYS.musikkonzept(state.projektId), { text: '', stuecke: [] });
      state.ensemble = load(KEYS.ensemble(state.projektId), []);
      state.team = load(KEYS.team(state.projektId), []);
      state.probeplan = load(KEYS.probeplan(state.projektId), []);
      
      if (state.szenen.length > 0 && !state.aktiveSzene) {
        state.aktiveSzene = state.szenen[0].id;
      }
      
      // v2.0: Migration von altem strukturTyp zu neuem System
      if (state.projektMeta.strukturTyp && !state.projektMeta.eigeneGruppen) {
        // Migration: Gruppen aus bestehenden Szenen extrahieren
        const existierendeGruppen = [...new Set(state.szenen.map(s => s.gruppe).filter(Boolean))];
        state.projektMeta.eigeneGruppen = existierendeGruppen.length > 0 ? existierendeGruppen : ['Teil 1'];
        delete state.projektMeta.strukturTyp;
        delete state.projektMeta.strukturVorlage;
        saveProjektDaten();
      }
      
      // Sicherstellen dass eigeneGruppen existiert
      if (!state.projektMeta.eigeneGruppen) {
        state.projektMeta.eigeneGruppen = ['Erster Akt'];
      }
      
      state.dirty = false; // Frisch geladen, keine ungespeicherten √Ñnderungen
    }
    
    // v2.0: Aktuelle Gruppen des Projekts holen (eigene + aus Szenen extrahierte)
    function getAktuelleGruppen() {
      const eigene = state.projektMeta.eigeneGruppen || [];
      // Auch Gruppen aus Szenen extrahieren die evtl. noch nicht in eigeneGruppen sind
      const ausszenen = [...new Set(state.szenen.map(s => s.gruppe).filter(Boolean))];
      const alle = [...new Set([...eigene, ...ausszenen])];
      return alle.length > 0 ? alle : ['Teil 1'];
    }
    
    // v2.0: Neue Gruppe hinzuf√ºgen
    function addGruppe(name) {
      if (!name || name.trim() === '') return;
      if (!state.projektMeta.eigeneGruppen) state.projektMeta.eigeneGruppen = [];
      if (!state.projektMeta.eigeneGruppen.includes(name.trim())) {
        state.projektMeta.eigeneGruppen.push(name.trim());
        saveProjektDaten();
        render();
      }
    }
    
    // v2.0: Gruppe umbenennen
    function renameGruppe(altName, neuName) {
      if (!neuName || neuName.trim() === '') return;
      const idx = state.projektMeta.eigeneGruppen?.indexOf(altName);
      if (idx !== -1) {
        state.projektMeta.eigeneGruppen[idx] = neuName.trim();
        // Auch alle Szenen mit dieser Gruppe aktualisieren
        state.szenen.forEach(s => {
          if (s.gruppe === altName) s.gruppe = neuName.trim();
        });
        saveProjektDaten();
        render();
      }
    }
    
    // v2.0: Gruppe l√∂schen (Szenen bleiben, bekommen 'Ohne Zuordnung')
    function deleteGruppe(name) {
      const idx = state.projektMeta.eigeneGruppen?.indexOf(name);
      if (idx !== -1) {
        state.projektMeta.eigeneGruppen.splice(idx, 1);
        saveProjektDaten();
        render();
      }
    }
    
    
    // v2.0: Gruppe nach oben/unten verschieben
    function moveGruppe(name, direction) {
      const gruppen = state.projektMeta.eigeneGruppen || [];
      const idx = gruppen.indexOf(name);
      if (idx === -1) return;
      
      const newIdx = idx + direction;
      if (newIdx < 0 || newIdx >= gruppen.length) return;
      
      // Tauschen
      const temp = gruppen[idx];
      gruppen[idx] = gruppen[newIdx];
      gruppen[newIdx] = temp;
      
      saveProjektDaten();
      render();
    }
    
    // Szenen nach Gruppe und Nummer sortieren
    function sortSzenen() {
      state.szenen.sort((a, b) => {
        // Erst nach Gruppe sortieren
        const gruppeA = parseInt(a.gruppe) || 1;
        const gruppeB = parseInt(b.gruppe) || 1;
        if (gruppeA !== gruppeB) return gruppeA - gruppeB;
        
        // Dann nach Nummer sortieren
        const nummerA = parseFloat(a.nummer) || 0;
        const nummerB = parseFloat(b.nummer) || 0;
        return nummerA - nummerB;
      });
    }

    function saveProjektDaten() {
      if (!state.projektId) return;
      
      state.dirty = true; // √Ñnderungen seit letztem Export
      
      save(KEYS.projektMeta(state.projektId), state.projektMeta);
      save(KEYS.figuren(state.projektId), state.figuren);
      save(KEYS.szenen(state.projektId), state.szenen);
      save(KEYS.textbuch(state.projektId), state.textbuch);
      save(KEYS.cues(state.projektId), state.cues);
      save(KEYS.fassungen(state.projektId), state.fassungen);
      save(KEYS.requisiten(state.projektId), state.requisiten);
      save(KEYS.kostueme(state.projektId), state.kostueme);
      save(KEYS.medien(state.projektId), state.medien);
      save(KEYS.buehne(state.projektId), state.buehne);
      // v3.0
      save(KEYS.konzept(state.projektId), state.konzept);
      save(KEYS.beziehungen(state.projektId), state.beziehungen);
      save(KEYS.rechercheMaterial(state.projektId), state.rechercheMaterial);
      save(KEYS.musikkonzept(state.projektId), state.musikkonzept);
      save(KEYS.ensemble(state.projektId), state.ensemble);
      save(KEYS.team(state.projektId), state.team);
      save(KEYS.probeplan(state.projektId), state.probeplan);
      
      // v2.2: Auto-Sync zur Cloud (wenn Cloud-Projekt)
      scheduleSyncToCloud();
    }
    
    // ============================================
    // PROJEKT-VERWALTUNG (NEU v1.4)
    // ============================================
    let editingProjekt = null;
    
    function wechsleProjekt(projektId) {
      if (projektId === state.projektId) return;
      
      // Aktuelles Projekt speichern
      saveProjektDaten();
      
      // Alle Modals schliessen
      state.showProjektModal = false;
      state.showProjektListeModal = false;
      state.showImportModal = false;
      state.showExportModal = false;
      editingProjekt = null;
      
      // Neues Projekt laden
      save(KEYS.aktuellesProjekt, projektId);
      state.projektId = projektId;
      state.aktiveSzene = null;
      loadProjektDaten();
      
      render();
    }
    
    function openProjektModal(projektId = null) {
      if (projektId) {
        // Bestehendes Projekt bearbeiten
        const projekte = load(KEYS.projekte, []);
        const projekt = projekte.find(p => p.id === projektId);
        editingProjekt = projekt ? { ...projekt, ...state.projektMeta } : null;
      } else {
        // Neues Projekt - Warnung anzeigen wenn aktuelles Projekt Daten hat
        const hatDaten = state.szenen.length > 0 || state.figuren.length > 0 || state.cues.length > 0;
        const istCloudProjekt = !!currentCloudProjectId;
        
        if (hatDaten) {
          let warnung;
          if (istCloudProjekt) {
            // Cloud-Projekt: Daten sind sicher
            warnung = `üìù Neues Projekt erstellen\n\n` +
              `Das aktuelle Projekt "${state.projektMeta.titel || 'Unbenannt'}" enth√§lt:\n` +
              `‚Ä¢ ${state.szenen.length} Szenen\n` +
              `‚Ä¢ ${state.figuren.length} Figuren\n` +
              `‚Ä¢ ${state.cues.length} Cues\n\n` +
              `‚òÅÔ∏è Das Projekt ist in der Cloud gespeichert und bleibt erhalten.\n\n` +
              `Neues Projekt erstellen?`;
          } else {
            // Nur lokal: Warnung anzeigen
            warnung = `‚ö†Ô∏è ACHTUNG: Neues Projekt erstellen\n\n` +
              `Das aktuelle Projekt "${state.projektMeta.titel || 'Unbenannt'}" enth√§lt:\n` +
              `‚Ä¢ ${state.szenen.length} Szenen\n` +
              `‚Ä¢ ${state.figuren.length} Figuren\n` +
              `‚Ä¢ ${state.cues.length} Cues\n\n` +
              `Diese Daten werden nur lokal im Browser gespeichert.\n` +
              `Wenn der Browser-Cache gel√∂scht wird, sind sie WEG!\n\n` +
              `üì• Empfehlung: Erst EXPORTIEREN (Projekt-Backup),\n` +
              `dann neues Projekt erstellen.\n\n` +
              `Trotzdem fortfahren?`;
          }
          
          if (!confirm(warnung)) {
            return;
          }
        }
        
        // Neues Projekt
        editingProjekt = {
          id: null,
          name: '',
          titel: '',
          untertitel: '',
          autor: '',
          fassung: 'Arbeitsfassung'
        };
      }
      state.showProjektModal = true;
      render();
    }
    
    function renderProjektModal() {
      const p = editingProjekt || {};
      const isEdit = !!p.id;
      const apiKey = localStorage.getItem('nina_rebu_api_key') || '';
      
      return `
        <div class="modal-overlay" onclick="closeModal('showProjektModal')">
          <div class="modal-content" style="max-width: 650px; max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚öôÔ∏è¬è Projekt-Einstellungen' : 'üìÅ Neues Projekt'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showProjektModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <!-- Basis-Info -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Projektname *</label>
                <input type="text" id="projekt-name" value="${p.name || p.titel || ''}" placeholder="Mein Theaterst√ºck">
                <p class="text-xs text-gray-400 mt-1">Wird in der Projektliste angezeigt</p>
              </div>
              
              <!-- Titelblatt-Bereich -->
              <div class="border rounded-lg p-4 mb-4 bg-gray-50">
                <h3 class="text-sm font-semibold text-gray-600 mb-3">üìÑ Titelblatt</h3>
                
                <div class="grid grid-cols-2 gap-4 mb-3">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">St√ºcktitel</label>
                    <input type="text" id="projekt-titel" value="${p.titel || ''}" placeholder="Romeo und Julia">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Untertitel</label>
                    <input type="text" id="projekt-untertitel" value="${p.untertitel || ''}" placeholder="Eine Trag√∂die in f√ºnf Akten">
                  </div>
                </div>
                
                <div class="grid grid-cols-2 gap-4 mb-3">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Autor:in</label>
                    <input type="text" id="projekt-autor" value="${p.autor || ''}" placeholder="William Shakespeare">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Copyright</label>
                    <input type="text" id="projekt-copyright" value="${p.copyright || ''}" placeholder="¬© 2024 Theater XY">
                  </div>
                </div>
                
                <div class="mb-3">
                  <label class="block text-xs font-medium text-gray-700 mb-1">Tagline</label>
                  <input type="text" id="projekt-tagline" value="${p.tagline || ''}" placeholder="Kurzer Werbespruch (1 Zeile)">
                </div>
                
                <div class="mb-3">
                  <label class="block text-xs font-medium text-gray-700 mb-1">Logline</label>
                  <textarea id="projekt-logline" rows="2" placeholder="Kurze Zusammenfassung der Handlung (2-3 S√§tze)">${p.logline || ''}</textarea>
                </div>
                
                <div>
                  <label class="block text-xs font-medium text-gray-700 mb-1">Titelbild</label>
                  <div class="flex gap-2 items-center">
                    ${p.titelbild ? `
                      <img src="${p.titelbild}" class="w-16 h-16 object-cover rounded border" id="titelbild-preview">
                      <button class="btn btn-xs btn-outline" onclick="removeTitelbild()">√ó</button>
                    ` : `<div id="titelbild-preview-container"></div>`}
                    <input type="file" id="projekt-titelbild" accept="image/*" class="text-xs flex-1"
                           onchange="handleTitelbildUpload(this)">
                  </div>
                </div>
              </div>
              
              <!-- Produktion -->
              <div class="border rounded-lg p-4 mb-4 bg-gray-50">
                <h3 class="text-sm font-semibold text-gray-600 mb-3">üé≠ Produktion</h3>
                
                <div class="grid grid-cols-3 gap-4 mb-3">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Fassung</label>
                    <input type="text" id="projekt-fassung" value="${p.fassung || 'Arbeitsfassung'}" placeholder="Arbeitsfassung">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Premiere</label>
                    <input type="date" id="projekt-premiere" value="${p.premiere || ''}">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Spielort</label>
                    <input type="text" id="projekt-spielort" value="${p.spielort || ''}" placeholder="Stadttheater">
                  </div>
                </div>
                
                <!-- v2.0: Flexibles Struktur-System -->
                <div class="border rounded-lg p-4 mb-4 bg-purple-50">
                  <h3 class="text-sm font-semibold text-gray-600 mb-3">üé≠ St√ºckstruktur</h3>
                  
                  <!-- Eigene Gruppen/Akte -->
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Deine Akte/Teile/Gruppen</label>
                    <div id="eigene-gruppen-liste" class="space-y-1 mb-2 max-h-40 overflow-y-auto">
                      ${(state.projektMeta.eigeneGruppen || ['Erster Akt']).map((g, idx) => `
                        <div class="flex items-center gap-1 bg-white rounded px-2 py-1 text-sm">
                          <span class="text-gray-400 text-xs w-4">${idx + 1}.</span>
                          <input type="text" value="${g}" class="flex-1 border-0 bg-transparent text-sm p-0"
                                 onchange="renameGruppe('${g}', this.value)">
                          <button type="button" class="text-gray-400 hover:text-blue-600" onclick="moveGruppe('${g}', -1)" title="Nach oben">‚ñ≤</button>
                          <button type="button" class="text-gray-400 hover:text-blue-600" onclick="moveGruppe('${g}', 1)" title="Nach unten">‚ñº</button>
                          <button type="button" class="text-gray-400 hover:text-red-600" onclick="if(confirm('Gruppe l√∂schen?')) deleteGruppe('${g}')" title="L√∂schen">‚úï</button>
                        </div>
                      `).join('')}
                    </div>
                    <div class="flex gap-2">
                      <input type="text" id="neue-gruppe-input" class="flex-1 text-sm" placeholder="Neue Gruppe hinzuf√ºgen...">
                      <button type="button" class="btn btn-sm btn-primary" onclick="
                        const input = document.getElementById('neue-gruppe-input');
                        if (input.value.trim()) {
                          addGruppe(input.value.trim());
                          input.value = '';
                        }
                      ">+ Hinzuf√ºgen</button>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- KI-Einstellungen -->
              <div class="border rounded-lg p-4 mb-4 bg-blue-50">
                <h3 class="text-sm font-semibold text-gray-600 mb-3">ü§ñ KI-Assistent</h3>
                <div>
                  <label class="block text-xs font-medium text-gray-700 mb-1">Anthropic API Key</label>
                  <div class="api-key-row">
                    <input type="password" id="projekt-apikey" value="${apiKey}" 
                           placeholder="sk-ant-api03-..." class="font-mono text-xs flex-1"
                           onchange="localStorage.setItem('nina_rebu_api_key', this.value); apiKeyStatus = 'idle'; render();">
                    <button class="api-test-btn ${apiKeyStatus}" 
                            onclick="testApiKey()"
                            ${!apiKey || apiKeyStatus === 'testing' ? 'disabled' : ''}>
                      ${apiKeyStatus === 'testing' ? '‚è≥' : apiKeyStatus === 'success' ? '‚úì OK' : 'üîç Testen'}
                    </button>
                  </div>
                  ${apiKeyStatus === 'success' ? `
                    <div class="api-status success">‚úì API-Key funktioniert!</div>
                  ` : ''}
                  ${apiKeyStatus === 'error' ? `
                    <div class="api-status error">‚úó ${apiKeyError || 'Key ung√ºltig'}</div>
                  ` : ''}
                  ${apiKey && apiKeyStatus === 'idle' ? `
                    <div class="api-status neutral">Key eingegeben ‚Äì klicke "Testen" zur Pr√ºfung</div>
                  ` : ''}
                  <p class="text-xs text-gray-400 mt-2">
                    üîí Der Key wird nur lokal im Browser gespeichert, nie √ºbertragen.
                    <br><a href="https://console.anthropic.com/settings/keys" target="_blank" rel="noopener" class="text-blue-500 hover:underline">‚Üí API-Key erstellen</a>
                  </p>
                </div>
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `
                  <button class="btn btn-danger" onclick="deleteProjekt('${p.id}')">üóëÔ∏è¬è L√∂schen</button>
                ` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showProjektModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveProjekt()">üíæ ${isEdit ? 'Speichern' : 'Erstellen'}</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Titelbild-Handling
    let pendingTitelbild = null;
    
    function handleTitelbildUpload(input) {
      const file = input.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        pendingTitelbild = e.target.result;
        // Preview zeigen
        let preview = document.getElementById('titelbild-preview');
        if (!preview) {
          const container = document.getElementById('titelbild-preview-container');
          if (container) {
            container.innerHTML = '<img id="titelbild-preview" class="w-16 h-16 object-cover rounded border">';
            preview = document.getElementById('titelbild-preview');
          }
        }
        if (preview) preview.src = pendingTitelbild;
      };
      reader.readAsDataURL(file);
    }
    
    function removeTitelbild() {
      pendingTitelbild = '';
      if (editingProjekt) editingProjekt.titelbild = '';
      render();
    }
    
    function saveProjekt() {
      const name = document.getElementById('projekt-name').value.trim();
      if (!name) {
        alert('Bitte einen Projektnamen eingeben.');
        return;
      }
      
      // API-Key wird jetzt direkt im onchange gespeichert
      // Hier nur noch sicherstellen, dass er aktuell ist
      const apiKeyInput = document.getElementById('projekt-apikey');
      if (apiKeyInput) {
        const apiKey = apiKeyInput.value.trim();
        if (apiKey) {
          localStorage.setItem('nina_rebu_api_key', apiKey);
        }
      }
      
      const projektDaten = {
        titel: document.getElementById('projekt-titel').value.trim() || name,
        untertitel: document.getElementById('projekt-untertitel').value.trim(),
        autor: document.getElementById('projekt-autor').value.trim(),
        copyright: document.getElementById('projekt-copyright')?.value.trim() || '',
        tagline: document.getElementById('projekt-tagline')?.value.trim() || '',
        logline: document.getElementById('projekt-logline')?.value.trim() || '',
        titelbild: pendingTitelbild !== null ? pendingTitelbild : (editingProjekt?.titelbild || ''),
        fassung: document.getElementById('projekt-fassung').value.trim() || 'Arbeitsfassung',
        premiere: document.getElementById('projekt-premiere').value,
        spielort: document.getElementById('projekt-spielort').value.trim(),
        // v2.0: eigeneGruppen werden direkt √ºber addGruppe/renameGruppe/deleteGruppe ge√§ndert
        fassungsDatum: new Date().toISOString()
      };
      
      const projekte = load(KEYS.projekte, []);
      
      if (editingProjekt?.id) {
        // Bestehendes Projekt aktualisieren
        const idx = projekte.findIndex(p => p.id === editingProjekt.id);
        if (idx !== -1) {
          projekte[idx].name = name;
        }
        save(KEYS.projekte, projekte);
        
        // Meta-Daten aktualisieren
        state.projektMeta = { ...state.projektMeta, ...projektDaten };
        saveProjektDaten();
      } else {
        // Neues Projekt erstellen
        const neueId = genId();
        projekte.push({
          id: neueId,
          name: name,
          erstellt: new Date().toISOString()
        });
        save(KEYS.projekte, projekte);
        
        // Standard-Szene f√ºr neues Projekt erstellen
        const startSzeneId = genId();
        // v2.0: Erste Gruppe aus eigeneGruppen verwenden (falls vorhanden)
        const ersteGruppe = state.projektMeta.eigeneGruppen?.[0] || 'Erster Akt';
        const startSzene = {
          id: startSzeneId,
          nummer: '1.1',
          titel: 'Start',
          gruppe: ersteGruppe,
          ort: '',
          zeit: '',
          zusammenfassung: '',
          figuren: []
        };
        
        // v2.0: eigeneGruppen initialisieren falls noch nicht vorhanden
        if (!projektDaten.eigeneGruppen) {
          projektDaten.eigeneGruppen = ['Erster Akt'];
        }
        
        // Daten f√ºr neues Projekt speichern
        save(KEYS.projektMeta(neueId), projektDaten);
        save(KEYS.figuren(neueId), []);
        save(KEYS.szenen(neueId), [startSzene]);  // Mit Start-Szene!
        save(KEYS.textbuch(neueId), { [startSzeneId]: '<p class="format-standard"><br></p>' });
        save(KEYS.cues(neueId), []);
        save(KEYS.fassungen(neueId), []);
        save(KEYS.requisiten(neueId), []);
        save(KEYS.kostueme(neueId), []);
        save(KEYS.medien(neueId), []);
        save(KEYS.buehne(neueId), []);
        
        // Zum neuen Projekt wechseln
        wechsleProjekt(neueId);
      }
      
      closeModal('showProjektModal');
      editingProjekt = null;
      pendingTitelbild = null;
    }
    
    function deleteProjekt(projektId) {
      const projekte = load(KEYS.projekte, []);
      
      if (projekte.length <= 1) {
        alert('Das letzte Projekt kann nicht gel√∂scht werden.');
        return;
      }
      
      const projekt = projekte.find(p => p.id === projektId);
      if (!confirm(`Projekt "${projekt?.name}" wirklich l√∂schen?\n\nAlle Daten (Szenen, Figuren, Cues, etc.) werden unwiderruflich gel√∂scht!`)) {
        return;
      }
      
      // Projekt aus Liste entfernen
      const neueProjekte = projekte.filter(p => p.id !== projektId);
      save(KEYS.projekte, neueProjekte);
      
      // Projekt-Daten l√∂schen (optional, localStorage Keys bleiben, aber sind verwaist)
      localStorage.removeItem(KEYS.projektMeta(projektId));
      localStorage.removeItem(KEYS.figuren(projektId));
      localStorage.removeItem(KEYS.szenen(projektId));
      localStorage.removeItem(KEYS.textbuch(projektId));
      localStorage.removeItem(KEYS.cues(projektId));
      localStorage.removeItem(KEYS.fassungen(projektId));
      localStorage.removeItem(KEYS.requisiten(projektId));
      localStorage.removeItem(KEYS.kostueme(projektId));
      localStorage.removeItem(KEYS.medien(projektId));
      localStorage.removeItem(KEYS.buehne(projektId));
      
      // Zu anderem Projekt wechseln (defensiv: nur wenn neueProjekte nicht leer)
      if (state.projektId === projektId && neueProjekte.length) {
        wechsleProjekt(neueProjekte[0].id);
      }
      
      closeModal('showProjektModal');
    }

    // ============================================
    // DRAMERA IMPORT/EXPORT
    // ============================================
    function importFromDramera(jsonData) {
      try {
        const dramera = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
        
        if (dramera.data) {
          const d = dramera.data;
          state.projektMeta.titel = d.projektName || state.projektMeta.titel;
          
          // ProjektMeta wiederherstellen (wenn vorhanden)
          if (d.projektMeta) {
            state.projektMeta = { ...state.projektMeta, ...d.projektMeta };
          }
          
          if (d.autor) {
            state.projektMeta.autor = d.autor.name || state.projektMeta.autor || '';
          }
          
          if (d.fundament?.titel) {
            const t = d.fundament.titel;
            if (typeof t === 'object') {
              state.projektMeta.titel = t.titel || state.projektMeta.titel;
              state.projektMeta.untertitel = t.untertitel || state.projektMeta.untertitel || '';
              state.projektMeta.tagline = t.tagline || state.projektMeta.tagline || '';
            }
          }
          
          if (d.fundament?.logline) {
            state.projektMeta.logline = typeof d.fundament.logline === 'object' 
              ? d.fundament.logline.text 
              : d.fundament.logline;
          }
          
          // Figuren
          if (d.figuren && d.figuren.length > 0) {
            state.figuren = d.figuren.map(f => ({
              id: f.id || genId(),
              name: (f.name || 'Unbenannt').toUpperCase(),
              kuerzel: f.kuerzel || f.name?.substring(0, 2).toUpperCase() || 'XX',
              beschreibung: f.beschreibung || f.wesen || '',
              want: f.want || f.wantExternal || '',
              need: f.need || f.needInternal || '',
              wunde: f.wunde || '',
              geheimnis: f.geheimnisse || '',
            }));
          }
          
          // Szenen
          if (d.felder && d.felder.length > 0) {
            state.szenen = d.felder.map((f, idx) => ({
              id: f.id || genId(),
              nummer: f.nummer || `${Math.floor(idx / 5) + 1}.${(idx % 5) + 1}`,
              titel: f.titel || `Szene ${idx + 1}`,
              gruppe: f.gruppe || '',
              ort: f.ort || '',
              zeit: f.zeit || '',
              figuren: f.figuren || [],
              zusammenfassung: f.zusammenfassung || '',
            }));
            
            d.felder.forEach(f => {
              if (f.inhalt) {
                state.textbuch[f.id] = f.inhalt;
              }
            });
            
            if (state.szenen.length > 0) {
              state.aktiveSzene = state.szenen[0].id;
            }
          }
          
          // Cues
          if (d.cues && d.cues.length > 0) {
            state.cues = d.cues;
          }
          
          // Requisiten
          if (d.requisiten && d.requisiten.length > 0) {
            state.requisiten = d.requisiten;
          }
          
          // Kost√ºme
          if (d.kostueme && d.kostueme.length > 0) {
            state.kostueme = d.kostueme;
          }
          
          // B√ºhnenpl√§ne
          if (d.buehne && d.buehne.length > 0) {
            state.buehne = d.buehne;
          }
          
          // Fassungen
          if (d.fassungen && d.fassungen.length > 0) {
            state.fassungen = d.fassungen;
            // Referenz auf letzte Fassung setzen (f√ºr √Ñnderungsverfolgung)
            if (!state.referenzFassungId && state.fassungen.length > 0) {
              state.referenzFassungId = state.fassungen[state.fassungen.length - 1].id;
            }
          }
          
          // Recherche als Medien
          if (d.recherche && d.recherche.length > 0) {
            state.medien = d.recherche.map(r => ({
              id: r.id || genId(),
              typ: r.typ || 'text',
              titel: r.titel || 'Material',
              inhalt: r.inhalt || r.text || '',
              url: r.url || '',
            }));
          }
          
          // v3.0 Felder
          if (d.konzept) state.konzept = d.konzept;
          if (d.beziehungen) state.beziehungen = d.beziehungen;
          if (d.rechercheMaterial) state.rechercheMaterial = d.rechercheMaterial;
          if (d.musikkonzept) state.musikkonzept = d.musikkonzept;
          if (d.ensemble) state.ensemble = d.ensemble;
          if (d.team) state.team = d.team;
          if (d.probeplan) state.probeplan = d.probeplan;
        }
        
        saveProjektDaten();
        render();
        alert('‚úÖ Import aus Backup erfolgreich!\n\n' + 
              `${state.figuren.length} Figuren\n` +
              `${state.szenen.length} Szenen\n` +
              `${state.cues.length} Cues\n` +
              `${state.requisiten.length} Requisiten\n` +
              `${state.medien.length} Medien`);
        
      } catch (e) {
        console.error('Import-Fehler:', e);
        alert('‚ùå Import fehlgeschlagen: ' + e.message);
      }
    }

    function exportToDramera() {
      return {
        version: '3.0',
        exportDate: new Date().toISOString(),
        source: 'NINA-Rebu v3.0',
        data: {
          projektName: state.projektMeta.titel,
          projektMeta: JSON.parse(JSON.stringify(state.projektMeta)),
          autor: {
            name: state.projektMeta.autor,
            email: '',
            adresse: '',
            copyright: `¬© ${new Date().getFullYear()} ${state.projektMeta.autor}`
          },
          fundament: {
            titel: {
              titel: state.projektMeta.titel,
              untertitel: state.projektMeta.untertitel,
              tagline: state.projektMeta.tagline
            },
            logline: state.projektMeta.logline
          },
          figuren: state.figuren.map(f => ({
            id: f.id,
            name: f.name,
            kuerzel: f.kuerzel,
            beschreibung: f.beschreibung,
            want: f.want,
            need: f.need,
            wunde: f.wunde,
            geheimnisse: f.geheimnis
          })),
          felder: state.szenen.map(s => ({
            id: s.id,
            titel: s.titel,
            nummer: s.nummer,
            gruppe: s.gruppe,
            ort: s.ort,
            zeit: s.zeit,
            position: state.szenen.indexOf(s),
            figuren: s.figuren,
            zusammenfassung: s.zusammenfassung,
            inhalt: state.textbuch[s.id] || ''
          })),
          cues: JSON.parse(JSON.stringify(state.cues || [])),
          requisiten: JSON.parse(JSON.stringify(state.requisiten || [])),
          kostueme: JSON.parse(JSON.stringify(state.kostueme || [])),
          buehne: JSON.parse(JSON.stringify(state.buehne || [])),
          fassungen: JSON.parse(JSON.stringify(state.fassungen || [])),
          recherche: state.medien.map(m => ({
            id: m.id,
            typ: m.typ,
            titel: m.titel,
            inhalt: m.inhalt,
            url: m.url
          })),
          // v3.0
          konzept: JSON.parse(JSON.stringify(state.konzept || {})),
          beziehungen: JSON.parse(JSON.stringify(state.beziehungen || [])),
          rechercheMaterial: JSON.parse(JSON.stringify(state.rechercheMaterial || [])),
          musikkonzept: JSON.parse(JSON.stringify(state.musikkonzept || {})),
          ensemble: JSON.parse(JSON.stringify(state.ensemble || [])),
          team: JSON.parse(JSON.stringify(state.team || [])),
          probeplan: JSON.parse(JSON.stringify(state.probeplan || []))
        }
      };
    }

    // ============================================
    // FASSUNGS-VERWALTUNG (v1.2: mit Uhrzeit)
    // ============================================
    function neueFassungSpeichern(name) {
      const now = new Date();
      const fassung = {
        id: genId(),
        name: name || `Fassung vom ${formatDateTime(now)}`,
        datum: now.toISOString(),
        textbuch: JSON.parse(JSON.stringify(state.textbuch)),
        szenen: JSON.parse(JSON.stringify(state.szenen)),
        cues: JSON.parse(JSON.stringify(state.cues)),
      };
      
      state.fassungen.push(fassung);
      state.projektMeta.fassung = fassung.name;
      state.projektMeta.fassungsDatum = fassung.datum;
      state.referenzFassungId = fassung.id; // Automatisch als Referenz f√ºr √Ñnderungsverfolgung
      saveProjektDaten();
      render();
    }

    function fassungLaden(fassungId) {
      const fassung = state.fassungen.find(f => f.id === fassungId);
      if (fassung) {
        if (!confirm(`Aktuelle √Ñnderungen werden √ºberschrieben.\n\nFassung "${fassung.name}" laden?`)) return;
        
        state.textbuch = JSON.parse(JSON.stringify(fassung.textbuch));
        state.szenen = JSON.parse(JSON.stringify(fassung.szenen));
        if (fassung.cues) state.cues = JSON.parse(JSON.stringify(fassung.cues));
        state.projektMeta.fassung = fassung.name;
        saveProjektDaten();
        render();
      }
    }

    // ============================================
    // UNDO/REDO SYSTEM (v1.2)
    // ============================================
    // Hilfsfunktion: Cue-Marker aus HTML entfernen
    function stripCueMarkers(html) {
      return html.replace(/<span class="cue-inline-marker[^"]*"[^>]*>[^<]*<\/span>/g, '');
    }
    
    function pushUndo() {
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) return;
      
      // Ohne Cue-Marker speichern
      const cleanContent = stripCueMarkers(editor.innerHTML);
      
      // Duplikate vermeiden: nicht pushen wenn identisch mit letztem Eintrag
      if (state.undoStack.length > 0) {
        const last = state.undoStack[state.undoStack.length - 1];
        if (last.szeneId === state.aktiveSzene && last.content === cleanContent) return;
      }
      
      state.undoStack.push({
        szeneId: state.aktiveSzene,
        content: cleanContent
      });
      
      // Max 50 Eintr√§ge
      if (state.undoStack.length > 50) {
        state.undoStack.shift();
      }
      
      // Redo l√∂schen bei neuer Aktion
      state.redoStack = [];
      updateUndoButtons();
    }
    
    // Debounced Undo: Snapshot nach Tipp-Pause (500ms)
    let undoTimer = null;
    let lastUndoContent = '';
    function debouncedPushUndo() {
      if (undoTimer) clearTimeout(undoTimer);
      undoTimer = setTimeout(() => {
        const editor = document.getElementById('text-editor');
        if (!editor || !state.aktiveSzene) return;
        const current = stripCueMarkers(editor.innerHTML);
        if (current !== lastUndoContent) {
          pushUndo();
          lastUndoContent = current;
        }
      }, 500);
    }
    
    // Sofort-Snapshot vor gr√∂sseren Aktionen (Enter, Paste, Format etc.)
    function pushUndoImmediate() {
      if (undoTimer) clearTimeout(undoTimer);
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) return;
      const current = stripCueMarkers(editor.innerHTML);
      if (current !== lastUndoContent) {
        pushUndo();
        lastUndoContent = current;
      }
    }
    
    function undo() {
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) return;
      
      // Pending Debounce abbrechen
      if (undoTimer) clearTimeout(undoTimer);
      
      // Undo-States finden die zur aktuellen Szene geh√∂ren
      // States anderer Szenen √ºberspringen
      let targetState = null;
      const skipped = [];
      while (state.undoStack.length > 0) {
        const candidate = state.undoStack[state.undoStack.length - 1];
        if (candidate.szeneId === state.aktiveSzene) {
          // Pr√ºfen ob es sich vom aktuellen Inhalt unterscheidet
          const currentContent = stripCueMarkers(editor.innerHTML);
          if (candidate.content === currentContent && state.undoStack.length > 1) {
            // Identisch ‚Äî diesen √ºberspringen, den darunter nehmen
            skipped.push(state.undoStack.pop());
            continue;
          }
          targetState = state.undoStack.pop();
          break;
        } else {
          // Andere Szene ‚Äî in skipped parken
          skipped.push(state.undoStack.pop());
        }
      }
      
      // √úbersprungene States zur√ºcklegen (unter den Stack)
      if (skipped.length > 0) {
        state.undoStack.unshift(...skipped);
      }
      
      if (!targetState) return;
      
      // Aktuellen Zustand in Redo sichern
      state.redoStack.push({
        szeneId: state.aktiveSzene,
        content: stripCueMarkers(editor.innerHTML)
      });
      
      // Zielzustand wiederherstellen
      state.textbuch[state.aktiveSzene] = targetState.content;
      lastUndoContent = targetState.content;
      
      const szeneCues = state.cues.filter(c => c.szeneId === state.aktiveSzene);
      const displayContent = state.textAnsicht === 'technik' 
        ? enrichTextWithCueMarkers(targetState.content, szeneCues) 
        : targetState.content;
      
      editor.innerHTML = displayContent;
      saveProjektDaten();
      updateUndoButtons();
    }
    
    function redo() {
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) return;
      
      // Redo-State f√ºr aktuelle Szene finden
      let targetState = null;
      const skipped = [];
      while (state.redoStack.length > 0) {
        const candidate = state.redoStack[state.redoStack.length - 1];
        if (candidate.szeneId === state.aktiveSzene) {
          targetState = state.redoStack.pop();
          break;
        } else {
          skipped.push(state.redoStack.pop());
        }
      }
      if (skipped.length > 0) {
        state.redoStack.unshift(...skipped);
      }
      
      if (!targetState) return;
      
      // Aktuellen Zustand in Undo sichern
      state.undoStack.push({
        szeneId: state.aktiveSzene,
        content: stripCueMarkers(editor.innerHTML)
      });
      
      // Redo-Zustand wiederherstellen
      state.textbuch[state.aktiveSzene] = targetState.content;
      lastUndoContent = targetState.content;
      
      const szeneCues = state.cues.filter(c => c.szeneId === state.aktiveSzene);
      const displayContent = state.textAnsicht === 'technik' 
        ? enrichTextWithCueMarkers(targetState.content, szeneCues) 
        : targetState.content;
      
      editor.innerHTML = displayContent;
      saveProjektDaten();
      updateUndoButtons();
    }
    
    function updateUndoButtons() {
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');
      if (undoBtn) undoBtn.disabled = state.undoStack.length === 0;
      if (redoBtn) redoBtn.disabled = state.redoStack.length === 0;
    }

    // ============================================
    // EDITOR FUNKTIONEN (v1.2: verbessert)
    // ============================================
    function applyFormat(format) {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const selectedText = range.toString().trim();
      
      // WICHTIG: Wenn keine Auswahl, formatiere die ganze Zeile/Absatz
      if (!selectedText) {
        // Finde den aktuellen Absatz (p, div) wo der Cursor steht
        let node = selection.anchorNode;
        while (node && node !== editor) {
          if (node.nodeType === 1 && (node.tagName === 'P' || node.tagName === 'DIV')) {
            break;
          }
          node = node.parentNode;
        }
        
        if (node && node !== editor && node.nodeType === 1) {
          // Undo speichern
          pushUndo();
          
          // Text des Absatzes holen (alle Whitespace normalisieren)
          const text = node.textContent.replace(/\s+/g, ' ').trim();
          if (!text) return;
          
          // Neues formatiertes Element erstellen
          const vorlage = FORMATVORLAGEN[format];
          let newElement;
          
          switch (format) {
            case 'dialog':
              newElement = document.createElement('div');
              newElement.className = vorlage.class;
              // Regex: Name (mit Umlauten, Leerzeichen, Zahlen, Punkten) gefolgt von Doppelpunkt
              const dMatch = text.match(/^([A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\d\.]*?):\s*(.*)$/);
              if (dMatch) {
                const figurName = dMatch[1].trim().toUpperCase();
                const dialogText = dMatch[2] || '';
                newElement.innerHTML = `<span class="figur-name">${figurName}:</span><span class="dialog-text">${dialogText}</span>`;
              } else {
                // Kein Doppelpunkt gefunden - ganzer Text wird Dialog
                newElement.innerHTML = `<span class="figur-name">FIGUR:</span><span class="dialog-text">${text}</span>`;
              }
              break;
              
            case 'regieanweisung':
              newElement = document.createElement('p');
              newElement.className = vorlage.class;
              let regiText = text;
              if (!regiText.startsWith('(')) regiText = '(' + regiText;
              if (!regiText.endsWith(')')) regiText = regiText + ')';
              newElement.textContent = regiText;
              break;
            
            case 'szeneTitel':
              newElement = document.createElement('p');
              newElement.className = vorlage.class;
              newElement.textContent = text;
              // Neue Szene erstellen
              setTimeout(() => createSceneFromTitle(text, node), 100);
              break;
            
            case 'aktTitel':
              newElement = document.createElement('p');
              newElement.className = vorlage.class;
              newElement.textContent = text;
              // Neuen Akt erstellen
              setTimeout(() => createActFromTitle(text, node), 100);
              break;
              
            default:
              newElement = document.createElement('p');
              newElement.className = vorlage.class;
              newElement.textContent = text;
          }
          
          // Element ersetzen
          node.parentNode.replaceChild(newElement, node);
          
          // Cursor ans Ende des neuen Elements setzen
          const newRange = document.createRange();
          newRange.selectNodeContents(newElement);
          newRange.collapse(false);
          selection.removeAllRanges();
          selection.addRange(newRange);
          
          saveCurrentText();
        }
        return;
      }
      
      // Mit Auswahl: Original-Verhalten
      // Undo speichern
      pushUndo();
      
      const vorlage = FORMATVORLAGEN[format];
      let newHtml = '';
      
      switch (format) {
        case 'dialog':
          // v1.4: Dialog-Format - erkennt NAME: Text
          const selMatch = selectedText.replace(/\s+/g, ' ').match(/^([A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\d\.]*?):\s*(.*)$/);
          if (selMatch) {
            const fName = selMatch[1].trim().toUpperCase();
            newHtml = `<div class="${vorlage.class}"><span class="figur-name">${fName}:</span><span class="dialog-text">${selMatch[2]}</span></div>`;
          } else {
            newHtml = `<div class="${vorlage.class}"><span class="figur-name">FIGUR:</span><span class="dialog-text">${selectedText}</span></div>`;
          }
          break;
          
        case 'regieanweisung':
          let text = selectedText;
          if (!text.startsWith('(')) text = '(' + text;
          if (!text.endsWith(')')) text = text + ')';
          newHtml = `<p class="${vorlage.class}">${text}</p>`;
          break;
          
        case 'szeneTitel':
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
          // Neue Szene erstellen wenn gew√ºnscht
          setTimeout(() => createSceneFromTitle(selectedText, null), 100);
          break;
        
        case 'aktTitel':
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
          // Neuen Akt erstellen
          setTimeout(() => createActFromTitle(selectedText, null), 100);
          break;
          
        case 'lied':
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
          break;
          
        case 'vers':
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
          break;
          
        default:
          newHtml = `<p class="${vorlage.class}">${selectedText}</p>`;
      }
      
      range.deleteContents();
      const temp = document.createElement('div');
      temp.innerHTML = newHtml;
      const frag = document.createDocumentFragment();
      while (temp.firstChild) {
        frag.appendChild(temp.firstChild);
      }
      range.insertNode(frag);
      
      selection.removeAllRanges();
      saveCurrentText();
    }

    function insertNewParagraph(format) {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Undo speichern
      pushUndo();
      
      editor.focus();
      const vorlage = FORMATVORLAGEN[format];
      let html = '';
      
      switch (format) {
        case 'dialog':
          // v1.2: Neues Dialog-Format
          html = `<div class="${vorlage.class}"><span class="figur-name">FIGUR:</span><span class="dialog-text">&nbsp;</span></div>`;
          break;
        case 'regieanweisung':
          html = `<p class="${vorlage.class}">()</p>`;
          break;
        case 'szeneTitel':
          const szene = state.szenen.find(s => s.id === state.aktiveSzene);
          html = `<p class="${vorlage.class}">${szene ? szene.nummer + ' ' + szene.titel : 'Neue Szene'}</p>`;
          break;
        case 'aktTitel':
          const aktGruppen = state.projektMeta?.eigeneGruppen || ['Erster Akt'];
          html = `<p class="${vorlage.class}">${aktGruppen[0] || 'ERSTER AKT'}</p>`;
          break;
        case 'pause':
          html = `<p class="${vorlage.class}">‚Äî PAUSE ‚Äî</p>`;
          break;
        case 'lied':
          html = `<p class="${vorlage.class}">üéµ </p>`;
          break;
        default:
          html = `<p class="${vorlage.class}"><br></p>`;
      }
      
      document.execCommand('insertHTML', false, html);
      saveCurrentText();
    }

    function insertFigurDialog(figurName) {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Undo speichern
      pushUndo();
      
      editor.focus();
      // v1.2: Neues Dialog-Format
      const html = `<div class="format-dialog"><span class="figur-name">${figurName.toUpperCase()}:</span><span class="dialog-text">&nbsp;</span></div>`;
      document.execCommand('insertHTML', false, html);
      saveCurrentText();
      
      // Cursor ans Ende setzen
      const selection = window.getSelection();
      const range = document.createRange();
      range.selectNodeContents(editor);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // ============================================
    // AUTOMATISCHE √ÑNDERUNGSVERFOLGUNG (Diff)
    // ============================================
    
    // HTML zu Plain-Text-Zeilen konvertieren (Struktur erhalten)
    function htmlToTextLines(html) {
      if (!html) return [];
      // Block-Elemente durch Zeilenumbruch ersetzen
      let text = html
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<\/(div|p|h[1-6])>/gi, '\n')
        .replace(/<[^>]+>/g, '')
        .replace(/&nbsp;/g, ' ')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/\n{3,}/g, '\n\n');
      return text.split('\n').map(l => l.trim());
    }
    
    // Wort-Level Diff (LCS-basiert)
    function diffWords(oldWords, newWords) {
      const m = oldWords.length;
      const n = newWords.length;
      
      // Optimierung: leere Arrays
      if (m === 0 && n === 0) return [];
      if (m === 0) return newWords.map(w => ({ type: 'ins', word: w }));
      if (n === 0) return oldWords.map(w => ({ type: 'del', word: w }));
      
      // LCS-Tabelle (optimiert: nur 2 Zeilen)
      let prev = new Array(n + 1).fill(0);
      let curr = new Array(n + 1).fill(0);
      
      // Vollst√§ndige Tabelle f√ºr Backtracking
      const dp = [prev.slice()];
      for (let i = 1; i <= m; i++) {
        curr = new Array(n + 1).fill(0);
        for (let j = 1; j <= n; j++) {
          if (oldWords[i - 1] === newWords[j - 1]) {
            curr[j] = prev[j - 1] + 1;
          } else {
            curr[j] = Math.max(prev[j], curr[j - 1]);
          }
        }
        dp.push(curr.slice());
        prev = curr;
      }
      
      // Backtrack
      const result = [];
      let i = m, j = n;
      while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && oldWords[i - 1] === newWords[j - 1]) {
          result.unshift({ type: 'same', word: oldWords[i - 1] });
          i--; j--;
        } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
          result.unshift({ type: 'ins', word: newWords[j - 1] });
          j--;
        } else {
          result.unshift({ type: 'del', word: oldWords[i - 1] });
          i--;
        }
      }
      return result;
    }
    
    // Zeilen-Level Diff
    function diffLines(oldLines, newLines) {
      const m = oldLines.length;
      const n = newLines.length;
      
      if (m === 0 && n === 0) return [];
      if (m === 0) return newLines.map(l => ({ type: 'ins', line: l }));
      if (n === 0) return oldLines.map(l => ({ type: 'del', line: l }));
      
      const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (oldLines[i - 1] === newLines[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }
      
      // Backtrack (reine LCS-Diff: same/del/ins)
      const raw = [];
      let i = m, j = n;
      while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && oldLines[i - 1] === newLines[j - 1]) {
          raw.unshift({ type: 'same', oldLine: oldLines[i - 1], newLine: newLines[j - 1] });
          i--; j--;
        } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
          raw.unshift({ type: 'ins', line: newLines[j - 1] });
          j--;
        } else {
          raw.unshift({ type: 'del', line: oldLines[i - 1] });
          i--;
        }
      }
      
      // Post-processing: aufeinanderfolgende del+ins Paare als 'changed' zusammenfassen
      const result = [];
      let idx = 0;
      while (idx < raw.length) {
        if (idx + 1 < raw.length && raw[idx].type === 'del' && raw[idx + 1].type === 'ins'
            && raw[idx].line.length > 0 && raw[idx + 1].line.length > 0) {
          result.push({ type: 'changed', oldLine: raw[idx].line, newLine: raw[idx + 1].line });
          idx += 2;
        } else {
          result.push(raw[idx]);
          idx++;
        }
      }
      return result;
    }
    
    // Escaping f√ºr HTML-Anzeige
    function escHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    
    // Diff f√ºr eine Szene berechnen und als HTML rendern
    function computeDiffHtml(szeneId) {
      // Referenz-Fassung holen
      const refFassung = getReferenzFassung();
      if (!refFassung) return null;
      
      const oldHtml = refFassung.textbuch?.[szeneId] || '';
      const newHtml = state.textbuch[szeneId] || '';
      
      // Zu Textzeilen konvertieren
      const oldLines = htmlToTextLines(oldHtml);
      const newLines = htmlToTextLines(newHtml);
      
      // Zeilen-Diff
      const lineDiff = diffLines(oldLines, newLines);
      
      let html = '';
      let delCount = 0;
      let insCount = 0;
      
      lineDiff.forEach(entry => {
        if (entry.type === 'same') {
          // Unver√§nderte Zeile
          if (entry.oldLine.length > 0) {
            html += `<p style="margin:4px 0;">${escHtml(entry.oldLine)}</p>`;
          } else {
            html += `<p style="margin:4px 0;">&nbsp;</p>`;
          }
        } else if (entry.type === 'del') {
          // Komplett gel√∂schte Zeile
          if (entry.line.length > 0) {
            html += `<p style="margin:4px 0;"><span class="diff-deleted">${escHtml(entry.line)}</span></p>`;
            delCount++;
          }
        } else if (entry.type === 'ins') {
          // Komplett neue Zeile
          if (entry.line.length > 0) {
            html += `<p style="margin:4px 0;"><span class="diff-inserted">${escHtml(entry.line)}</span></p>`;
            insCount++;
          }
        } else if (entry.type === 'changed') {
          // Ge√§nderte Zeile: Wort-Level Diff
          const oldW = entry.oldLine.split(/(\s+)/).filter(w => w.trim().length > 0);
          const newW = entry.newLine.split(/(\s+)/).filter(w => w.trim().length > 0);
          const wordDiff = diffWords(oldW, newW);
          
          let lineHtml = '';
          wordDiff.forEach(wd => {
            if (wd.type === 'same') {
              lineHtml += escHtml(wd.word) + ' ';
            } else if (wd.type === 'del') {
              lineHtml += `<span class="diff-deleted">${escHtml(wd.word)}</span> `;
              delCount++;
            } else if (wd.type === 'ins') {
              lineHtml += `<span class="diff-inserted">${escHtml(wd.word)}</span> `;
              insCount++;
            }
          });
          html += `<p style="margin:4px 0;">${lineHtml.trim()}</p>`;
        }
      });
      
      return { html, delCount, insCount };
    }
    
    // Referenz-Fassung holen
    function getReferenzFassung() {
      if (!state.fassungen || state.fassungen.length === 0) return null;
      
      // Wenn eine bestimmte Referenz gesetzt ist
      if (state.referenzFassungId) {
        const ref = state.fassungen.find(f => f.id === state.referenzFassungId);
        if (ref) return ref;
      }
      
      // Standard: letzte gespeicherte Fassung
      return state.fassungen[state.fassungen.length - 1];
    }
    
    // Referenz-Fassung setzen
    function setReferenzFassung(fassungId) {
      state.referenzFassungId = fassungId || null;
      render();
    }
    
    // ============================================
    // SUCHEN & ERSETZEN
    // ============================================
    
    let searchReplaceVisible = false;
    
    function toggleSearchReplace() {
      searchReplaceVisible = !searchReplaceVisible;
      const existing = document.getElementById('search-replace-bar');
      if (existing) {
        existing.remove();
        searchReplaceVisible = false;
        clearSearchHighlights();
        return;
      }
      
      const toolbar = document.querySelector('.toolbar');
      if (!toolbar) return;
      
      const bar = document.createElement('div');
      bar.id = 'search-replace-bar';
      bar.style.cssText = 'display:flex; align-items:center; gap:8px; padding:6px 12px; background:#f8fafc; border-top:1px solid #e2e8f0; flex-wrap:wrap;';
      bar.innerHTML = `
        <input type="text" id="search-input" placeholder="Suchen..." 
               style="padding:4px 8px; border:1px solid #d1d5db; border-radius:4px; font-size:13px; width:180px;"
               oninput="doSearch()" onkeydown="if(event.key==='Enter'){event.preventDefault(); doSearchNext();}">
        <span id="search-count" style="font-size:11px; color:#6b7280; min-width:60px;"></span>
        <button onclick="doSearchNext()" style="padding:3px 8px; font-size:12px; border:1px solid #d1d5db; border-radius:4px; background:white; cursor:pointer;" title="N√§chster Treffer">‚ñº</button>
        <button onclick="doSearchPrev()" style="padding:3px 8px; font-size:12px; border:1px solid #d1d5db; border-radius:4px; background:white; cursor:pointer;" title="Vorheriger Treffer">‚ñ≤</button>
        <div style="width:1px; height:20px; background:#d1d5db;"></div>
        <input type="text" id="replace-input" placeholder="Ersetzen durch..." 
               style="padding:4px 8px; border:1px solid #d1d5db; border-radius:4px; font-size:13px; width:180px;">
        <button onclick="doReplace()" style="padding:3px 8px; font-size:12px; border:1px solid #d1d5db; border-radius:4px; background:white; cursor:pointer;">Ersetzen</button>
        <button onclick="doReplaceAll()" style="padding:3px 8px; font-size:12px; border:1px solid #d1d5db; border-radius:4px; background:white; cursor:pointer;">Alle</button>
        <button onclick="toggleSearchReplace()" style="padding:3px 8px; font-size:12px; border:none; background:none; cursor:pointer; color:#6b7280;" title="Schliessen">‚úï</button>
      `;
      toolbar.after(bar);
      
      setTimeout(() => document.getElementById('search-input')?.focus(), 50);
    }
    
    let searchMatches = [];
    let currentMatchIndex = -1;
    
    function doSearch() {
      clearSearchHighlights();
      const query = document.getElementById('search-input')?.value;
      const countEl = document.getElementById('search-count');
      if (!query || query.length < 2) {
        if (countEl) countEl.textContent = '';
        searchMatches = [];
        currentMatchIndex = -1;
        return;
      }
      
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // TreeWalker f√ºr Text-Nodes
      const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
      const textNodes = [];
      while (walker.nextNode()) textNodes.push(walker.currentNode);
      
      searchMatches = [];
      const queryLower = query.toLowerCase();
      
      textNodes.forEach(node => {
        const text = node.textContent.toLowerCase();
        let pos = 0;
        while ((pos = text.indexOf(queryLower, pos)) !== -1) {
          searchMatches.push({ node, start: pos, length: query.length });
          pos += query.length;
        }
      });
      
      if (countEl) countEl.textContent = searchMatches.length > 0 ? `${searchMatches.length} Treffer` : 'Keine Treffer';
      
      // Alle Treffer highlighten
      // R√ºckw√§rts durch die Matches, damit Positionen stabil bleiben
      for (let i = searchMatches.length - 1; i >= 0; i--) {
        const m = searchMatches[i];
        try {
          const range = document.createRange();
          range.setStart(m.node, m.start);
          range.setEnd(m.node, m.start + m.length);
          const mark = document.createElement('mark');
          mark.className = 'search-highlight';
          mark.style.cssText = 'background:#fde68a; padding:0 1px; border-radius:2px;';
          range.surroundContents(mark);
        } catch(e) { /* Skip if range crosses elements */ }
      }
      
      // Aktualisiere Matches-Liste nach Highlighting
      const marks = editor.querySelectorAll('mark.search-highlight');
      searchMatches = Array.from(marks);
      currentMatchIndex = searchMatches.length > 0 ? 0 : -1;
      
      if (currentMatchIndex >= 0) highlightCurrentMatch();
    }
    
    function highlightCurrentMatch() {
      // Alle auf Standard zur√ºck
      searchMatches.forEach(m => {
        if (m.style) m.style.background = '#fde68a';
      });
      // Aktuellen hervorheben
      if (currentMatchIndex >= 0 && currentMatchIndex < searchMatches.length) {
        const current = searchMatches[currentMatchIndex];
        current.style.background = '#f97316';
        current.style.color = 'white';
        current.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        const countEl = document.getElementById('search-count');
        if (countEl) countEl.textContent = `${currentMatchIndex + 1} / ${searchMatches.length}`;
      }
    }
    
    function doSearchNext() {
      if (searchMatches.length === 0) return;
      currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
      highlightCurrentMatch();
    }
    
    function doSearchPrev() {
      if (searchMatches.length === 0) return;
      currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
      highlightCurrentMatch();
    }
    
    function doReplace() {
      if (currentMatchIndex < 0 || currentMatchIndex >= searchMatches.length) return;
      const replaceWith = document.getElementById('replace-input')?.value || '';
      
      pushUndoImmediate();
      
      const mark = searchMatches[currentMatchIndex];
      mark.replaceWith(document.createTextNode(replaceWith));
      
      saveCurrentText();
      doSearch(); // Re-search
    }
    
    function doReplaceAll() {
      if (searchMatches.length === 0) return;
      const replaceWith = document.getElementById('replace-input')?.value || '';
      
      pushUndoImmediate();
      
      // R√ºckw√§rts ersetzen
      for (let i = searchMatches.length - 1; i >= 0; i--) {
        searchMatches[i].replaceWith(document.createTextNode(replaceWith));
      }
      
      saveCurrentText();
      
      const countEl = document.getElementById('search-count');
      if (countEl) countEl.textContent = 'Alle ersetzt';
      searchMatches = [];
      currentMatchIndex = -1;
    }
    
    function clearSearchHighlights() {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      const marks = editor.querySelectorAll('mark.search-highlight');
      marks.forEach(mark => {
        mark.replaceWith(document.createTextNode(mark.textContent));
      });
      // Adjazente Text-Nodes zusammenf√ºhren
      editor.normalize();
    }
    
    // v1.2: Text als gestrichen markieren
    function toggleGestrichen() {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const selectedText = range.toString().trim();
      if (!selectedText) return;
      
      // Undo speichern
      pushUndo();
      
      // Pr√ºfen ob bereits gestrichen
      const parentEl = range.commonAncestorContainer.parentElement;
      if (parentEl && parentEl.classList.contains('format-gestrichen')) {
        // Streichung entfernen
        const text = parentEl.textContent;
        parentEl.replaceWith(document.createTextNode(text));
      } else {
        // Streichung hinzuf√ºgen
        const span = document.createElement('span');
        span.className = 'format-gestrichen';
        span.textContent = selectedText;
        range.deleteContents();
        range.insertNode(span);
      }
      
      selection.removeAllRanges();
      saveCurrentText();
    }
    
    // NEU: Erg√§nzung markieren
    function toggleErgaenzung() {
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const selectedText = range.toString().trim();
      if (!selectedText) return;
      
      // Undo speichern
      pushUndo();
      
      // Pr√ºfen ob bereits Erg√§nzung
      const parentEl = range.commonAncestorContainer.parentElement;
      if (parentEl && parentEl.classList.contains('format-ergaenzung')) {
        // Erg√§nzung entfernen
        const text = parentEl.textContent;
        parentEl.replaceWith(document.createTextNode(text));
      } else {
        // Erg√§nzung hinzuf√ºgen
        const span = document.createElement('span');
        span.className = 'format-ergaenzung';
        span.textContent = selectedText;
        range.deleteContents();
        range.insertNode(span);
      }
      
      selection.removeAllRanges();
      saveCurrentText();
    }
    
    // NEU: Ansicht wechseln
    function setTextAnsicht(ansicht) {
      // Aktuellen Text speichern bevor Ansicht gewechselt wird
      if (state.textAnsicht !== 'aenderungen') {
        saveCurrentText();
      }
      state.textAnsicht = ansicht;
      render();
    }
    
    // NEU: Editor-Klassen basierend auf Ansicht
    function getEditorClasses() {
      const classes = ['editor-content'];
      
      switch (state.textAnsicht) {
        case 'schauspieler':
          // Keine Cues, keine √Ñnderungsmarkierungen
          classes.push('hide-cues', 'hide-aenderungen');
          break;
        case 'technik':
          // Cues sichtbar, Streichungen sichtbar
          break;
        case 'aenderungen':
          // Keine Cues, aber Streichungen und Erg√§nzungen sichtbar
          classes.push('hide-cues');
          break;
      }
      
      return classes.join(' ');
    }

    function execCommand(cmd, value = null) {
      // Undo speichern vor √Ñnderung
      pushUndo();
      document.execCommand(cmd, false, value);
      saveCurrentText();
    }
    
    // NEU: Text mit Cue-Markern anreichern (nur f√ºr Anzeige)
    function enrichTextWithCueMarkers(text, cues) {
      if (!cues || cues.length === 0) return text;
      
      let enrichedText = text;
      
      // Cues mit Ankertext sortieren nach L√§nge (l√§ngste zuerst, um √úberlappungen zu vermeiden)
      const cuesWithAnker = cues
        .filter(c => c.ankerText)
        .sort((a, b) => b.ankerText.length - a.ankerText.length);
      
      cuesWithAnker.forEach(cue => {
        const anker = cue.ankerText;
        const marker = `<span class="cue-inline-marker ${CUE_TYPEN[cue.typ]?.class || 'cue-lx'}" contenteditable="false" data-cue-id="${cue.id}" onclick="editCue('${cue.id}')">${CUE_TYPEN[cue.typ]?.prefix || ''}${cue.nummer}</span>`;
        
        // Ankertext im Text finden und Marker dahinter einf√ºgen
        // Nur das erste Vorkommen markieren
        const index = enrichedText.indexOf(anker);
        if (index !== -1) {
          const endIndex = index + anker.length;
          enrichedText = enrichedText.substring(0, endIndex) + marker + enrichedText.substring(endIndex);
        }
      });
      
      return enrichedText;
    }

    function saveCurrentText() {
      const editor = document.getElementById('text-editor');
      if (editor && state.aktiveSzene) {
        // Cue-Marker entfernen vor dem Speichern
        const content = stripCueMarkers(editor.innerHTML);
        state.textbuch[state.aktiveSzene] = content;
        saveProjektDaten();
      }
    }
    
    // NEU: Pr√ºft ob Cue-Anker noch im Text existieren
    function checkCueAnkers(szeneId) {
      const textContent = state.textbuch[szeneId] || '';
      // HTML-Tags entfernen f√ºr die Suche
      const plainText = textContent.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');
      
      const cuesInSzene = state.cues.filter(c => c.szeneId === szeneId && c.ankerText);
      const orphanedCues = [];
      
      cuesInSzene.forEach(cue => {
        // Ankertext normalisieren (Whitespace vereinheitlichen)
        const ankerNormalized = cue.ankerText.replace(/\s+/g, ' ').trim();
        if (!plainText.includes(ankerNormalized)) {
          orphanedCues.push(cue);
        }
      });
      
      return orphanedCues;
    }
    
    // NEU: Warnung anzeigen wenn Anker fehlen
    function showOrphanedCuesWarning(orphanedCues) {
      if (orphanedCues.length === 0) return;
      
      const cueList = orphanedCues.map(c => 
        `‚Ä¢ ${CUE_TYPEN[c.typ]?.prefix || ''}${c.nummer}: "${c.ankerText.substring(0, 50)}${c.ankerText.length > 50 ? '...' : ''}"`
      ).join('\n');
      
      const action = confirm(
        `‚ö†Ô∏è¬è Folgende Cues haben ihren Ankertext verloren:\n\n${cueList}\n\n` +
        `Der Text, an dem diese Cues positioniert waren, wurde ge√§ndert oder gel√∂scht.\n\n` +
        `Klicke OK, um die Cues zu bearbeiten und neu zu positionieren.\n` +
        `Klicke Abbrechen, um sp√§ter zu entscheiden.`
      );
      
      if (action && orphanedCues.length > 0) {
        // Ersten verwaisten Cue √∂ffnen
        editCue(orphanedCues[0].id);
      }
    }
    
    // NEU: Beim Szene-Wechsel pr√ºfen
    function selectSzeneWithCheck(szeneId) {
      // Erst alte Szene pr√ºfen
      if (state.aktiveSzene) {
        const orphaned = checkCueAnkers(state.aktiveSzene);
        if (orphaned.length > 0) {
          showOrphanedCuesWarning(orphaned);
        }
      }
      
      // Dann wechseln
      selectSzene(szeneId);
    }
    
    // NEU: Aktuelle Szene pr√ºfen (vom Button)
    function checkCurrentSzeneAnkers() {
      if (!state.aktiveSzene) {
        alert('Keine Szene ausgew√§hlt.');
        return;
      }
      
      const orphaned = checkCueAnkers(state.aktiveSzene);
      
      if (orphaned.length === 0) {
        const cuesWithAnker = state.cues.filter(c => c.szeneId === state.aktiveSzene && c.ankerText).length;
        if (cuesWithAnker === 0) {
          alert('‚úÖ Keine Cues mit Ankertexten in dieser Szene.\n\nTipp: Markiere Text und klicke üí°üîäüì∫ um Cues mit Textposition zu erstellen.');
        } else {
          alert(`‚úÖ Alle ${cuesWithAnker} Cue-Anker in dieser Szene sind g√ºltig!`);
        }
      } else {
        showOrphanedCuesWarning(orphaned);
      }
    }

    // ============================================
    // RENDER MAIN
    // ============================================
    // ============================================
    // KI-ASSISTENT FUNKTIONEN (v1.7)
    // ============================================
    
    // API-Key aus localStorage holen
    function getApiKey() {
      return localStorage.getItem('nina_rebu_api_key') || '';
    }
    
    // API-Key testen
    async function testApiKey() {
      const apiKey = getApiKey();
      if (!apiKey || !apiKey.trim()) {
        apiKeyError = 'Bitte zuerst einen Key eingeben';
        apiKeyStatus = 'error';
        render();
        return;
      }
      
      apiKeyStatus = 'testing';
      apiKeyError = '';
      render();
      
      try {
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 10,
            messages: [{ role: 'user', content: 'Antworte nur mit: OK' }]
          })
        });
        
        if (response.ok) {
          apiKeyStatus = 'success';
        } else {
          const err = await response.json();
          apiKeyStatus = 'error';
          if (response.status === 401) {
            apiKeyError = 'Ung√ºltiger API-Key';
          } else if (response.status === 403) {
            apiKeyError = 'Keine Berechtigung (Key gesperrt?)';
          } else if (err.error?.message) {
            apiKeyError = err.error.message;
          } else {
            apiKeyError = `Fehler ${response.status}`;
          }
        }
      } catch (err) {
        apiKeyStatus = 'error';
        apiKeyError = 'Netzwerkfehler ‚Äì bitte Verbindung pr√ºfen';
      }
      
      render();
    }
    
    // KI-Panel √∂ffnen/schliessen
    // v2.0: Projekt-Men√º Funktionen
    function toggleProjektMenu() {
      const menu = document.getElementById('projekt-menu');
      if (menu) {
        menu.classList.toggle('hidden');
        // Click au√üerhalb schlie√üt Men√º
        if (!menu.classList.contains('hidden')) {
          setTimeout(() => {
            document.addEventListener('click', closeProjektMenuOnClickOutside, { once: true });
          }, 10);
        }
      }
    }
    
    function closeProjektMenu() {
      const menu = document.getElementById('projekt-menu');
      if (menu) menu.classList.add('hidden');
    }
    
    function closeProjektMenuOnClickOutside(e) {
      const menu = document.getElementById('projekt-menu');
      if (menu && !menu.contains(e.target) && !e.target.closest('button[onclick*="toggleProjektMenu"]')) {
        menu.classList.add('hidden');
      }
    }
    
    // v2.0: Projekt-Liste anzeigen (Modal)
    function showProjektListe() {
      state.showProjektListeModal = true;
      render();
    }
    
    // v2.0: Handler f√ºr Cloud-Speichern Button
    function handleCloudSave() {
      closeProjektMenu();
      const istCloudProjekt = !!(currentCloudProjectId && isCloudMode);
      if (!cloudUser) {
        state.showCloudModal = true;
        render();
      } else if (istCloudProjekt) {
        alert('‚òÅÔ∏è Bereits in Cloud gespeichert!');
      } else {
        uploadToCloud();
      }
    }
    
    // v2.0: Handler f√ºr Cloud-Reload Button
    function handleCloudReload() {
      closeProjektMenu();
      const istCloudProjekt = !!(currentCloudProjectId && isCloudMode);
      if (istCloudProjekt) {
        forceCloudSync();
      }
    }
    
    // v2.0: Warnung beim Schlie√üen (nur f√ºr lokale Projekte)
    window.addEventListener('beforeunload', function(e) {
      const hatDaten = state.szenen?.length > 0 || state.figuren?.length > 0;
      
      // Nur warnen wenn: Daten vorhanden UND nicht k√ºrzlich exportiert
      if (hatDaten && state.dirty) {
        const message = '‚ö†Ô∏è Du hast ungespeicherte √Ñnderungen!\n\nBitte exportiere dein Projekt (Backup oder Word), bevor du das Fenster schliesst.';
        e.preventDefault();
        e.returnValue = message;
        return message;
      }
    });

    function toggleKiPanel() {
      const apiKey = getApiKey();
      if (!apiKey) {
        alert('Bitte zuerst einen API-Key in den Projekt-Einstellungen hinterlegen.\n\n‚Üí Klicke auf "‚öôÔ∏è Einst." in der linken Sidebar.');
        return;
      }
      
      state.kiPanelOpen = !state.kiPanelOpen;
      
      // Bei erstem √ñffnen: Begr√ºssung hinzuf√ºgen
      if (state.kiPanelOpen && state.kiMessages.length === 0) {
        state.kiMessages.push({
          role: 'assistant',
          content: `üëã Hallo! Ich bin dein KI-Assistent f√ºr das Regiebuch.

Ich kann dir helfen mit:
‚Ä¢ **Szenen analysieren** ‚Äì "Was ist das Ziel dieser Szene?"
‚Ä¢ **Figuren entwickeln** ‚Äì "Welche Motivation hat diese Figur?"
‚Ä¢ **Dialoge verbessern** ‚Äì "Wie k√∂nnte dieser Dialog nat√ºrlicher klingen?"
‚Ä¢ **Regieanweisungen** ‚Äì "Schlage Regieanweisungen f√ºr diese Szene vor"
‚Ä¢ **Fragen beantworten** ‚Äì Alles rund um Theater und Dramaturgie

Was m√∂chtest du tun?`
        });
      }
      
      render();
    }
    
    // Kontext f√ºr KI zusammenstellen
    function buildKiContext() {
      let context = `Du bist ein erfahrener Dramaturg und Theaterassistent. Du hilfst beim Erstellen eines Regiebuchs.

PROJEKT: "${state.projektMeta?.titel || 'Unbenannt'}"
${state.projektMeta?.untertitel ? `Untertitel: ${state.projektMeta.untertitel}` : ''}
${state.projektMeta?.autor ? `Autor: ${state.projektMeta.autor}` : ''}
${state.projektMeta?.logline ? `Logline: ${state.projektMeta.logline}` : ''}

`;
      
      // Figuren
      if (state.figuren.length > 0) {
        context += `FIGUREN (${state.figuren.length}):\n`;
        state.figuren.forEach(f => {
          context += `- ${f.name}${f.kuerzel ? ` (${f.kuerzel})` : ''}: ${f.beschreibung || 'Keine Beschreibung'}`;
          if (f.want) context += ` | Will: ${f.want}`;
          if (f.need) context += ` | Braucht: ${f.need}`;
          context += '\n';
        });
        context += '\n';
      }
      
      // Aktuelle Szene
      if (state.aktiveSzene) {
        const szene = state.szenen.find(s => s.id === state.aktiveSzene);
        if (szene) {
          context += `AKTUELLE SZENE: ${szene.nummer} "${szene.titel}"
Ort: ${szene.ort || '-'} | Zeit: ${szene.zeit || '-'}
${szene.zusammenfassung ? `Zusammenfassung: ${szene.zusammenfassung}` : ''}
`;
          
          // Figuren der Szene
          const figurenNamen = szene.figuren?.map(fId => {
            const f = state.figuren.find(fig => fig.id === fId);
            return f?.name;
          }).filter(Boolean).join(', ');
          if (figurenNamen) context += `Figuren in Szene: ${figurenNamen}\n`;
          
          // Text der Szene (gek√ºrzt)
          const szenenText = state.textbuch[state.aktiveSzene];
          if (szenenText) {
            // HTML zu Text konvertieren
            const tmp = document.createElement('div');
            tmp.innerHTML = szenenText;
            let plainText = tmp.textContent || tmp.innerText || '';
            // Auf max 2000 Zeichen k√ºrzen
            if (plainText.length > 2000) {
              plainText = plainText.substring(0, 2000) + '... [gek√ºrzt]';
            }
            context += `\nSZENEN-TEXT:\n${plainText}\n`;
          }
        }
      }
      
      // Alle Szenen (√úbersicht)
      if (state.szenen.length > 0) {
        context += `\nALLE SZENEN (${state.szenen.length}):\n`;
        state.szenen.forEach(s => {
          context += `- ${s.nummer} "${s.titel}"${s.ort ? ` @ ${s.ort}` : ''}\n`;
        });
      }
      
      return context;
    }
    
    // Nachricht an KI senden
    async function sendKiMessage(userMessage) {
      if (!userMessage?.trim()) return;
      
      const apiKey = getApiKey();
      if (!apiKey) {
        alert('Bitte zuerst einen API-Key in den Einstellungen hinterlegen.');
        return;
      }
      
      // User-Nachricht hinzuf√ºgen
      state.kiMessages.push({ role: 'user', content: userMessage.trim() });
      state.kiInput = '';
      state.kiLoading = true;
      render();
      
      // Scroll nach unten
      setTimeout(() => {
        const messagesDiv = document.getElementById('ki-messages');
        if (messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }, 50);
      
      try {
        // Kontext aufbauen
        const systemPrompt = buildKiContext() + `

WICHTIGE REGELN:
- Antworte auf Deutsch
- Sei hilfreich, pr√§zise und kreativ
- Bei Szenen-Analysen: Gehe auf dramaturgische Aspekte ein (Ziel, Konflikt, Wendepunkte)
- Bei Dialog-Verbesserungen: Biete konkrete Alternativen an
- Formatiere mit **fett** f√ºr wichtige Begriffe
- Halte Antworten kompakt (max. 300 W√∂rter), ausser bei kreativen Aufgaben`;
        
        // Nachrichten f√ºr API vorbereiten (ohne lokale Begr√ºssung)
        const apiMessages = state.kiMessages
          .filter(m => !m.isLocal)
          .map(m => ({ role: m.role, content: m.content }));
        
        // API-Aufruf
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 2000,
            system: systemPrompt,
            messages: apiMessages
          })
        });
        
        if (!response.ok) {
          const errText = await response.text();
          let errMsg = 'API-Fehler';
          try {
            const errJson = JSON.parse(errText);
            errMsg = errJson.error?.message || errMsg;
            if (errMsg.includes('invalid x-api-key') || errMsg.includes('invalid_api_key')) {
              errMsg = 'Ung√ºltiger API-Key. Bitte √ºberpr√ºfe den Key in den Einstellungen.';
            } else if (errMsg.includes('rate_limit')) {
              errMsg = 'Zu viele Anfragen. Bitte warte kurz und versuche es erneut.';
            } else if (errMsg.includes('credit') || errMsg.includes('billing')) {
              errMsg = 'Kein API-Guthaben mehr. Bitte pr√ºfe dein Anthropic-Konto.';
            }
          } catch (e) {
            errMsg = errText.substring(0, 200);
          }
          throw new Error(errMsg);
        }
        
        const result = await response.json();
        
        // Antwort extrahieren
        let fullText = '';
        for (const block of result.content) {
          if (block.type === 'text') {
            fullText += block.text;
          }
        }
        
        // Antwort hinzuf√ºgen
        state.kiMessages.push({ role: 'assistant', content: fullText.trim() });
        
      } catch (err) {
        console.error('KI-Fehler:', err);
        state.kiMessages.push({ 
          role: 'assistant', 
          content: `‚ùå Fehler: ${err.message}\n\nüí° Bitte pr√ºfe deinen API-Key in den Projekt-Einstellungen.`
        });
      } finally {
        state.kiLoading = false;
        render();
        
        // Scroll nach unten
        setTimeout(() => {
          const messagesDiv = document.getElementById('ki-messages');
          if (messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }, 50);
      }
    }
    
    // KI-Panel rendern
    function renderKiPanel() {
      const hasApiKey = !!getApiKey();
      
      return `
        <!-- KI Toggle Button -->
        <button class="ki-toggle-btn ${hasApiKey ? 'has-key' : ''} ${state.kiPanelOpen ? 'panel-open' : ''}" 
                onclick="toggleKiPanel()" 
                title="${hasApiKey ? 'KI-Assistent √∂ffnen' : 'API-Key ben√∂tigt'}">
          ü§ñ
        </button>
        
        <!-- KI Panel -->
        <div class="ki-panel ${state.kiPanelOpen ? 'open' : ''}">
          <div class="ki-panel-header">
            <h3>ü§ñ KI-Assistent</h3>
            <div style="display: flex; gap: 0.5rem;">
              <button onclick="state.kiMessages = []; toggleKiPanel(); toggleKiPanel();" title="Chat leeren">üóëÔ∏è</button>
              <button onclick="toggleKiPanel()" title="Schliessen">‚úï</button>
            </div>
          </div>
          
          <div class="ki-messages" id="ki-messages">
            ${state.kiMessages.length === 0 && !state.kiLoading ? `
              <div style="text-align: center; color: #9ca3af; padding: 2rem;">
                <div style="font-size: 2rem; margin-bottom: 0.5rem;">üé≠</div>
                <p>Starte eine Unterhaltung mit dem KI-Assistenten.</p>
              </div>
            ` : ''}
            
            ${state.kiMessages.map((msg, i) => `
              <div class="ki-message ${msg.role}">
                ${msg.content.split('\n').map(line => {
                  // Markdown-√§hnliche Formatierung
                  const formatted = line.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                  return `<p>${formatted}</p>`;
                }).join('')}
              </div>
            `).join('')}
            
            ${state.kiLoading ? `
              <div class="ki-message assistant loading">
                <span class="typing-indicator">‚óè‚óè‚óè</span>
              </div>
            ` : ''}
          </div>
          
          <div class="ki-input-area">
            <textarea 
              id="ki-input"
              placeholder="Frage stellen... (Enter zum Senden)"
              rows="2"
              onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendKiMessage(this.value); }"
              ${state.kiLoading ? 'disabled' : ''}
            >${state.kiInput}</textarea>
            <div class="ki-input-actions">
              <button class="btn btn-sm btn-outline flex-1" 
                      onclick="state.kiMessages = []; render();"
                      ${state.kiLoading || state.kiMessages.length === 0 ? 'disabled' : ''}>
                üóëÔ∏è Leeren
              </button>
              <button class="btn btn-sm btn-primary flex-1" 
                      onclick="sendKiMessage(document.getElementById('ki-input').value)"
                      ${state.kiLoading ? 'disabled' : ''}>
                Senden
              </button>
            </div>
          </div>
        </div>
      `;
    }

    // ============================================
    // CLOUD MODAL
    // ============================================
    // v2.0: Projekt-Liste Modal (√ñffnen...)
    function renderProjektListeModal() {
      const alleProjekte = load(KEYS.projekte, []);
      
      // Cloud-Projekte hinzuf√ºgen die noch nicht lokal sind
      if (cloudUser && cloudProjects.length > 0) {
        cloudProjects.forEach(cp => {
          const localId = 'cloud_' + cp.id;
          if (!alleProjekte.find(p => p.id === localId || p.cloudId === cp.id)) {
            alleProjekte.push({ id: localId, cloudId: cp.id, name: cp.name, isCloudOnly: true });
          }
        });
      }
      
      // Projekte mit Cloud-Status markieren
      const projekteAngereichert = alleProjekte.map(p => ({
        ...p,
        istCloud: !!(p.cloudId || p.id?.startsWith('cloud_')),
      }));
      
      return `
        <div class="modal-overlay" onclick="state.showProjektListeModal = false; render()">
          <div class="modal-content" style="max-width: 500px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h3>üìÇ Projekt √∂ffnen</h3>
              <button class="modal-close" onclick="state.showProjektListeModal = false; render()">√ó</button>
            </div>
            <div class="p-4">
              ${projekteAngereichert.length === 0 ? `
                <div class="text-center py-8 text-gray-500">
                  <div class="text-4xl mb-2">üìÅ</div>
                  <p>Keine Projekte vorhanden</p>
                  <button class="btn btn-primary mt-4" onclick="state.showProjektListeModal = false; openProjektModal()">
                    + Neues Projekt erstellen
                  </button>
                </div>
              ` : `
                <div class="space-y-2 max-h-96 overflow-y-auto">
                  ${projekteAngereichert.map(p => `
                    <div class="flex items-center justify-between p-3 rounded-lg border ${p.id === state.projektId ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:bg-gray-50'} cursor-pointer"
                         onclick="${p.isCloudOnly ? `selectCloudProject('${p.cloudId}')` : `wechsleProjekt('${p.id}')`}; state.showProjektListeModal = false; render()">
                      <div class="flex items-center gap-3">
                        <span class="text-xl" title="${p.istCloud ? 'Cloud-Projekt (sicher)' : 'Lokales Projekt (nur Browser)'}">
                          ${p.istCloud ? '‚òÅÔ∏è' : 'üíæ'}
                        </span>
                        <div>
                          <div class="font-medium">${p.name || 'Unbenannt'}</div>
                          <div class="text-xs text-gray-500">${p.istCloud ? 'In Cloud gespeichert' : 'Nur lokal'}</div>
                        </div>
                      </div>
                      ${p.id === state.projektId ? '<span class="text-xs text-blue-600">Aktiv</span>' : ''}
                    </div>
                  `).join('')}
                </div>
                
                <div class="mt-4 pt-4 border-t flex gap-2">
                  <button class="btn btn-outline flex-1" onclick="state.showProjektListeModal = false; openProjektModal()">
                    + Neues Projekt
                  </button>
                  ${cloudUser ? `
                    <button class="btn btn-primary flex-1" onclick="state.showProjektListeModal = false; createCloudProjectSimple()">
                      ‚òÅÔ∏è Neues Cloud-Projekt
                    </button>
                  ` : `
                    <button class="btn btn-outline flex-1" onclick="state.showProjektListeModal = false; state.showCloudModal = true; render()">
                      ‚òÅÔ∏è Cloud-Login
                    </button>
                  `}
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }
    
    function renderCloudModal() {
      const lokaleProj = load(KEYS.projekte, []).filter(p => !p.id?.startsWith('cloud_'));
      const aktuellesProjekt = lokaleProj.find(p => p.id === state.projektId);
      const hatCloudId = aktuellesProjekt?.cloudId;
      
      return `
        <div class="modal-overlay" onclick="state.showCloudModal = false; render()">
          <div class="modal-content" style="max-width: 600px; max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h3>‚òÅÔ∏è Cloud-Synchronisation</h3>
              <button class="modal-close" onclick="state.showCloudModal = false; render()">√ó</button>
            </div>
            <div class="p-4">
              ${cloudUser ? `
                <!-- Eingeloggt -->
                <div class="bg-green-50 border border-green-200 rounded-lg p-3 mb-4">
                  <div class="flex items-center justify-between">
                    <div>
                      <div class="text-green-700 font-medium">‚úì Eingeloggt</div>
                      <div class="text-green-600 text-sm">${cloudUser.email}</div>
                    </div>
                    <button class="btn btn-sm btn-outline" onclick="cloudLogout()">Ausloggen</button>
                  </div>
                </div>
                
                <!-- Cloud-Projekte -->
                <div class="mb-4">
                  <h4 class="font-semibold mb-2">‚òÅÔ∏è Cloud-Projekte (${cloudProjects.length})</h4>
                  ${cloudProjects.length === 0 ? `
                    <div class="text-gray-500 text-sm py-4 text-center">Keine Cloud-Projekte vorhanden</div>
                  ` : `
                    <div class="space-y-2 max-h-48 overflow-y-auto">
                      ${cloudProjects.map(p => `
                        <div class="flex items-center justify-between p-2 bg-gray-50 rounded ${currentCloudProjectId === p.id ? 'ring-2 ring-blue-500' : ''}">
                          <div>
                            <div class="font-medium">${escapeHtml(p.name)}</div>
                            ${p.author ? `<div class="text-xs text-gray-500">${escapeHtml(p.author)}</div>` : ''}
                          </div>
                          <div class="flex gap-1">
                            <button class="btn btn-xs btn-primary" onclick="selectCloudProject('${p.id}'); state.showCloudModal = false; render()">
                              √ñffnen
                            </button>
                            <button class="btn btn-xs btn-outline text-red-500" onclick="deleteCloudProject('${p.id}')">
                              üóëÔ∏è
                            </button>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  `}
                </div>
                
                <!-- Neues Cloud-Projekt -->
                <div class="mb-4 p-3 bg-blue-50 rounded-lg">
                  <h4 class="font-semibold mb-2">+ Neues Cloud-Projekt</h4>
                  <div class="flex gap-2">
                    <input type="text" id="cloud_projekt_name" placeholder="Projektname" 
                           class="flex-1 px-3 py-2 border rounded text-sm">
                    <button class="btn btn-primary" onclick="createCloudProject()">
                      Erstellen
                    </button>
                  </div>
                </div>
                
                <!-- Lokales Projekt hochladen -->
                ${state.projektId && typeof state.projektId === 'string' && !state.projektId.startsWith('cloud_') ? `
                  <div class="p-3 bg-yellow-50 rounded-lg">
                    <h4 class="font-semibold mb-2">‚¨ÜÔ∏è Aktuelles Projekt hochladen</h4>
                    <p class="text-sm text-gray-600 mb-2">
                      "${escapeHtml(state.projektMeta?.titel || 'Unbenannt')}" in die Cloud hochladen
                    </p>
                    <button class="btn btn-warning" onclick="uploadProjectToCloud()">
                      ‚òÅÔ∏è In Cloud hochladen
                    </button>
                  </div>
                ` : ''}
                
              ` : `
                <!-- Nicht eingeloggt - Login Form -->
                <div class="space-y-4">
                  <div>
                    <label class="block text-sm font-medium mb-1">E-Mail</label>
                    <input type="email" id="cloud_email" class="w-full px-3 py-2 border rounded">
                  </div>
                  <div>
                    <label class="block text-sm font-medium mb-1">Passwort</label>
                    <input type="password" id="cloud_password" class="w-full px-3 py-2 border rounded">
                  </div>
                  <div class="flex gap-2">
                    <button class="btn btn-primary flex-1" onclick="cloudLogin(document.getElementById('cloud_email').value, document.getElementById('cloud_password').value)">
                      Einloggen
                    </button>
                    <button class="btn btn-outline flex-1" onclick="toggleRegisterFields()">
                      Registrieren
                    </button>
                  </div>
                  
                  <div id="register_fields" class="hidden space-y-2 pt-2 border-t">
                    <div>
                      <label class="block text-sm font-medium mb-1">Name</label>
                      <input type="text" id="cloud_name" class="w-full px-3 py-2 border rounded">
                    </div>
                    <button class="btn btn-success w-full" onclick="cloudRegister(document.getElementById('cloud_email').value, document.getElementById('cloud_password').value, document.getElementById('cloud_name').value)">
                      Konto erstellen
                    </button>
                  </div>
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }
    
    function toggleRegisterFields() {
      const fields = document.getElementById('register_fields');
      if (fields) fields.classList.toggle('hidden');
    }

    function render() {
      const app = document.getElementById('app');
      app.innerHTML = `
        <div class="flex h-screen">
          ${renderSidebar()}
          
          <div class="flex-1 flex flex-col overflow-hidden">
            ${renderHeader()}
            
            <div class="flex-1 flex overflow-hidden">
              ${renderMainContent()}
            </div>
          </div>
        </div>
        
        ${state.showImportModal ? renderImportModal() : ''}
        ${state.showExportModal ? renderExportModal() : ''}
        ${state.showFassungModal ? renderFassungModal() : ''}
        ${state.showFigurModal ? renderFigurModal() : ''}
        ${state.showCueModal ? renderCueModal() : ''}
        ${state.showSzeneModal ? renderSzeneModal() : ''}
        ${state.showKostuemModal ? renderKostuemModal() : ''}
        ${state.showRequisitenModal ? renderRequisitenModal() : ''}
        ${state.showBuehneModal ? renderBuehneModal() : ''}
        ${state.showLightbox ? renderLightbox() : ''}
        ${showCueExportDialog ? renderCueExportDialog() : ''}
        ${state.showProjektModal ? renderProjektModal() : ''}
        ${state.showCloudModal ? renderCloudModal() : ''}
        ${state.showProjektListeModal ? renderProjektListeModal() : ''}
        ${renderKiPanel()}
      `;
      
      // Event-Listener f√ºr Editor
      const editor = document.getElementById('text-editor');
      if (editor) {
        // Standard-Absatztrenner auf <p> setzen (statt <div>)
        try { document.execCommand('defaultParagraphSeparator', false, 'p'); } catch(e) {}
        
        editor.addEventListener('input', () => {
          saveCurrentText();
          debouncedPushUndo(); // Undo-Snapshot nach Tipp-Pause
        });
        editor.addEventListener('blur', () => saveCurrentText());
        
        // Paste: Undo-Snapshot + optionale Bereinigung
        editor.addEventListener('paste', (e) => {
          pushUndoImmediate();
        });
        
        // Enter-Handling: saubere Abs√§tze erzeugen
        editor.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            pushUndo();
            
            // Aktuellen Absatz und seine Klasse finden
            let currentBlock = selection.anchorNode;
            while (currentBlock && currentBlock !== editor) {
              if (currentBlock.nodeType === 1 && (currentBlock.tagName === 'P' || currentBlock.tagName === 'DIV')) break;
              currentBlock = currentBlock.parentNode;
            }
            
            const currentClass = currentBlock?.className || '';
            const isDialog = currentClass.includes('format-dialog');
            
            // Range: alles ab Cursor bis Ende des Absatzes
            const range = selection.getRangeAt(0);
            const afterRange = document.createRange();
            afterRange.setStart(range.endContainer, range.endOffset);
            if (currentBlock && currentBlock !== editor) {
              afterRange.setEndAfter(currentBlock.lastChild || currentBlock);
            } else {
              afterRange.setEnd(range.endContainer, range.endOffset);
            }
            
            // Inhalt nach Cursor extrahieren
            const afterContent = afterRange.extractContents();
            const afterText = afterContent.textContent.trim();
            
            // Neues Element erstellen
            const newEl = document.createElement('p');
            
            if (isDialog && afterText) {
              // Dialog-Absatz: neuer Absatz wird Standard (Fliesstext weiter)
              newEl.className = 'format-dialog';
              // Gleiche Figur beibehalten
              const figurSpan = currentBlock.querySelector('.figur-name');
              const figurName = figurSpan ? figurSpan.textContent : '';
              newEl.innerHTML = `<span class="figur-name">${figurName}</span><span class="dialog-text">${afterText}</span>`;
            } else if (afterText) {
              // Gleiche Klasse beibehalten
              newEl.className = currentClass.replace('format-dialog', '').trim() || 'format-standard';
              newEl.appendChild(afterContent);
            } else {
              // Leerer neuer Absatz: Standard-Format
              newEl.className = 'format-standard';
              newEl.innerHTML = '<br>';
            }
            
            // Neues Element nach aktuellem einf√ºgen
            if (currentBlock && currentBlock !== editor && currentBlock.parentNode) {
              currentBlock.parentNode.insertBefore(newEl, currentBlock.nextSibling);
            } else {
              editor.appendChild(newEl);
            }
            
            // Cursor an Anfang des neuen Elements setzen
            const newRange = document.createRange();
            if (newEl.querySelector('.dialog-text')) {
              newRange.setStart(newEl.querySelector('.dialog-text'), 0);
            } else if (newEl.firstChild) {
              newRange.setStart(newEl.firstChild, 0);
            } else {
              newRange.setStart(newEl, 0);
            }
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
            
            saveCurrentText();
            return;
          }
          
          if (e.ctrlKey || e.metaKey) {
            // Undo/Redo
            if (e.key === 'z' && !e.shiftKey) {
              e.preventDefault();
              undo();
            } else if ((e.key === 'z' && e.shiftKey) || e.key === 'y') {
              e.preventDefault();
              redo();
            }
            
            // Suchen & Ersetzen (Ctrl+H oder Ctrl+F)
            if (e.key === 'h' || e.key === 'f') {
              e.preventDefault();
              toggleSearchReplace();
            }
            
            // Format-Shortcuts (Ctrl+Shift+Buchstabe)
            if (e.shiftKey) {
              const formatMap = {
                'd': 'dialog',
                'r': 'regieanweisung',
                't': 'szeneTitel',
                'a': 'aktTitel',
                'l': 'lied',
                'v': 'vers',
                'p': 'pause',
                'n': 'standard'
              };
              const format = formatMap[e.key.toLowerCase()];
              if (format) {
                e.preventDefault();
                applyFormat(format);
              }
            }
          }
        });
      }
      
      updateUndoButtons();
      
      // Initialer Undo-Snapshot setzen
      const editorInit = document.getElementById('text-editor');
      if (editorInit && state.aktiveSzene) {
        lastUndoContent = stripCueMarkers(editorInit.innerHTML);
        if (state.undoStack.length === 0) {
          pushUndo();
        }
      }
      
      // Bottom-Player wiederherstellen wenn etwas spielt
      if (state.currentlyPlaying && state.currentView === 'textbuch') {
        requestAnimationFrame(() => updateBottomPlayer());
      }
    }

    function renderSidebar() {
      const navItems = [
        { id: 'titelblatt', icon: 'üìñ', label: 'Titelblatt' },
        { id: 'textbuch', icon: 'üìù', label: 'Textbuch' },
        { id: 'szenen', icon: 'üé¨', label: 'Szenen' },
        { id: 'figuren', icon: 'üë§', label: 'Figuren' },
        { id: 'buehne', icon: 'üé™', label: 'B√ºhne' },
        { id: 'requisiten', icon: 'üé≠', label: 'Requisiten' },
        { id: 'kostueme', icon: 'üëó', label: 'Kost√ºme' },
        { id: 'medien', icon: 'üéµ', label: 'Medien' },
        { id: 'fassungen', icon: 'üìö', label: 'Fassungen' },
        { id: 'konzept', icon: 'üß≠', label: 'Konzept' },
        { id: 'teamproben', icon: 'üë•', label: 'Team & Proben' },
      ];
      
      // Cloud-Status ermitteln
      const istCloudProjekt = !!(currentCloudProjectId && isCloudMode);
      const istEingeloggt = !!cloudUser;
      const projektTitel = state.projektMeta?.titel || 'Unbenannt';
      
      return `
        <div class="sidebar w-56 flex flex-col text-white">
          <!-- Logo (gr√∂√üer) -->
          <div class="p-4 border-b border-white/10">
            <div class="text-center">
              <img src="nina-logo.jpg" alt="N!NA" class="h-24 w-auto mx-auto mb-2" />
              <div class="font-bold text-lg">N!NA-Rebu</div>
              <div class="text-xs text-blue-300">Regiebuch v2.4</div>
            </div>
          </div>
          
          <!-- Projekt-Men√º (Datei-Men√º Stil) -->
          <div class="p-3 border-b border-white/10">
            <div class="relative">
              <button class="w-full text-left px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 flex items-center justify-between"
                      onclick="toggleProjektMenu()">
                <div class="flex items-center gap-2 flex-1 min-w-0">
                  <span>${istCloudProjekt ? '‚òÅÔ∏è' : 'üíæ'}</span>
                  <span class="truncate font-medium">${projektTitel}</span>
                </div>
                <span class="text-gray-400">‚ñº</span>
              </button>
              
              <!-- Dropdown Men√º -->
              <div id="projekt-menu" class="hidden absolute left-0 right-0 top-full mt-1 bg-slate-800 rounded-lg shadow-xl z-50 py-1 text-sm">
                <!-- Neu & √ñffnen -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openProjektModal()">
                  <span>üìÑ</span> Neues Projekt...
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); showProjektListe()">
                  <span>üìÇ</span> √ñffnen...
                </button>
                
                <div class="border-t border-white/10 my-1"></div>
                
                <!-- Speichern -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); saveProjektDaten(); alert('üíæ Lokal gespeichert!')">
                  <span>üíæ</span> Speichern
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openModal('showFassungModal')">
                  <span>üìë</span> Fassung speichern...
                </button>
                
                <div class="border-t border-white/10 my-1"></div>
                
                <!-- Cloud -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3 ${!istEingeloggt ? 'opacity-40' : ''}" 
                        onclick="handleCloudSave()"
                        title="${!istEingeloggt ? 'Erst einloggen' : ''}">
                  <span>‚òÅÔ∏è</span> ${istCloudProjekt ? 'In Cloud gespeichert ‚úì' : 'In Cloud speichern...'}
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3 ${!istCloudProjekt ? 'opacity-40' : ''}" 
                        onclick="handleCloudReload()"
                        title="${!istCloudProjekt ? 'Nur f√ºr Cloud-Projekte' : 'Lokale Daten mit Cloud √ºberschreiben'}">
                  <span>üîÑ</span> Von Cloud neu laden
                </button>
                
                <div class="border-t border-white/10 my-1"></div>
                
                <!-- Import/Export -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openModal('showImportModal')">
                  <span>‚¨áÔ∏è</span> Importieren...
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openModal('showExportModal')">
                  <span>‚¨ÜÔ∏è</span> Exportieren...
                </button>
                
                <div class="border-t border-white/10 my-1"></div>
                
                <!-- Einstellungen & L√∂schen -->
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3" onclick="closeProjektMenu(); openProjektModal(state.projektId)">
                  <span>‚öôÔ∏è</span> Projekteinstellungen...
                </button>
                <button class="w-full text-left px-4 py-2 hover:bg-slate-700 flex items-center gap-3 text-red-400" onclick="closeProjektMenu(); deleteProjekt(state.projektId)">
                  <span>üóëÔ∏è</span> Projekt l√∂schen
                </button>
              </div>
            </div>
            
            <!-- Status-Anzeige -->
            <div class="flex items-center justify-between mt-2 text-xs">
              <span class="text-gray-400">${state.projektMeta?.fassung || 'Arbeitsfassung'}</span>
              <span class="${istCloudProjekt ? 'text-green-400' : 'text-yellow-400'}">
                ${istCloudProjekt ? '‚òÅÔ∏è Cloud' : 'üíæ Lokal'}
              </span>
            </div>
          </div>
          
          <!-- Navigation -->
          <nav class="flex-1 py-2 overflow-y-auto">
            <div class="px-3 py-2">
              <div class="nav-section">Module</div>
            </div>
            ${navItems.map(item => `
              <div class="nav-item ${state.currentView === item.id ? 'active' : ''} px-3 py-2 flex items-center gap-2"
                   onclick="navigateTo('${item.id}')">
                <span>${item.icon}</span>
                <span class="text-sm">${item.label}</span>
              </div>
            `).join('')}
          </nav>
          
          <!-- KI-Assistent -->
          <div class="p-3 border-t border-white/10">
            <button class="btn btn-sm w-full ${getApiKey() ? 'btn-purple' : 'btn-outline-light'}" 
                    onclick="toggleKiPanel()"
                    title="${getApiKey() ? 'KI-Assistent √∂ffnen' : 'API-Key in Einstellungen hinterlegen'}">
              ü§ñ KI-Assistent ${getApiKey() ? '' : '(Key fehlt)'}
            </button>
          </div>
          
          <!-- Cloud-Login Status -->
          <div class="p-3 border-t border-white/10 text-xs">
            ${cloudUser ? `
              <div class="flex items-center justify-between">
                <span class="text-green-400 truncate" title="${cloudUser.email}">‚òÅÔ∏è ${cloudUser.email}</span>
                <button class="text-gray-400 hover:text-white" onclick="cloudLogout()">Logout</button>
              </div>
            ` : `
              <button class="w-full text-center text-gray-400 hover:text-white" onclick="state.showCloudModal = true; render()">
                ‚òÅÔ∏è Cloud-Login
              </button>
            `}
          </div>
        </div>
      `;
    }

        function renderHeader() {
      const isCloudProject = currentCloudProjectId && isCloudMode;
      const projektName = state.projektMeta?.titel || 'Neues Projekt';
      return `
        <header class="bg-white border-b border-gray-200 px-4 py-3 flex items-center justify-between">
          <div>
            <h1 class="text-xl font-bold text-gray-800">${getViewTitle()}</h1>
            <p class="text-sm text-gray-500">${getViewSubtitle()}</p>
          </div>
          <div class="flex items-center gap-3">
            <span class="px-2 py-1 ${isCloudProject ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'} rounded-full text-xs font-medium">
              ${isCloudProject ? '‚òÅÔ∏è' : 'üíæ'} ${projektName}
            </span>
            <button class="text-xs text-gray-500 hover:text-blue-600" onclick="openProjektModal(state.projektId)" title="Struktur bearbeiten">
              ‚öôÔ∏è ${(state.projektMeta.eigeneGruppen || []).length} Teile
            </button>
            <span class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-sm font-medium">
              ${state.projektMeta.fassung || 'Arbeitsfassung'}
            </span>
          </div>
        </header>
      `;
    }
    
    function getViewTitle() {
      const titles = {
        textbuch: 'üìù Textbuch',
        szenen: 'üé¨ Szenen',
        figuren: 'üë§ Figuren',
        cues: 'üí° Cue-Listen',
        requisiten: 'üé≠ Requisiten',
        kostueme: 'üëó Kost√ºme',
        medien: 'üìÅ Medien',
        fassungen: 'üìö Fassungen',
      };
      return titles[state.currentView] || 'N!NA-Rebu';
    }

    function getViewSubtitle() {
      const szene = state.szenen.find(s => s.id === state.aktiveSzene);
      if (state.currentView === 'textbuch' && szene) {
        return `Szene ${szene.nummer}: ${szene.titel}`;
      }
      return `${state.szenen.length} Szenen ¬∑ ${state.figuren.length} Figuren ¬∑ ${state.cues.length} Cues`;
    }

    function renderMainContent() {
      switch (state.currentView) {
        case 'titelblatt': return renderTitelblatt();
        case 'textbuch': return renderTextbuch();
        case 'szenen': return renderSzenenView();
        case 'figuren': return renderFigurenView();
        case 'cues': return renderCuesView();
        case 'buehne': return renderBuehneView();
        case 'requisiten': return renderRequisitenView();
        case 'kostueme': return renderKostuemeView();
        case 'medien': return renderMedienView();
        case 'fassungen': return renderFassungenView();
        case 'konzept': return renderKonzeptView();
        case 'teamproben': return renderTeamProbenView();
        default: return renderPlaceholder(state.currentView);
      }
    }
    
    // ============================================
    // TITELBLATT VIEW (wie gedrucktes Regiebuch)
    // ============================================
    function renderTitelblatt() {
      const meta = state.projektMeta || {};
      const figuren = state.figuren || [];
      const szenen = state.szenen || [];
      const cues = state.cues || [];
      
      return `
        <div class="flex-1 overflow-y-auto bg-gray-100 p-8">
          <div class="max-w-3xl mx-auto">
            
            <!-- Titelseite -->
            <div class="bg-white rounded-lg shadow-lg p-12 mb-8 text-center">
              ${meta.titelbild ? `
                <img src="${meta.titelbild}" alt="Titelbild" class="w-64 h-auto mx-auto mb-8 rounded-lg shadow">
              ` : `
                <div class="w-64 h-40 mx-auto mb-8 bg-gradient-to-br from-blue-100 to-purple-100 rounded-lg flex items-center justify-center">
                  <span class="text-6xl">üé≠</span>
                </div>
              `}
              
              <h1 class="text-4xl font-bold text-gray-900 mb-2">${meta.titel || 'Unbenannt'}</h1>
              ${meta.untertitel ? `<h2 class="text-xl text-gray-600 mb-4">${meta.untertitel}</h2>` : ''}
              ${meta.autor ? `<p class="text-lg text-gray-500 mb-6">von ${meta.autor}</p>` : ''}
              
              ${meta.tagline ? `<p class="text-lg italic text-gray-600 mb-4">"${meta.tagline}"</p>` : ''}
              ${meta.logline ? `<p class="text-sm text-gray-500 max-w-xl mx-auto mb-8">${meta.logline}</p>` : ''}
              
              <div class="border-t pt-6 mt-6">
                <p class="text-sm text-gray-500">${meta.fassung || 'Arbeitsfassung'}</p>
                ${meta.premiere ? `<p class="text-sm text-gray-400">Premiere: ${new Date(meta.premiere).toLocaleDateString('de-DE')}</p>` : ''}
                ${meta.spielort ? `<p class="text-sm text-gray-400">${meta.spielort}</p>` : ''}
              </div>
              
              ${meta.copyright ? `<p class="text-xs text-gray-400 mt-6">¬© ${meta.copyright}</p>` : ''}
              
              <button class="mt-6 text-sm text-blue-600 hover:text-blue-800" onclick="openProjektModal(state.projektId)">
                ‚úèÔ∏è Bearbeiten
              </button>
            </div>
            
            <!-- Besetzung / Figurenliste -->
            <div class="bg-white rounded-lg shadow-lg p-8 mb-8">
              <h2 class="text-2xl font-bold text-gray-800 mb-6 pb-2 border-b">Besetzung</h2>
              
              ${figuren.length === 0 ? `
                <p class="text-gray-500 italic">Noch keine Figuren angelegt.</p>
                <button class="mt-4 btn btn-outline" onclick="navigateTo('figuren')">+ Figuren hinzuf√ºgen</button>
              ` : `
                <div class="space-y-4">
                  ${figuren.map(f => `
                    <div class="flex items-start gap-4 py-2 border-b border-gray-100 last:border-0">
                      <div class="w-12 h-12 rounded-full bg-blue-100 text-blue-700 flex items-center justify-center font-bold flex-shrink-0">
                        ${f.kuerzel || (f.name || '').substring(0, 2).toUpperCase()}
                      </div>
                      <div class="flex-1">
                        <div class="font-semibold text-gray-800">${f.name || 'Unbenannt'}</div>
                        ${f.beschreibung ? `<div class="text-sm text-gray-500">${f.beschreibung}</div>` : ''}
                      </div>
                      <div class="text-xs text-gray-400">
                        ${state.szenen.filter(s => s.figuren?.includes(f.id)).length} Szenen
                      </div>
                    </div>
                  `).join('')}
                </div>
              `}
            </div>
            
            <!-- Struktur / Szenen√ºbersicht -->
            <div class="bg-white rounded-lg shadow-lg p-8 mb-8">
              <h2 class="text-2xl font-bold text-gray-800 mb-6 pb-2 border-b">Szenen√ºbersicht</h2>
              
              ${szenen.length === 0 ? `
                <p class="text-gray-500 italic">Noch keine Szenen angelegt.</p>
                <button class="mt-4 btn btn-outline" onclick="navigateTo('szenen')">+ Szenen hinzuf√ºgen</button>
              ` : `
                <div class="space-y-2">
                  ${(() => {
                    let html = '';
                    let lastGruppe = null;
                    szenen.forEach((s, idx) => {
                      const gruppe = s.gruppe || 'Ohne Zuordnung';
                      if (gruppe !== lastGruppe) {
                        html += `<h3 class="font-bold text-lg text-gray-700 mt-4 mb-2 pt-2 border-t first:border-0 first:mt-0">${gruppe}</h3>`;
                        lastGruppe = gruppe;
                      }
                      const figurenInSzene = (s.figuren || []).map(fId => {
                        const fig = figuren.find(f => f.id === fId);
                        return fig ? (fig.kuerzel || fig.name?.substring(0,2)) : '';
                      }).filter(Boolean).join(', ');
                      html += `
                        <div class="flex items-center gap-4 py-1 text-sm hover:bg-gray-50 rounded px-2 cursor-pointer" onclick="selectSzene('${s.id}'); navigateTo('textbuch')">
                          <span class="font-mono text-gray-400 w-12">${s.nummer || (idx + 1)}</span>
                          <span class="flex-1">${s.titel || 'Ohne Titel'}</span>
                          <span class="text-gray-400 text-xs">${figurenInSzene || '‚Äì'}</span>
                          <span class="text-gray-400 text-xs">${s.ort || ''}</span>
                        </div>
                      `;
                    });
                    return html;
                  })()}
                </div>
              `}
            </div>
            
            <!-- Technische √úbersicht -->
            <div class="bg-white rounded-lg shadow-lg p-8 mb-8">
              <h2 class="text-2xl font-bold text-gray-800 mb-6 pb-2 border-b">Technische √úbersicht</h2>
              
              <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                  <div class="text-3xl font-bold text-blue-600">${szenen.length}</div>
                  <div class="text-sm text-gray-500">Szenen</div>
                </div>
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                  <div class="text-3xl font-bold text-green-600">${figuren.length}</div>
                  <div class="text-sm text-gray-500">Figuren</div>
                </div>
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                  <div class="text-3xl font-bold text-yellow-600">${cues.length}</div>
                  <div class="text-sm text-gray-500">Cues</div>
                </div>
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                  <div class="text-3xl font-bold text-purple-600">${(state.projektMeta.eigeneGruppen || []).length}</div>
                  <div class="text-sm text-gray-500">Akte/Teile</div>
                </div>
              </div>
              
              <!-- Cue-√úbersicht -->
              ${cues.length > 0 ? `
                <div class="mt-6">
                  <h3 class="font-semibold text-gray-700 mb-3">Cue-Liste</h3>
                  <div class="space-y-1 text-sm max-h-48 overflow-y-auto">
                    ${cues.slice(0, 20).map(c => {
                      const szene = szenen.find(s => s.id === c.szeneId);
                      return `
                        <div class="flex items-center gap-2 py-1 px-2 bg-gray-50 rounded">
                          <span class="cue-badge cue-${c.typ || 'lx'}">${(c.typ || 'LX').toUpperCase()} ${c.nummer || ''}</span>
                          <span class="flex-1 truncate">${c.beschreibung || '‚Äì'}</span>
                          <span class="text-xs text-gray-400">${szene?.nummer || ''}</span>
                        </div>
                      `;
                    }).join('')}
                    ${cues.length > 20 ? `<div class="text-center text-gray-400 text-xs py-2">... und ${cues.length - 20} weitere</div>` : ''}
                  </div>
                </div>
              ` : ''}
            </div>
            
          </div>
        </div>
      `;
    }
    
    // Hilfsfunktion: Szenen-Liste in Array-Reihenfolge (frei verschiebbar)
    function renderGruppierteSzenenListe() {
      // Falls keine Szenen, Hinweis zeigen
      if (state.szenen.length === 0) {
        return '<div class="text-xs text-gray-400 p-2 text-center">Keine Szenen vorhanden</div>';
      }
      
      let html = '';
      let lastGruppe = null;
      
      // Szenen in Array-Reihenfolge durchgehen (NICHT sortiert!)
      state.szenen.forEach((s, idx) => {
        const gruppe = s.gruppe || 'Ohne Zuordnung';
        
        // Gruppen-√úberschrift einf√ºgen wenn sich die Gruppe √§ndert
        if (gruppe !== lastGruppe) {
          html += `<div class="text-xs font-bold text-gray-400 uppercase px-2 py-1 bg-gray-100 rounded mb-1 mt-2">${gruppe}</div>`;
          lastGruppe = gruppe;
        }
        
        html += `
          <div class="szene-item ${s.id === state.aktiveSzene ? 'active' : ''} flex items-center group" 
               onclick="selectSzene('${s.id}')">
            <div class="flex-1 min-w-0">
              <div class="font-medium text-sm">${s.nummer}</div>
              <div class="text-xs text-gray-500 truncate">${s.titel}</div>
            </div>
            <div class="flex flex-col gap-0.5 opacity-0 group-hover:opacity-100 transition-opacity ml-1" onclick="event.stopPropagation()">
              <button class="text-xs text-gray-400 hover:text-blue-600 px-1 ${idx === 0 ? 'invisible' : ''}" onclick="moveSzene('${s.id}', -1)" title="Nach oben">‚ñ≤</button>
              <button class="text-xs text-gray-400 hover:text-blue-600 px-1 ${idx === state.szenen.length - 1 ? 'invisible' : ''}" onclick="moveSzene('${s.id}', 1)" title="Nach unten">‚ñº</button>
            </div>
          </div>
        `;
      });
      
      return html;
    }

    // ============================================
    // TEXTBUCH VIEW (v1.2: mit Streichungs-Button)
    // ============================================
    function renderTextbuch() {
      // Sicherheitspr√ºfung: Wenn keine Szenen vorhanden, automatisch eine erstellen
      if (state.szenen.length === 0) {
        const startSzeneId = genId();
        const startSzene = {
          id: startSzeneId,
          nummer: '1.1',
          titel: 'Start',
          gruppe: '1',
          ort: '',
          zeit: '',
          zusammenfassung: '',
          figuren: []
        };
        state.szenen.push(startSzene);
        state.textbuch[startSzeneId] = '<p class="format-standard"><br></p>';
        state.aktiveSzene = startSzeneId;
        saveProjektDaten();
      }
      
      // Sicherheitspr√ºfung: Wenn keine aktive Szene, erste Szene ausw√§hlen
      if (!state.aktiveSzene && state.szenen.length > 0) {
        state.aktiveSzene = state.szenen[0].id;
      }
      
      const szene = state.szenen.find(s => s.id === state.aktiveSzene);
      let content = state.textbuch[state.aktiveSzene] || '';
      const szeneCues = state.cues.filter(c => c.szeneId === state.aktiveSzene);
      const szeneFiguren = szene?.figuren?.map(fId => state.figuren.find(f => f.id === fId)).filter(Boolean) || [];
      
      // In Technik-Ansicht: Cue-Marker im Text anzeigen
      // In √Ñnderungen-Ansicht: Diff gegen Referenz berechnen
      let displayContent;
      let diffResult = null;
      if (state.textAnsicht === 'technik') {
        displayContent = enrichTextWithCueMarkers(content, szeneCues);
      } else if (state.textAnsicht === 'aenderungen') {
        diffResult = computeDiffHtml(state.aktiveSzene);
        displayContent = content; // Fallback, wird unten √ºberschrieben
      } else {
        displayContent = content;
      }
      
      return `
        <div class="flex-1 flex overflow-hidden">
          <!-- Szenen-Liste links -->
          <div class="w-48 bg-gray-50 border-r border-gray-200 flex flex-col">
            <div class="p-3 border-b border-gray-200 flex items-center justify-between">
              <div class="text-xs font-semibold text-gray-500 uppercase">Szenen</div>
              <button class="btn btn-xs btn-primary" onclick="openSzeneModal()">+</button>
            </div>
            <div class="flex-1 overflow-y-auto p-2">
              ${renderGruppierteSzenenListe()}
            </div>
          </div>
          
          <!-- Editor Mitte -->
          <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Toolbar -->
            <div class="toolbar">
              ${state.textAnsicht !== 'aenderungen' ? `
              <select class="format-select" id="format-select" onchange="state.selectedFormat = this.value; applySelectedFormat();">
                ${Object.entries(FORMATVORLAGEN).map(([key, val]) => `
                  <option value="${key}" ${state.selectedFormat === key ? 'selected' : ''}>
                    ${val.icon} ${val.name}
                  </option>
                `).join('')}
              </select>
              
              <div class="toolbar-divider"></div>
              
              <div class="toolbar-group">
                <button class="toolbar-btn" onclick="execCommand('bold')" title="Fett (Ctrl/Cmd+B)"><b>F</b></button>
                <button class="toolbar-btn" onclick="execCommand('italic')" title="Kursiv (Ctrl/Cmd+I)"><i>K</i></button>
                <button class="toolbar-btn" onclick="execCommand('underline')" title="Unterstrichen (Ctrl/Cmd+U)"><u>U</u></button>
                <button class="toolbar-btn" onclick="toggleSearchReplace()" title="Suchen & Ersetzen (Ctrl/Cmd+F)" style="font-size:13px;">üîç</button>
              </div>
              
              <div class="toolbar-divider"></div>
              
              <div class="toolbar-group">
                <button class="toolbar-btn" id="undo-btn" onclick="undo()" title="R√ºckg√§ngig (Ctrl/Cmd+Z)">‚Ü©</button>
                <button class="toolbar-btn" id="redo-btn" onclick="redo()" title="Wiederholen (Ctrl/Cmd+Shift+Z)">‚Ü™</button>
              </div>
              
              <div class="toolbar-divider"></div>
              ` : `<span style="font-size:12px; color:#6b7280;">Nur-Lese-Ansicht ‚Äì √Ñnderungen werden automatisch erkannt</span><div style="flex:1;"></div>`}
              
              <!-- Ansicht-Auswahl -->
              <select class="format-select" style="width: auto; min-width: 140px;" onchange="setTextAnsicht(this.value)">
                <option value="technik" ${state.textAnsicht === 'technik' ? 'selected' : ''}>‚öôÔ∏è¬è Technik</option>
                <option value="schauspieler" ${state.textAnsicht === 'schauspieler' ? 'selected' : ''}>üìñ Schauspieler</option>
                <option value="aenderungen" ${state.textAnsicht === 'aenderungen' ? 'selected' : ''}>üìù √Ñnderungen</option>
              </select>
              
              ${state.textAnsicht !== 'aenderungen' ? `
              <div class="toolbar-divider"></div>
              
              <button class="toolbar-btn toolbar-icon-only" onclick="splitSzeneAtCursor()" title="Szene hier teilen ‚Äì Text ab Cursor wird neue Szene">‚úÇÔ∏è<span class="toolbar-label">Teilen</span></button>
              <button class="toolbar-btn toolbar-icon-only" onclick="cleanupFormatting()" title="Formatierung bereinigen ‚Äì Word-Styles entfernen">üßπ<span class="toolbar-label">Bereinigen</span></button>
              ` : ''}
            </div>
            
            <!-- Editor -->
            <div class="flex-1 overflow-y-auto p-4 bg-gray-100">
              <div class="editor-container max-w-4xl mx-auto shadow-lg">
                ${state.textAnsicht === 'aenderungen' ? (() => {
                  // Diff-Ansicht (read-only)
                  const refFassung = getReferenzFassung();
                  if (!refFassung) {
                    return `
                      <div class="editor-content" style="padding: 20px;">
                        <div class="diff-no-ref">
                          <p style="font-size:24px; margin-bottom:8px;">üìã</p>
                          <p><strong>Keine Referenz-Fassung vorhanden</strong></p>
                          <p style="margin-top:8px;">Speichere zuerst eine Fassung (Projekt-Menu), um √Ñnderungen automatisch nachzuverfolgen.</p>
                        </div>
                      </div>`;
                  }
                  
                  const refDate = new Date(refFassung.datum).toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
                  
                  let infoHtml = `<div class="diff-info-bar">
                    <span>üìã Vergleich mit:</span>
                    <select onchange="setReferenzFassung(this.value)" style="max-width:200px;">
                      ${state.fassungen.map(f => {
                        const d = new Date(f.datum).toLocaleDateString('de-CH', { day:'2-digit', month:'2-digit', year:'numeric' });
                        return '<option value="' + f.id + '"' + (f.id === refFassung.id ? ' selected' : '') + '>' + f.name + ' (' + d + ')</option>';
                      }).join('')}
                    </select>`;
                  
                  if (diffResult && (diffResult.delCount > 0 || diffResult.insCount > 0)) {
                    infoHtml += `<span class="diff-stats"><span class="del-count">-${diffResult.delCount} gestrichen</span> ¬∑ <span class="ins-count">+${diffResult.insCount} neu</span></span>`;
                  }
                  infoHtml += `</div>`;
                  
                  let bodyHtml = '';
                  if (diffResult && (diffResult.delCount > 0 || diffResult.insCount > 0)) {
                    bodyHtml = diffResult.html;
                  } else {
                    bodyHtml = '<div class="diff-no-changes"><p style="font-size:24px; margin-bottom:8px;">‚úÖ</p><p><strong>Keine √Ñnderungen</strong></p><p style="margin-top:6px;">Der Text dieser Szene ist identisch mit der Referenz-Fassung.</p></div>';
                  }
                  
                  return `<div class="editor-content diff-view" style="padding: 20px;">${infoHtml}${bodyHtml}</div>`;
                })() : `
                <div id="text-editor" 
                     class="editor-content ${getEditorClasses()}"
                     contenteditable="true"
                     spellcheck="true">${displayContent}</div>
                `}
              </div>
            </div>
          </div>
          
          <!-- Details rechts -->
          <div class="details-panel w-64 overflow-y-auto">
            <!-- Szenen-Info -->
            <div class="detail-section">
              <div class="detail-label">Szene bearbeiten</div>
              ${szene ? `
                <div class="space-y-2">
                  <div class="grid grid-cols-3 gap-2">
                    <div>
                      <label class="text-xs text-gray-500">Nr.</label>
                      <input type="text" value="${szene.nummer}" class="text-sm"
                             onchange="updateSzene('${szene.id}', 'nummer', this.value)">
                    </div>
                    <div class="col-span-2">
                      <label class="text-xs text-gray-500">Akt/Teil/Gruppe</label>
                      <input type="text" list="gruppe-options-${szene.id}" value="${szene.gruppe || ''}" class="text-sm"
                             onchange="updateSzene('${szene.id}', 'gruppe', this.value)"
                             placeholder="z.B. Erster Akt, Prolog, Episode 1...">
                      <datalist id="gruppe-options-${szene.id}">
                        ${getAktuelleGruppen().map(g => `<option value="${g}">`).join('')}
                      </datalist>
                    </div>
                  </div>
                  <div>
                    <label class="text-xs text-gray-500">Titel</label>
                    <input type="text" value="${szene.titel}" class="text-sm"
                           onchange="updateSzene('${szene.id}', 'titel', this.value)">
                  </div>
                  <div class="grid grid-cols-2 gap-2">
                    <div>
                      <label class="text-xs text-gray-500">Ort</label>
                      <input type="text" value="${szene.ort || ''}" class="text-sm" placeholder="Wo?"
                             onchange="updateSzene('${szene.id}', 'ort', this.value)">
                    </div>
                    <div>
                      <label class="text-xs text-gray-500">Zeit</label>
                      <input type="text" value="${szene.zeit || ''}" class="text-sm" placeholder="Wann?"
                             onchange="updateSzene('${szene.id}', 'zeit', this.value)">
                    </div>
                  </div>
                  <div>
                    <label class="text-xs text-gray-500">Zusammenfassung</label>
                    <textarea rows="2" class="text-sm" placeholder="Was passiert?"
                              onchange="updateSzene('${szene.id}', 'zusammenfassung', this.value)">${szene.zusammenfassung || ''}</textarea>
                  </div>
                </div>
              ` : '<p class="text-sm text-gray-400">Keine Szene ausgew√§hlt</p>'}
            </div>
            
            <!-- Figuren in Szene (kompakt) -->
            <div class="detail-section">
              <div class="flex items-center justify-between mb-2">
                <div class="detail-label">Figuren</div>
                <select class="text-xs border rounded px-1 py-0.5" style="max-width: 120px;"
                        onchange="if(this.value) { toggleFigurInSzene('${szene?.id}', this.value, true); this.value=''; }">
                  <option value="">+ hinzuf√ºgen...</option>
                  ${state.figuren.filter(f => f && f.name && !szene?.figuren?.includes(f.id)).map(f => `
                    <option value="${f.id}">${f.kuerzel || (f.name || '').substring(0,2)} ‚Äì ${f.name || 'Unbenannt'}</option>
                  `).join('')}
                </select>
              </div>
              <div class="flex flex-wrap gap-1">
                ${szene?.figuren?.length > 0 ? szene.figuren.map(fId => {
                  const f = state.figuren.find(fig => fig.id === fId);
                  if (!f) return '';
                  return `
                    <span class="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-xs">
                      <span class="font-medium">${f.kuerzel || (f.name || '').substring(0,2)}</span>
                      <button class="hover:text-red-600" onclick="toggleFigurInSzene('${szene.id}', '${f.id}', false)" title="Entfernen">√ó</button>
                    </span>
                  `;
                }).join('') : '<span class="text-xs text-gray-400">Keine Figuren</span>'}
              </div>
            </div>
            
            <!-- Cues -->
            <div class="detail-section">
              <div class="flex items-center justify-between mb-2">
                <div class="detail-label">Cues</div>
                <button class="btn btn-xs btn-outline" onclick="openCueModal()">+ Cue</button>
              </div>
              <div class="space-y-1">
                ${szeneCues.length > 0 ? szeneCues.map(c => `
                  <div class="p-1.5 hover:bg-gray-100 rounded cursor-pointer text-xs"
                       onclick="editCue('${c.id}')">
                    <div class="flex items-center gap-1">
                      <span class="cue-badge ${CUE_TYPEN[c.typ]?.class || 'cue-lx'}" style="font-size: 10px; padding: 1px 4px;">
                        ${CUE_TYPEN[c.typ]?.prefix || 'LX'}${c.nummer}
                      </span>
                      <span class="text-gray-600 truncate flex-1">${c.beschreibung || '‚Äì'}</span>
                    </div>
                    ${c.ankerText ? `
                      <div class="text-gray-400 mt-0.5 pl-1 border-l border-purple-200 italic truncate" title="${escapeHtml(c.ankerText)}">
                        üîç "${c.ankerText.length > 30 ? c.ankerText.substring(0, 30) + '...' : c.ankerText}"
                      </div>
                    ` : ''}
                  </div>
                `).join('') : '<p class="text-xs text-gray-400">Keine Cues</p>'}
              </div>
            </div>
            
            <!-- Medien dieser Szene -->
            <div class="detail-section">
              <div class="flex items-center justify-between mb-2">
                <div class="detail-label">üéµ Medien</div>
                <button class="btn btn-xs btn-outline" onclick="navigateTo('medien')">Alle</button>
              </div>
              ${renderSzeneMedien(szene?.id)}
            </div>
            
            <!-- Format-Shortcuts (ganz unten) - nur Anzeige, kein Klick -->
            <div class="detail-section border-t pt-3 mt-3">
              <div class="detail-label text-gray-400">FORMATE (CTRL+SHIFT+...)</div>
              <div id="format-indicator" class="text-xs space-y-0.5 font-mono">
                <div class="format-item px-1.5 py-0.5 rounded" data-format="dialog">
                  <span class="font-bold text-blue-600">D</span> Dialog
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="regieanweisung">
                  <span class="font-bold text-blue-600">R</span> Regieanweisung
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="szeneTitel">
                  <span class="font-bold text-blue-600">T</span> Szenen-Titel
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="aktTitel">
                  <span class="font-bold text-blue-600">A</span> Akt-Titel
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="lied">
                  <span class="font-bold text-blue-600">L</span> Lied
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="vers">
                  <span class="font-bold text-blue-600">V</span> Vers
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="pause">
                  <span class="font-bold text-blue-600">P</span> Pause
                </div>
                <div class="format-item px-1.5 py-0.5 rounded" data-format="standard">
                  <span class="font-bold text-blue-600">N</span> Normal
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // ============================================
    // SZENEN VIEW
    // ============================================
    function renderSzenenView() {
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-5xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold">Alle Szenen (${state.szenen.length})</h2>
              <button class="btn btn-primary" onclick="openSzeneModal()">+ Neue Szene</button>
            </div>
            
            <div class="space-y-6">
              ${renderSzenenNachGruppen()}
            </div>
            
            ${state.szenen.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üé¨</div>
                <p>Noch keine Szenen vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openSzeneModal()">Erste Szene erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    function renderSzenenNachGruppen() {
      const eigeneGruppen = state.projektMeta.eigeneGruppen || ['Erster Akt'];
      
      // Szenen nach Gruppe gruppieren
      const gruppen = {};
      state.szenen.forEach(s => {
        const gruppe = s.gruppe || eigeneGruppen[0] || 'Ohne Gruppe';
        if (!gruppen[gruppe]) gruppen[gruppe] = [];
        gruppen[gruppe].push(s);
      });
      
      // Sortierung: eigeneGruppen-Reihenfolge, dann unbekannte Gruppen
      const sortierteGruppen = Object.keys(gruppen).sort((a, b) => {
        const indexA = eigeneGruppen.indexOf(a);
        const indexB = eigeneGruppen.indexOf(b);
        return (indexA === -1 ? 999 : indexA) - (indexB === -1 ? 999 : indexB);
      });
      
      if (sortierteGruppen.length === 0) return '';
      
      return sortierteGruppen.map(gruppenName => {
        const szenen = gruppen[gruppenName];
        
        return `
          <div class="card overflow-hidden">
            <div class="bg-gray-100 px-4 py-2 border-b">
              <h3 class="font-semibold text-gray-700">${gruppenName}</h3>
            </div>
            <div class="divide-y divide-gray-100">
              ${szenen.map(s => {
                const figurenNamen = s.figuren?.map(fId => {
                  const f = state.figuren.find(fig => fig.id === fId);
                  return f ? `<span class="figur-badge">${f.kuerzel || (f.name || '').substring(0,2)}</span>` : '';
                }).join('') || '<span class="text-gray-400 text-sm">‚Äì</span>';
                const cueCount = state.cues.filter(c => c.szeneId === s.id).length;
                
                return `
                  <div class="p-4 hover:bg-blue-50 cursor-pointer transition-colors" onclick="editSzene('${s.id}')">
                    <div class="flex items-start gap-4">
                      <div class="w-12 h-12 rounded bg-blue-100 text-blue-700 flex items-center justify-center font-bold text-lg flex-shrink-0">
                        ${s.nummer}
                      </div>
                      <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2 flex-wrap">
                          <h4 class="font-semibold">${s.titel}</h4>
                          ${s.ort ? `<span class="text-xs bg-gray-100 px-2 py-0.5 rounded">üîç ${s.ort}</span>` : ''}
                          ${s.zeit ? `<span class="text-xs bg-gray-100 px-2 py-0.5 rounded">üïê ${s.zeit}</span>` : ''}
                          ${cueCount > 0 ? `<span class="text-xs bg-yellow-100 text-yellow-700 px-2 py-0.5 rounded">üí° ${cueCount} Cues</span>` : ''}
                        </div>
                        ${s.zusammenfassung ? `<p class="text-sm text-gray-500 mt-1 line-clamp-2">${s.zusammenfassung}</p>` : ''}
                        <div class="flex items-center gap-2 mt-2">
                          <span class="text-xs text-gray-400">Figuren:</span>
                          ${figurenNamen}
                        </div>
                      </div>
                      <div class="flex gap-1 flex-shrink-0">
                        <button class="btn btn-xs btn-outline" onclick="event.stopPropagation(); selectSzene('${s.id}'); navigateTo('textbuch');" title="Text bearbeiten">
                          üìù
                        </button>
                        <button class="btn btn-xs btn-danger" onclick="event.stopPropagation(); deleteSzene('${s.id}')" title="L√∂schen">
                          üóëÔ∏è¬è
                        </button>
                      </div>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }).join('');
    }

    // ============================================
    // FIGUREN VIEW
    // ============================================
    function renderFigurenView() {
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-5xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold">Figuren (${state.figuren.length})</h2>
              <button class="btn btn-primary" onclick="openFigurModal()">+ Neue Figur</button>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              ${state.figuren.map(f => {
                const szenenCount = state.szenen.filter(s => s.figuren?.includes(f.id)).length;
                // Besetzung aus Ensemble
                const besetzung = (state.ensemble || []).filter(e => (e.rolleIds || []).includes(f.id));
                // Beziehungen
                const bez = (state.beziehungen || []).filter(b => b.figur1Id === f.id || b.figur2Id === f.id);
                return `
                  <div class="card p-4 hover:shadow-md transition-shadow">
                    <div class="flex items-start gap-4 cursor-pointer" onclick="editFigur('${f.id}')">
                      <div class="w-14 h-14 rounded-full bg-blue-100 text-blue-700 flex items-center justify-center font-bold text-xl flex-shrink-0">
                        ${f.kuerzel || (f.name || '').substring(0, 2)}
                      </div>
                      <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2">
                          <h3 class="font-semibold text-lg">${f.name || 'Unbenannt'}</h3>
                          <span class="text-xs bg-gray-100 px-2 py-0.5 rounded">${szenenCount} Szenen</span>
                        </div>
                        <p class="text-sm text-gray-500 mt-1">${f.beschreibung || 'Keine Beschreibung'}</p>
                        ${f.want ? `<p class="text-xs text-gray-400 mt-2"><strong>Will:</strong> ${f.want}</p>` : ''}
                        ${f.need ? `<p class="text-xs text-gray-400"><strong>Braucht:</strong> ${f.need}</p>` : ''}
                      </div>
                    </div>
                    ${besetzung.length > 0 || bez.length > 0 ? `
                      <div class="mt-3 pt-3 border-t border-gray-100 space-y-2">
                        ${besetzung.length > 0 ? `
                          <div class="flex items-center gap-2 text-xs text-teal-600">
                            <span>üé≠</span>
                            <span>${besetzung.map(e => e.name).join(', ')}</span>
                          </div>
                        ` : ''}
                        ${bez.length > 0 ? `
                          <div class="text-xs text-gray-500 space-y-0.5">
                            ${bez.slice(0, 3).map(b => {
                              const otherId = b.figur1Id === f.id ? b.figur2Id : b.figur1Id;
                              const other = state.figuren.find(x => x.id === otherId);
                              return `<div>üîó <strong>${other?.name || '?'}</strong>: ${b.art || b.beschreibung || '‚Äî'}</div>`;
                            }).join('')}
                            ${bez.length > 3 ? `<div class="text-gray-400">+ ${bez.length - 3} weitere</div>` : ''}
                          </div>
                        ` : ''}
                      </div>
                    ` : ''}
                  </div>
                `;
              }).join('')}
            </div>
            
            ${state.figuren.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üë§</div>
                <p>Noch keine Figuren vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openFigurModal()">Erste Figur erstellen</button>
              </div>
            ` : ''}
            
            ${state.figuren.length >= 2 ? `
              <!-- Beziehungen-Sektion -->
              <div class="mt-8">
                <div class="flex justify-between items-center mb-4">
                  <h3 class="text-lg font-semibold">üîó Beziehungen</h3>
                  <button class="btn btn-sm bg-blue-50 text-blue-700 hover:bg-blue-100 border border-blue-200" onclick="addBeziehung()">+ Beziehung</button>
                </div>
                ${(state.beziehungen || []).length === 0 ? `
                  <div class="card p-6 text-center text-gray-400">
                    <p class="text-sm">Noch keine Beziehungen definiert</p>
                    <p class="text-xs mt-1">Beschreibe die Verbindungen zwischen deinen Figuren</p>
                  </div>
                ` : `
                  <div class="space-y-2">
                    ${(state.beziehungen || []).map(b => {
                      const f1 = state.figuren.find(f => f.id === b.figur1Id);
                      const f2 = state.figuren.find(f => f.id === b.figur2Id);
                      return `
                        <div class="card p-3 flex items-center gap-3">
                          <div class="flex items-center gap-2 min-w-0">
                            <select onchange="setBeziehungFigur('${b.id}', 'figur1Id', this.value)"
                              class="text-sm p-1 rounded border border-gray-200 bg-gray-50 font-medium">
                              ${state.figuren.map(fig => `<option value="${fig.id}" ${fig.id === b.figur1Id ? 'selected' : ''}>${fig.name}</option>`).join('')}
                            </select>
                            <span class="text-gray-400">‚Üî</span>
                            <select onchange="setBeziehungFigur('${b.id}', 'figur2Id', this.value)"
                              class="text-sm p-1 rounded border border-gray-200 bg-gray-50 font-medium">
                              ${state.figuren.map(fig => `<option value="${fig.id}" ${fig.id === b.figur2Id ? 'selected' : ''}>${fig.name}</option>`).join('')}
                            </select>
                          </div>
                          <input type="text" value="${(b.art || '').replace(/"/g, '&quot;')}"
                            onchange="updateBeziehung('${b.id}', 'art', this.value)"
                            class="flex-1 text-sm p-1 rounded border border-gray-200 bg-gray-50" placeholder="Art der Beziehung...">
                          <input type="text" value="${(b.beschreibung || '').replace(/"/g, '&quot;')}"
                            onchange="updateBeziehung('${b.id}', 'beschreibung', this.value)"
                            class="flex-1 text-sm p-1 rounded border border-gray-200 bg-gray-50" placeholder="Details...">
                          <button onclick="deleteBeziehung('${b.id}')" class="text-gray-400 hover:text-red-500 text-sm flex-shrink-0">‚úï</button>
                        </div>
                      `;
                    }).join('')}
                  </div>
                `}
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }

    // ============================================
    // CUES VIEW
    // ============================================
    function renderCuesView() {
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-5xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold">Cue-Listen (${state.cues.length} Cues)</h2>
              <div class="flex gap-2">
                <button class="btn btn-outline" onclick="openCueExportDialog()">üìÑ Export</button>
                <button class="btn btn-primary" onclick="openCueModal()">+ Neuer Cue</button>
              </div>
            </div>
            
            <div class="grid grid-cols-2 gap-6">
              ${Object.entries(CUE_TYPEN).map(([key, typ]) => {
                const cues = state.cues.filter(c => c.typ === key).sort((a, b) => a.nummer - b.nummer);
                return `
                  <div class="card ${key === 'u' ? 'col-span-2' : ''}">
                    <div class="p-4 border-b border-gray-200 flex items-center gap-2">
                      <span class="text-2xl">${typ.icon}</span>
                      <h3 class="font-semibold">${typ.name}-Cues</h3>
                      <span class="ml-auto bg-gray-100 px-2 py-1 rounded text-sm font-medium">${cues.length}</span>
                    </div>
                    <div class="p-4">
                      ${cues.length > 0 ? `
                        <div class="space-y-2">
                          ${cues.map(c => {
                            const szene = state.szenen.find(s => s.id === c.szeneId);
                            // Verkn√ºpfte Elemente
                            const requisit = c.requisitenId ? state.requisiten.find(r => r.id === c.requisitenId) : null;
                            const medium = c.mediumId ? state.medien.find(m => m.id === c.mediumId) : null;
                            
                            // F√ºr Umbau
                            const umbauVon = c.umbauVon ? state.buehne.find(b => b.id === c.umbauVon) : null;
                            const umbauNach = c.umbauNach ? state.buehne.find(b => b.id === c.umbauNach) : null;
                            
                            // Info-Text je nach Typ
                            let infoText = '';
                            if (requisit) {
                              infoText = `<span class="text-xs text-purple-600">üîó ${requisit.name}</span>`;
                            } else if (medium) {
                              infoText = `<span class="text-xs text-green-600">üîó ${medium.name}</span>`;
                            } else if (c.mediumGeplant) {
                              infoText = `<span class="text-xs text-orange-500">‚è≥ ${c.mediumGeplant} (geplant)</span>`;
                            } else if (key === 'u' && (umbauVon || umbauNach)) {
                              infoText = `<span class="text-xs text-orange-600">üé™ ${umbauVon?.name || '?'} ‚Üí ${umbauNach?.name || '?'}</span>`;
                              if (c.umbauAktionen?.length > 0) {
                                infoText += `<span class="text-xs text-gray-500 ml-2">(${c.umbauAktionen.length} Aktionen)</span>`;
                              }
                            }
                            
                            // Ankertext als Stichwort
                            const stichwort = c.ankerText 
                              ? `<div class="text-xs text-purple-600 italic mt-1 truncate" title="${escapeHtml(c.ankerText)}">üîç ‚Äû${c.ankerText.length > 50 ? c.ankerText.substring(0, 50) + '...' : c.ankerText}"</div>`
                              : '';
                            
                            return `
                              <div class="p-2 bg-gray-50 rounded hover:bg-gray-100 cursor-pointer"
                                   onclick="editCue('${c.id}')">
                                <div class="flex items-center gap-2">
                                  <span class="cue-badge ${typ.class}">${typ.prefix}${c.nummer}</span>
                                  <div class="flex-1 min-w-0">
                                    <span class="text-sm truncate block">${c.beschreibung || '‚Äì'}</span>
                                    ${infoText}
                                  </div>
                                  <span class="text-xs text-gray-400 whitespace-nowrap">${szene?.nummer || '‚Äì'}</span>
                                </div>
                                ${stichwort}
                              </div>
                            `;
                          }).join('')}
                        </div>
                      ` : `
                        <p class="text-sm text-gray-400 text-center py-4">Keine ${typ.name}-Cues</p>
                      `}
                      <button class="btn btn-sm btn-outline w-full mt-3" onclick="openCueModal('${key}')">
                        + ${typ.prefix}-Cue hinzuf√ºgen
                      </button>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        </div>
      `;
    }

    // ============================================
    // KOST√úME VIEW (v1.2: implementiert)
    // ============================================
    function renderKostuemeView() {
      // Bilder asynchron laden
      setTimeout(loadKostuemBilder, 100);
      
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-6xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <div>
                <h2 class="text-lg font-semibold">üëó Kost√ºme & Masken (${state.kostueme.length})</h2>
              </div>
              <div class="flex gap-2">
                <button class="btn btn-outline" onclick="exportKostuemeList()">üìÑ Export</button>
                <button class="btn btn-primary" onclick="openKostuemModal()">+ Neues Kost√ºm</button>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              ${state.kostueme.map(k => {
                const figur = state.figuren.find(f => f.id === k.figur);
                const szenenCount = k.szenen?.length || 0;
                // Bilder-Arrays (mit Fallback f√ºr alte Daten)
                const kostuemBilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
                const maskeBilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
                const hasImages = kostuemBilder.length > 0 || maskeBilder.length > 0;
                
                return `
                  <div class="kostuem-card cursor-pointer" onclick="editKostuem('${k.id}')">
                    <!-- Bilder -->
                    ${hasImages ? `
                      <div class="p-3 bg-gray-50 border-b">
                        ${kostuemBilder.length > 0 ? `
                          <div class="mb-2">
                            <span class="text-xs text-gray-500 mb-1 block">üëó Kost√ºm (${kostuemBilder.length})</span>
                            <div class="image-grid">
                              ${kostuemBilder.slice(0, 3).map((imgId, i) => `
                                <img src="${imageUrlCache[imgId] || ''}" 
                                     class="image-thumb" 
                                     id="img-kostuem-${k.id}-${i}"
                                     onclick="event.stopPropagation(); openKostuemGallery('${k.id}', 'kostuem', ${i})">
                              `).join('')}
                              ${kostuemBilder.length > 3 ? `<div class="add-image-btn" style="cursor:pointer;" onclick="event.stopPropagation(); openKostuemGallery('${k.id}', 'kostuem', 0)">+${kostuemBilder.length - 3}</div>` : ''}
                            </div>
                          </div>
                        ` : ''}
                        ${maskeBilder.length > 0 ? `
                          <div>
                            <span class="text-xs text-gray-500 mb-1 block">üé≠ Maske (${maskeBilder.length})</span>
                            <div class="image-grid">
                              ${maskeBilder.slice(0, 3).map((imgId, i) => `
                                <img src="${imageUrlCache[imgId] || ''}" 
                                     class="image-thumb" 
                                     id="img-maske-${k.id}-${i}"
                                     onclick="event.stopPropagation(); openKostuemGallery('${k.id}', 'maske', ${i})">
                              `).join('')}
                              ${maskeBilder.length > 3 ? `<div class="add-image-btn" style="cursor:pointer;" onclick="event.stopPropagation(); openKostuemGallery('${k.id}', 'maske', 0)">+${maskeBilder.length - 3}</div>` : ''}
                            </div>
                          </div>
                        ` : ''}
                      </div>
                    ` : ''}
                    
                    <div class="p-4 bg-purple-50 border-b border-purple-100">
                      <div class="flex items-center gap-2">
                        <span class="text-2xl">üëó</span>
                        <div class="flex-1">
                          <h3 class="font-semibold">${k.name}</h3>
                          <p class="text-xs text-purple-600">${figur?.name || 'Keine Figur'}</p>
                        </div>
                      </div>
                    </div>
                    <div class="p-4">
                      ${k.beschreibung ? `<p class="text-sm text-gray-600 mb-2">üëó ${k.beschreibung}</p>` : ''}
                      ${k.maske ? `<p class="text-sm text-gray-600 mb-2">üé≠ ${k.maske}</p>` : ''}
                      <div class="flex items-center gap-2 text-xs text-gray-400">
                        <span>üé¨ ${szenenCount} Szenen</span>
                      </div>
                      ${k.notizen ? `<p class="text-xs text-orange-500 mt-2">üìå ${k.notizen}</p>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
            
            ${state.kostueme.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üëó</div>
                <p>Noch keine Kost√ºme vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openKostuemModal()">Erstes Kost√ºm erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    // Kost√ºm-Bilder asynchron nachladen
    async function loadKostuemBilder() {
      for (const k of state.kostueme) {
        // Neue Array-Struktur
        const kostuemBilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
        const maskeBilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
        
        for (let i = 0; i < kostuemBilder.length; i++) {
          const imgId = kostuemBilder[i];
          if (!imageUrlCache[imgId]) {
            const url = await getImageUrl(imgId);
            if (url) {
              const img = document.getElementById(`img-kostuem-${k.id}-${i}`);
              if (img) img.src = url;
            }
          }
        }
        
        for (let i = 0; i < maskeBilder.length; i++) {
          const imgId = maskeBilder[i];
          if (!imageUrlCache[imgId]) {
            const url = await getImageUrl(imgId);
            if (url) {
              const img = document.getElementById(`img-maske-${k.id}-${i}`);
              if (img) img.src = url;
            }
          }
        }
      }
    }
    
    function openKostuemGallery(kostuemId, type, startIndex = 0) {
      const k = state.kostueme.find(x => x.id === kostuemId);
      if (!k) return;
      
      // Bilder je nach Typ
      let bilder;
      if (type === 'kostuem') {
        bilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
      } else {
        bilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
      }
      
      const urls = bilder.map(id => imageUrlCache[id]).filter(Boolean);
      
      if (urls.length > 0) {
        openLightbox(urls, startIndex);
      }
    }
    
    async function exportKostuemeList() {
      // Bilder als Base64 laden
      const bilderBase64 = {};
      for (const k of state.kostueme) {
        if (k.kostuemBilder) {
          for (const imgId of k.kostuemBilder) {
            if (!bilderBase64[imgId]) bilderBase64[imgId] = await getImageAsBase64(imgId);
          }
        }
        if (k.maskeBilder) {
          for (const imgId of k.maskeBilder) {
            if (!bilderBase64[imgId]) bilderBase64[imgId] = await getImageAsBase64(imgId);
          }
        }
        // Fallback f√ºr alte Daten mit einzelnem Bild
        if (k.kostuemBildId && !bilderBase64[k.kostuemBildId]) {
          bilderBase64[k.kostuemBildId] = await getImageAsBase64(k.kostuemBildId);
        }
        if (k.maskeBildId && !bilderBase64[k.maskeBildId]) {
          bilderBase64[k.maskeBildId] = await getImageAsBase64(k.maskeBildId);
        }
      }
      
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Kost√ºme - ${state.projektMeta.titel}</title>
        <style>
          body{font-family:Arial,sans-serif;padding:20px;} 
          .item{margin-bottom:30px;border:1px solid #ddd;padding:15px;page-break-inside:avoid;} 
          .images{display:flex;flex-wrap:wrap;gap:15px;margin:10px 0;}
          .image-box{text-align:center;}
          img{max-width:150px;max-height:150px;}
          h2{margin-bottom:10px;}
          @media print { .no-print{display:none;} }
        </style></head><body>`;
      html += `<div class="no-print" style="margin-bottom:20px;"><button onclick="window.print()" style="padding:10px 20px;font-size:16px;">üñ®Ô∏è¬è Als PDF drucken</button></div>`;
      html += `<h1>Kost√ºme & Masken: ${state.projektMeta.titel}</h1>`;
      html += `<p>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      
      state.kostueme.forEach(k => {
        const figur = state.figuren.find(f => f.id === k.figur);
        const szenenNamen = k.szenen?.map(sId => state.szenen.find(s => s.id === sId)?.nummer).filter(Boolean).join(', ') || '‚Äì';
        
        html += `<div class="item">`;
        html += `<h2>üëó ${k.name}</h2>`;
        html += `<p><strong>Figur:</strong> ${figur?.name || '‚Äì'}</p>`;
        html += `<p><strong>Szenen:</strong> ${szenenNamen}</p>`;
        
        // Kost√ºm-Bilder
        const kostuemBilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
        const maskeBilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
        
        if (kostuemBilder.length > 0 || maskeBilder.length > 0) {
          html += `<div class="images">`;
          kostuemBilder.forEach(imgId => {
            if (bilderBase64[imgId]) html += `<div class="image-box"><img src="${bilderBase64[imgId]}"><br><small>Kost√ºm</small></div>`;
          });
          maskeBilder.forEach(imgId => {
            if (bilderBase64[imgId]) html += `<div class="image-box"><img src="${bilderBase64[imgId]}"><br><small>Maske</small></div>`;
          });
          html += `</div>`;
        }
        
        if (k.beschreibung) html += `<p><strong>Kost√ºm:</strong> ${k.beschreibung}</p>`;
        if (k.maske) html += `<p><strong>Maske:</strong> ${k.maske}</p>`;
        if (k.notizen) html += `<p><em>Notizen: ${k.notizen}</em></p>`;
        html += `</div>`;
      });
      
      html += `</body></html>`;
      openExportWindow(html, 'kostueme-liste');
    }

    // ============================================
    // LIGHTBOX (Bildvergr√∂√üerung)
    // ============================================
    function openLightbox(images, startIndex = 0) {
      state.lightboxImages = images;
      state.lightboxIndex = startIndex;
      state.showLightbox = true;
      render();
    }
    
    function closeLightbox() {
      state.showLightbox = false;
      render();
    }
    
    function lightboxPrev() {
      state.lightboxIndex = (state.lightboxIndex - 1 + state.lightboxImages.length) % state.lightboxImages.length;
      render();
    }
    
    function lightboxNext() {
      state.lightboxIndex = (state.lightboxIndex + 1) % state.lightboxImages.length;
      render();
    }
    
    function renderLightbox() {
      const images = state.lightboxImages;
      const idx = state.lightboxIndex;
      if (!images || images.length === 0) return '';
      
      const currentImg = images[idx];
      const showNav = images.length > 1;
      
      return `
        <div class="lightbox-overlay" onclick="closeLightbox()">
          <span class="lightbox-close" onclick="closeLightbox()">‚úï</span>
          ${showNav ? `<span class="lightbox-nav prev" onclick="event.stopPropagation(); lightboxPrev()">‚ùÆ</span>` : ''}
          <img src="${currentImg}" class="lightbox-content" onclick="event.stopPropagation()">
          ${showNav ? `<span class="lightbox-nav next" onclick="event.stopPropagation(); lightboxNext()">‚ùØ</span>` : ''}
          ${showNav ? `<div class="lightbox-counter">${idx + 1} / ${images.length}</div>` : ''}
        </div>
      `;
    }

    // ============================================
    // B√úHNE VIEW (v1.3)
    // ============================================
    function renderBuehneView() {
      setTimeout(loadBuehneImages, 100);
      
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-6xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <div>
                <h2 class="text-lg font-semibold">üé™ B√ºhne</h2>
                <p class="text-sm text-gray-500">B√ºhnenpl√§ne, Skizzen und Referenzbilder</p>
              </div>
              <div class="flex gap-2">
                <button class="btn btn-outline" onclick="exportBuehneList()">üìÑ Export</button>
                <button class="btn btn-primary" onclick="openBuehneModal()">+ Neues Element</button>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              ${state.buehne.map(b => {
                return `
                  <div class="card cursor-pointer hover:shadow-md" onclick="editBuehne('${b.id}')">
                    <!-- Bilder -->
                    ${b.bilder?.length > 0 ? `
                      <div class="p-2 bg-gray-50 border-b">
                        <div class="image-grid">
                          ${b.bilder.slice(0, 4).map((imgId, i) => `
                            <img src="${imageUrlCache[imgId] || ''}" 
                                 class="image-thumb" 
                                 id="buehne-img-${b.id}-${i}"
                                 onclick="event.stopPropagation(); openBuehneGallery('${b.id}')"
                                 alt="">
                          `).join('')}
                          ${b.bilder.length > 4 ? `<div class="add-image-btn">+${b.bilder.length - 4}</div>` : ''}
                        </div>
                      </div>
                    ` : ''}
                    <div class="p-4">
                      <h3 class="font-semibold mb-1">${b.name}</h3>
                      <p class="text-xs text-purple-600 mb-2">${b.kategorie || 'Allgemein'}</p>
                      ${b.beschreibung ? `<p class="text-sm text-gray-600 mb-2">${b.beschreibung}</p>` : ''}
                      ${b.notizen ? `<p class="text-xs text-orange-500">üìå ${b.notizen}</p>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
            
            ${state.buehne.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üé™</div>
                <p>Noch keine B√ºhnenelemente vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openBuehneModal()">Erstes Element erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    async function loadBuehneImages() {
      for (const b of state.buehne) {
        if (b.bilder) {
          for (let i = 0; i < b.bilder.length; i++) {
            const imgId = b.bilder[i];
            if (!imageUrlCache[imgId]) {
              const url = await getImageUrl(imgId);
              if (url) {
                const img = document.getElementById(`buehne-img-${b.id}-${i}`);
                if (img) img.src = url;
              }
            }
          }
        }
      }
    }
    
    function openBuehneGallery(buehneId) {
      const b = state.buehne.find(x => x.id === buehneId);
      if (b?.bilder?.length > 0) {
        const urls = b.bilder.map(id => imageUrlCache[id]).filter(Boolean);
        if (urls.length > 0) openLightbox(urls, 0);
      }
    }

    // ============================================
    // REQUISITEN VIEW (v1.3)
    // ============================================
    function renderRequisitenView() {
      setTimeout(loadRequisitenImages, 100);
      
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-6xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <div>
                <h2 class="text-lg font-semibold">üé≠ Requisiten</h2>
                <p class="text-sm text-gray-500">Requisiten-Verwaltung mit Zust√§ndigkeiten</p>
              </div>
              <div class="flex gap-2">
                <button class="btn btn-outline" onclick="exportRequisitenList()">üìÑ Export</button>
                <button class="btn btn-primary" onclick="openRequisitenModal()">+ Neue Requisite</button>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              ${state.requisiten.map(r => {
                const szenenNamen = r.szenen?.map(sId => {
                  const s = state.szenen.find(sz => sz.id === sId);
                  return s?.nummer || '';
                }).filter(Boolean).join(', ') || '‚Äì';
                
                return `
                  <div class="card cursor-pointer hover:shadow-md" onclick="editRequisit('${r.id}')">
                    <!-- Bilder -->
                    ${r.bilder?.length > 0 ? `
                      <div class="p-2 bg-gray-50 border-b">
                        <div class="image-grid">
                          ${r.bilder.slice(0, 4).map((imgId, i) => `
                            <img src="${imageUrlCache[imgId] || ''}" 
                                 class="image-thumb" 
                                 id="requisit-img-${r.id}-${i}"
                                 onclick="event.stopPropagation(); openRequisitenGallery('${r.id}')"
                                 alt="">
                          `).join('')}
                          ${r.bilder.length > 4 ? `<div class="add-image-btn">+${r.bilder.length - 4}</div>` : ''}
                        </div>
                      </div>
                    ` : ''}
                    <div class="p-4">
                      <h3 class="font-semibold mb-1">üé≠ ${r.name}</h3>
                      ${r.beschreibung ? `<p class="text-sm text-gray-600 mb-2">${r.beschreibung}</p>` : ''}
                      <div class="flex flex-wrap gap-2 text-xs mb-2">
                        ${r.zustaendig ? `<span class="bg-blue-100 text-blue-700 px-2 py-1 rounded">üë§ ${r.zustaendig}</span>` : ''}
                        <span class="bg-gray-100 text-gray-600 px-2 py-1 rounded">üé¨ ${szenenNamen}</span>
                      </div>
                      ${r.notizen ? `<p class="text-xs text-orange-500">üìå ${r.notizen}</p>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
            
            ${state.requisiten.length === 0 ? `
              <div class="card p-8 text-center text-gray-400">
                <div class="text-4xl mb-2">üé≠</div>
                <p>Noch keine Requisiten vorhanden.</p>
                <button class="btn btn-primary mt-4" onclick="openRequisitenModal()">Erste Requisite erstellen</button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
    
    async function loadRequisitenImages() {
      for (const r of state.requisiten) {
        if (r.bilder) {
          for (let i = 0; i < r.bilder.length; i++) {
            const imgId = r.bilder[i];
            if (!imageUrlCache[imgId]) {
              const url = await getImageUrl(imgId);
              if (url) {
                const img = document.getElementById(`requisit-img-${r.id}-${i}`);
                if (img) img.src = url;
              }
            }
          }
        }
      }
    }
    
    function openRequisitenGallery(reqId) {
      const r = state.requisiten.find(x => x.id === reqId);
      if (r?.bilder?.length > 0) {
        const urls = r.bilder.map(id => imageUrlCache[id]).filter(Boolean);
        if (urls.length > 0) openLightbox(urls, 0);
      }
    }

    // ============================================
    // FASSUNGEN VIEW (v1.2: mit Uhrzeit)
    // ============================================
    function renderFassungenView() {
      return `
        <div class="flex-1 p-6 overflow-y-auto">
          <div class="max-w-3xl mx-auto">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-lg font-semibold">Fassungs-Archiv</h2>
              <button class="btn btn-success" onclick="openModal('showFassungModal')">
                üíæ Aktuelle Fassung speichern
              </button>
            </div>
            
            <!-- Warnhinweis -->
            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
              <div style="display: flex; align-items: flex-start; gap: 10px;">
                <span style="font-size: 20px;">‚ö†Ô∏è¬è</span>
                <div>
                  <p style="font-size: 13px; font-weight: 600; color: #92400e; margin: 0 0 4px 0;">Nur lokal im Browser gespeichert!</p>
                  <p style="font-size: 12px; color: #a16207; margin: 0;">
                    Alle Fassungen werden nur im Browser-Cache gespeichert. Bei Cache-L√∂schung, Browser-Wechsel oder anderem Computer sind sie <strong>nicht verf√ºgbar</strong>.<br>
                    ‚Üí F√ºr sichere Sicherung: <strong>Export ‚Üí Projekt-Backup (.json)</strong>
                  </p>
                </div>
              </div>
            </div>
            
            <div class="card overflow-hidden">
              <!-- Aktuelle Fassung -->
              <div class="p-4 bg-green-50 border-b-2 border-green-200">
                <div class="flex items-center gap-3">
                  <span class="px-2 py-1 bg-green-500 text-white text-xs font-semibold rounded">AKTIV</span>
                  <span class="font-semibold">${state.projektMeta.fassung}</span>
                  <span class="text-sm text-gray-500 ml-auto">${formatDateTime(state.projektMeta.fassungsDatum)}</span>
                </div>
              </div>
              
              <!-- Archivierte Fassungen -->
              ${state.fassungen.length > 0 ? `
                <div class="divide-y divide-gray-200">
                  ${state.fassungen.slice().reverse().map(f => `
                    <div class="p-4 flex items-center hover:bg-gray-50">
                      <div class="flex-1">
                        <div class="font-medium">${f.name}</div>
                        <div class="text-sm text-gray-500">${formatDateTime(f.datum)}</div>
                      </div>
                      <button class="btn btn-sm btn-outline" onclick="fassungLaden('${f.id}')">
                        üìÇ Laden
                      </button>
                    </div>
                  `).join('')}
                </div>
              ` : `
                <div class="p-8 text-center text-gray-400">
                  <div class="text-4xl mb-2">üìö</div>
                  <p>Noch keine archivierten Fassungen.</p>
                  <p class="text-sm mt-2">Speichere nach jeder Probe eine neue Fassung,<br>um √Ñnderungen nachverfolgen zu k√∂nnen.</p>
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }


    // ============================================
    // SZENE-MEDIEN (f√ºr Textbuch-Sidebar)
    // ============================================
    function renderSzeneMedien(szeneId) {
      if (!szeneId) {
        return '<p class="text-sm text-gray-400">Keine Szene ausgew√§hlt</p>';
      }
      
      const szeneMedien = state.medien.filter(m => m.szenen?.includes(szeneId));
      
      if (szeneMedien.length === 0) {
        return `
          <p class="text-sm text-gray-400 mb-2">Keine Medien zugeordnet</p>
          <button class="btn btn-xs btn-outline w-full" onclick="navigateTo('medien')">
            + Medium hinzuf√ºgen
          </button>
        `;
      }
      
      return `
        <div class="space-y-2">
          ${szeneMedien.map(m => {
            const isPlaying = state.currentlyPlaying === m.id;
            const icon = m.type === 'audio' ? 'üéµ' : 'üé¨';
            const hasFile = m.source === 'cloud' ? !!m.url : !!m.localFileUrl;
            const isYouTube = isYouTubeUrl(m.url);
            
            return `
              <div class="flex items-center gap-2 p-2 bg-gray-50 rounded hover:bg-gray-100">
                <span>${icon}</span>
                <span class="flex-1 text-sm truncate" title="${m.name}">${m.name}</span>
                ${hasFile || isYouTube ? `
                  <button class="btn btn-xs ${isPlaying ? 'btn-primary' : 'btn-outline'}" 
                          data-play-btn="${m.id}"
                          onclick="togglePlayMedium('${m.id}')">
                    ${isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
                  </button>
                ` : m.source === 'local' ? `
                  <button class="btn btn-xs btn-outline" onclick="reloadLocalFile('${m.id}')" title="Datei laden">
                    üìÇ
                  </button>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
        
        <!-- Mini-Player: wird jetzt als Bottom-Bar im Editor angezeigt -->
        ${state.currentlyPlaying && szeneMedien.find(m => m.id === state.currentlyPlaying) ? `
          <div class="mt-2 p-2 bg-blue-50 rounded text-center">
            <span class="text-xs text-blue-600">‚ñ∂ Spielt im Player unten</span>
          </div>
        ` : ''}
      `;
    }

    // ============================================
    // MEDIEN VIEW (v1.3 - Vereinfacht mit Drag&Drop)
    // ============================================
    function renderMedienView() {
      const tab = state.medienTab || 'audio';
      return `
        <div class="flex-1 flex flex-col overflow-hidden">
          <!-- Header -->
          <div class="px-6 py-4 border-b border-gray-200 bg-white">
            <div class="flex items-center justify-between mb-3">
              <div>
                <h2 class="text-lg font-semibold text-gray-900">üé¨ Medien</h2>
              </div>
              <div id="storage-info" class="text-xs text-gray-400 text-right"></div>
            </div>
            <!-- Tabs -->
            <div class="flex gap-1 border-b border-gray-200 -mb-4">
              <button onclick="state.medienTab='audio'; render();" 
                class="px-4 py-2 text-sm font-medium border-b-2 transition-colors ${tab === 'audio' ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700'}">
                üéµ Audio / Video
              </button>
              <button onclick="state.medienTab='material'; render();" 
                class="px-4 py-2 text-sm font-medium border-b-2 transition-colors ${tab === 'material' ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700'}">
                üìé Material
              </button>
              <button onclick="state.medienTab='musik'; render();" 
                class="px-4 py-2 text-sm font-medium border-b-2 transition-colors ${tab === 'musik' ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700'}">
                ‚ô´ Musikkonzept
              </button>
            </div>
          </div>
          
          <!-- Tab Content -->
          <div class="flex-1 overflow-y-auto p-6">
            ${tab === 'audio' ? renderMedienAudioTab() : ''}
            ${tab === 'material' ? renderMedienMaterialTab() : ''}
            ${tab === 'musik' ? renderMedienMusikTab() : ''}
          </div>
        </div>
      `;
    }
    
    function renderMedienAudioTab() {
      return `
            <!-- Upload Zone -->
            <div id="dropzone" 
                 class="border-2 border-dashed border-gray-300 rounded-lg p-8 mb-6 text-center 
                        hover:border-blue-400 hover:bg-blue-50 transition-colors cursor-pointer"
                 onclick="openFilePicker()"
                 ondragover="handleDragOver(event)"
                 ondragleave="handleDragLeave(event)"
                 ondrop="handleFileDrop(event)">
              <div class="text-4xl mb-3">üìÅ</div>
              <p class="text-gray-600 mb-2">Datei hierher ziehen oder klicken</p>
              <p class="text-sm text-gray-400 mb-2">
                üéµ <strong>Audio:</strong> wird permanent gespeichert<br>
                üé¨ <strong>Video:</strong> muss nach Neustart neu gew√§hlt werden
              </p>
            </div>
            
            <!-- Medien Liste -->
            ${state.medien.length === 0 ? `
              <div class="text-center text-gray-400 py-8">
                <p class="text-sm">Noch keine Medien ‚Äì lade eine Datei hoch</p>
              </div>
            ` : `
              <div class="space-y-4">
                ${state.medien.map(m => renderMediumCard(m)).join('')}
              </div>
            `}
      `;
    }
    
    function renderMedienMaterialTab() {
      const items = state.rechercheMaterial || [];
      return `
        <div class="mb-4 flex gap-2 flex-wrap">
          <button onclick="addRechercheMaterial('text')" class="btn btn-sm bg-blue-50 text-blue-700 hover:bg-blue-100 border border-blue-200">üìù Text</button>
          <button onclick="addRechercheMaterial('idee')" class="btn btn-sm bg-yellow-50 text-yellow-700 hover:bg-yellow-100 border border-yellow-200">üí° Idee</button>
          <button onclick="addRechercheMaterial('link')" class="btn btn-sm bg-green-50 text-green-700 hover:bg-green-100 border border-green-200">üîó Link</button>
          <button onclick="addRechercheMaterial('bild')" class="btn btn-sm bg-purple-50 text-purple-700 hover:bg-purple-100 border border-purple-200">üì∑ Bild</button>
        </div>
        
        ${items.length === 0 ? `
          <div class="text-center text-gray-400 py-12">
            <div class="text-4xl mb-3">üìé</div>
            <p class="text-sm">Recherche-Material sammeln</p>
            <p class="text-xs mt-1">Texte, Ideen, Links und Bilder f√ºr dein Projekt</p>
          </div>
        ` : `
          <div class="space-y-3">
            ${items.map((item, idx) => {
              const icons = { text: 'üìù', idee: 'üí°', link: 'üîó', bild: 'üì∑' };
              const colors = { text: 'blue', idee: 'yellow', link: 'green', bild: 'purple' };
              const c = colors[item.typ] || 'gray';
              return `
                <div class="border border-${c}-200 bg-${c}-50 rounded-lg p-4">
                  <div class="flex items-start justify-between mb-2">
                    <div class="flex items-center gap-2">
                      <span>${icons[item.typ] || 'üìÑ'}</span>
                      <input type="text" value="${(item.titel || '').replace(/"/g, '&quot;')}" 
                        onchange="updateRechercheMaterial('${item.id}', 'titel', this.value)"
                        class="font-medium bg-transparent border-b border-transparent hover:border-${c}-300 focus:border-${c}-500 outline-none"
                        placeholder="Titel...">
                    </div>
                    <button onclick="deleteRechercheMaterial('${item.id}')" class="text-gray-400 hover:text-red-500 text-sm">‚úï</button>
                  </div>
                  ${item.typ === 'link' ? `
                    <input type="url" value="${(item.url || '').replace(/"/g, '&quot;')}" 
                      onchange="updateRechercheMaterial('${item.id}', 'url', this.value)"
                      class="w-full text-sm p-2 rounded border border-${c}-200 bg-white mb-2" placeholder="https://...">
                  ` : ''}
                  ${item.typ === 'bild' ? `
                    ${item.bildData ? `<img src="${item.bildData}" class="max-h-40 rounded mb-2 cursor-pointer" onclick="openLightboxSingle('${item.bildData}')">` : ''}
                    <input type="file" accept="image/*" onchange="uploadRechercheBild('${item.id}', this)" class="text-xs mb-2">
                  ` : ''}
                  <textarea rows="2" 
                    onchange="updateRechercheMaterial('${item.id}', 'inhalt', this.value)"
                    class="w-full text-sm p-2 rounded border border-${c}-200 bg-white resize-y" 
                    placeholder="Notizen...">${item.inhalt || ''}</textarea>
                  <div class="mt-2">
                    <select onchange="toggleRechercheSzene('${item.id}', this.value); this.value='';" 
                      class="text-xs border rounded px-2 py-1">
                      <option value="">+ Szene zuordnen</option>
                      ${state.szenen.map(s => `<option value="${s.id}">${s.nummer} ${s.titel}</option>`).join('')}
                    </select>
                    <span class="text-xs text-gray-500 ml-2">${(item.szeneIds || []).map(sid => {
                      const sz = state.szenen.find(s => s.id === sid);
                      return sz ? `<span class="inline-block bg-white border rounded px-1 mr-1">${sz.nummer} <button onclick="toggleRechercheSzene('${item.id}','${sid}')" class="text-red-400 ml-1">√ó</button></span>` : '';
                    }).join('')}</span>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        `}
      `;
    }
    
    function renderMedienMusikTab() {
      const mk = state.musikkonzept || { text: '', stuecke: [] };
      return `
        <div class="mb-6">
          <label class="block text-sm font-medium text-gray-700 mb-2">Musikkonzept</label>
          <textarea rows="4" 
            onchange="state.musikkonzept.text = this.value; saveProjektDaten();"
            class="w-full p-3 rounded-lg border border-gray-300 resize-y text-sm"
            placeholder="Beschreibe das Musikkonzept der Inszenierung...">${mk.text || ''}</textarea>
        </div>
        
        <div class="flex items-center justify-between mb-3">
          <h3 class="font-medium text-gray-700">‚ô´ St√ºckliste</h3>
          <button onclick="addMusikStueck()" class="btn btn-sm bg-indigo-50 text-indigo-700 hover:bg-indigo-100 border border-indigo-200">+ St√ºck</button>
        </div>
        
        ${(mk.stuecke || []).length === 0 ? `
          <div class="text-center text-gray-400 py-8">
            <div class="text-4xl mb-3">‚ô´</div>
            <p class="text-sm">Noch keine Musikst√ºcke erfasst</p>
          </div>
        ` : `
          <div class="space-y-3">
            ${mk.stuecke.map(s => `
              <div class="border border-indigo-200 bg-indigo-50 rounded-lg p-4">
                <div class="flex items-start justify-between mb-2">
                  <input type="text" value="${(s.titel || '').replace(/"/g, '&quot;')}" 
                    onchange="updateMusikStueck('${s.id}', 'titel', this.value)"
                    class="font-medium bg-transparent border-b border-transparent hover:border-indigo-300 focus:border-indigo-500 outline-none"
                    placeholder="Titel des St√ºcks...">
                  <button onclick="deleteMusikStueck('${s.id}')" class="text-gray-400 hover:text-red-500 text-sm">‚úï</button>
                </div>
                <input type="text" value="${(s.kuenstler || '').replace(/"/g, '&quot;')}" 
                  onchange="updateMusikStueck('${s.id}', 'kuenstler', this.value)"
                  class="w-full text-sm p-2 rounded border border-indigo-200 bg-white mb-2" placeholder="K√ºnstler / Komponist">
                <input type="text" value="${(s.einsatz || '').replace(/"/g, '&quot;')}" 
                  onchange="updateMusikStueck('${s.id}', 'einsatz', this.value)"
                  class="w-full text-sm p-2 rounded border border-indigo-200 bg-white mb-2" placeholder="Einsatz (wann/wo im St√ºck)">
                <textarea rows="2" 
                  onchange="updateMusikStueck('${s.id}', 'notizen', this.value)"
                  class="w-full text-sm p-2 rounded border border-indigo-200 bg-white resize-y" 
                  placeholder="Notizen...">${s.notizen || ''}</textarea>
                <div class="mt-2">
                  <select onchange="toggleMusikSzene('${s.id}', this.value); this.value='';" 
                    class="text-xs border rounded px-2 py-1">
                    <option value="">+ Szene zuordnen</option>
                    ${state.szenen.map(sz => `<option value="${sz.id}">${sz.nummer} ${sz.titel}</option>`).join('')}
                  </select>
                  <span class="text-xs text-gray-500 ml-2">${(s.szeneIds || []).map(sid => {
                    const sz = state.szenen.find(sc => sc.id === sid);
                    return sz ? `<span class="inline-block bg-white border rounded px-1 mr-1">${sz.nummer} <button onclick="toggleMusikSzene('${s.id}','${sid}')" class="text-red-400 ml-1">√ó</button></span>` : '';
                  }).join('')}</span>
                </div>
              </div>
            `).join('')}
          </div>
        `}
      `;
    }
    
    // === RECHERCHE-MATERIAL CRUD ===
    function addRechercheMaterial(typ) {
      pushUndo();
      state.rechercheMaterial.push({
        id: genId(),
        typ: typ,
        titel: '',
        inhalt: '',
        url: '',
        bildData: '',
        szeneIds: [],
        tags: []
      });
      saveProjektDaten();
      render();
    }
    
    function updateRechercheMaterial(id, field, value) {
      const item = state.rechercheMaterial.find(r => r.id === id);
      if (item) {
        item[field] = value;
        saveProjektDaten();
      }
    }
    
    function deleteRechercheMaterial(id) {
      if (!confirm('Material l√∂schen?')) return;
      pushUndo();
      state.rechercheMaterial = state.rechercheMaterial.filter(r => r.id !== id);
      saveProjektDaten();
      render();
    }
    
    function toggleRechercheSzene(materialId, szeneId) {
      if (!szeneId) return;
      const item = state.rechercheMaterial.find(r => r.id === materialId);
      if (!item) return;
      if (!item.szeneIds) item.szeneIds = [];
      const idx = item.szeneIds.indexOf(szeneId);
      if (idx >= 0) {
        item.szeneIds.splice(idx, 1);
      } else {
        item.szeneIds.push(szeneId);
      }
      saveProjektDaten();
      render();
    }
    
    function uploadRechercheBild(materialId, input) {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        updateRechercheMaterial(materialId, 'bildData', e.target.result);
        render();
      };
      reader.readAsDataURL(file);
    }
    
    function openLightboxSingle(src) {
      state.lightboxImages = [src];
      state.lightboxIndex = 0;
      state.showLightbox = true;
      render();
    }
    
    // === MUSIKKONZEPT CRUD ===
    function addMusikStueck() {
      pushUndo();
      if (!state.musikkonzept) state.musikkonzept = { text: '', stuecke: [] };
      if (!state.musikkonzept.stuecke) state.musikkonzept.stuecke = [];
      state.musikkonzept.stuecke.push({
        id: genId(),
        titel: '',
        kuenstler: '',
        szeneIds: [],
        einsatz: '',
        notizen: ''
      });
      saveProjektDaten();
      render();
    }
    
    function updateMusikStueck(id, field, value) {
      const stueck = (state.musikkonzept?.stuecke || []).find(s => s.id === id);
      if (stueck) {
        stueck[field] = value;
        saveProjektDaten();
      }
    }
    
    function deleteMusikStueck(id) {
      if (!confirm('Musikst√ºck l√∂schen?')) return;
      pushUndo();
      state.musikkonzept.stuecke = state.musikkonzept.stuecke.filter(s => s.id !== id);
      saveProjektDaten();
      render();
    }
    
    function toggleMusikSzene(stueckId, szeneId) {
      if (!szeneId) return;
      const stueck = (state.musikkonzept?.stuecke || []).find(s => s.id === stueckId);
      if (!stueck) return;
      if (!stueck.szeneIds) stueck.szeneIds = [];
      const idx = stueck.szeneIds.indexOf(szeneId);
      if (idx >= 0) {
        stueck.szeneIds.splice(idx, 1);
      } else {
        stueck.szeneIds.push(szeneId);
      }
      saveProjektDaten();
      render();
    }
    
    // ============================================
    // KONZEPT-MODUL (v3.0)
    // ============================================
    function renderKonzeptView() {
      const tab = state.konzeptTab || 'treatment';
      return `
        <div class="flex-1 flex flex-col overflow-hidden">
          <div class="px-6 py-4 border-b border-gray-200 bg-white">
            <div class="flex items-center justify-between mb-3">
              <h2 class="text-lg font-semibold text-gray-900">üß≠ Konzept</h2>
            </div>
            <div class="flex gap-1 border-b border-gray-200 -mb-4">
              ${[
                { id: 'treatment', icon: 'üìù', label: 'Treatment' },
                { id: 'fundament', icon: 'üíé', label: 'Fundament' },
                { id: 'werte', icon: '‚öñÔ∏è', label: 'Werte' },
                { id: 'motive', icon: 'üîÑ', label: 'Motive' }
              ].map(t => `
                <button onclick="state.konzeptTab='${t.id}'; render();"
                  class="px-4 py-2 text-sm font-medium border-b-2 transition-colors ${tab === t.id ? 'border-amber-500 text-amber-700' : 'border-transparent text-gray-500 hover:text-gray-700'}">
                  ${t.icon} ${t.label}
                </button>
              `).join('')}
            </div>
          </div>
          <div class="flex-1 overflow-y-auto p-6">
            ${tab === 'treatment' ? renderKonzeptTreatment() : ''}
            ${tab === 'fundament' ? renderKonzeptFundament() : ''}
            ${tab === 'werte' ? renderKonzeptWerte() : ''}
            ${tab === 'motive' ? renderKonzeptMotive() : ''}
          </div>
        </div>
      `;
    }
    
    function renderKonzeptTreatment() {
      const k = state.konzept || {};
      const chapters = k.treatment || [];
      return `
        <div class="mb-4 flex justify-between items-center">
          <p class="text-sm text-gray-500">Die Geschichte deiner Inszenierung in Prosa ‚Äì kapitelweise aufklappbar.</p>
          <button onclick="addTreatmentChapter()" class="btn btn-sm bg-amber-50 text-amber-700 hover:bg-amber-100 border border-amber-200">+ Kapitel</button>
        </div>
        ${chapters.length === 0 ? `
          <div class="text-center text-gray-400 py-12">
            <div class="text-4xl mb-3">üìù</div>
            <p class="text-sm">Noch kein Treatment geschrieben</p>
            <p class="text-xs mt-1">Beschreibe die Geschichte deiner Inszenierung Kapitel f√ºr Kapitel</p>
          </div>
        ` : `
          <div class="space-y-3">
            ${chapters.map((ch, idx) => `
              <div class="border border-amber-200 bg-amber-50 rounded-lg overflow-hidden">
                <div class="flex items-center gap-2 p-3 cursor-pointer hover:bg-amber-100" onclick="this.nextElementSibling.classList.toggle('hidden')">
                  <span class="text-gray-400 text-xs">${idx + 1}.</span>
                  <input type="text" value="${(ch.titel || '').replace(/"/g, '&quot;')}"
                    onclick="event.stopPropagation()"
                    onchange="updateTreatmentChapter('${ch.id}', 'titel', this.value)"
                    class="flex-1 font-medium bg-transparent border-b border-transparent hover:border-amber-300 focus:border-amber-500 outline-none"
                    placeholder="Kapitel-Titel...">
                  <div class="flex gap-1">
                    ${idx > 0 ? `<button onclick="event.stopPropagation(); moveTreatmentChapter('${ch.id}', -1)" class="text-gray-400 hover:text-gray-600 text-xs px-1">‚ñ≤</button>` : ''}
                    ${idx < chapters.length - 1 ? `<button onclick="event.stopPropagation(); moveTreatmentChapter('${ch.id}', 1)" class="text-gray-400 hover:text-gray-600 text-xs px-1">‚ñº</button>` : ''}
                    <button onclick="event.stopPropagation(); deleteTreatmentChapter('${ch.id}')" class="text-gray-400 hover:text-red-500 text-xs px-1">‚úï</button>
                  </div>
                </div>
                <div class="p-3 pt-0">
                  <textarea rows="6"
                    onchange="updateTreatmentChapter('${ch.id}', 'text', this.value)"
                    class="w-full text-sm p-3 rounded border border-amber-200 bg-white resize-y"
                    placeholder="Erz√§hle dieses Kapitel...">${ch.text || ''}</textarea>
                </div>
              </div>
            `).join('')}
          </div>
        `}
      `;
    }
    
    function renderKonzeptFundament() {
      const f = state.konzept?.fundament || {};
      const fields = [
        { key: 'kern', label: 'üéØ Kern', placeholder: 'Was ist der Kern deiner Inszenierung? Worum geht es wirklich?', rows: 3 },
        { key: 'unaussprechliches', label: 'ü§´ Das Unaussprechliche', placeholder: 'Was kann in diesem St√ºck nicht gesagt werden, muss aber gezeigt werden?', rows: 3 },
        { key: 'emotionalerBogen', label: 'üåä Emotionaler Bogen', placeholder: 'Welche emotionale Reise macht das Publikum?', rows: 3 },
        { key: 'konflikt', label: '‚ö° Zentraler Konflikt', placeholder: 'Was ist der zentrale Konflikt der Inszenierung?', rows: 3 }
      ];
      return `
        <p class="text-sm text-gray-500 mb-4">Das dramaturgische Fundament deiner Inszenierung.</p>
        <div class="space-y-4">
          <!-- Logline (Referenz aus Projektdaten) -->
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">üìã Logline</label>
            <div class="text-sm p-3 rounded-lg border border-gray-200 bg-gray-50 text-gray-600 italic">
              ${state.projektMeta.logline || '<span class="text-gray-400">Noch keine Logline ‚Äì editierbar im Titelblatt</span>'}
            </div>
          </div>
          ${fields.map(fld => `
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">${fld.label}</label>
              <textarea rows="${fld.rows}"
                onchange="if(!state.konzept.fundament) state.konzept.fundament={}; state.konzept.fundament['${fld.key}'] = this.value; saveProjektDaten();"
                class="w-full p-3 rounded-lg border border-gray-300 resize-y text-sm"
                placeholder="${fld.placeholder}">${f[fld.key] || ''}</textarea>
            </div>
          `).join('')}
        </div>
      `;
    }
    
    function renderKonzeptWerte() {
      const werte = state.konzept?.werte || [];
      return `
        <div class="mb-4 flex justify-between items-center">
          <div>
            <p class="text-sm text-gray-500">Wertequadrate nach Friedemann Schulz von Thun.</p>
            <p class="text-xs text-gray-400 mt-1">Jedes Quadrat: positiver Wert ‚Üî √úbertreibung ‚Üî Gegenwert ‚Üî Entwertung</p>
          </div>
          <button onclick="addWertequadrat()" class="btn btn-sm bg-amber-50 text-amber-700 hover:bg-amber-100 border border-amber-200">+ Wertequadrat</button>
        </div>
        ${werte.length === 0 ? `
          <div class="text-center text-gray-400 py-12">
            <div class="text-4xl mb-3">‚öñÔ∏è</div>
            <p class="text-sm">Noch keine Wertequadrate definiert</p>
          </div>
        ` : `
          <div class="space-y-4">
            ${werte.map(w => `
              <div class="border border-amber-200 bg-amber-50 rounded-lg p-4">
                <div class="flex justify-between mb-3">
                  <span class="text-sm font-medium text-amber-800">Wertequadrat</span>
                  <button onclick="deleteWertequadrat('${w.id}')" class="text-gray-400 hover:text-red-500 text-sm">‚úï</button>
                </div>
                <div class="grid grid-cols-2 gap-2 mb-3">
                  <div>
                    <label class="text-xs text-gray-500">‚úÖ Positiver Wert</label>
                    <input type="text" value="${(w.wert1 || '').replace(/"/g, '&quot;')}"
                      onchange="updateWertequadrat('${w.id}', 'wert1', this.value)"
                      class="w-full text-sm p-2 rounded border border-green-200 bg-green-50" placeholder="z.B. Sparsamkeit">
                  </div>
                  <div>
                    <label class="text-xs text-gray-500">‚ö†Ô∏è √úbertreibung</label>
                    <input type="text" value="${(w.wert2 || '').replace(/"/g, '&quot;')}"
                      onchange="updateWertequadrat('${w.id}', 'wert2', this.value)"
                      class="w-full text-sm p-2 rounded border border-red-200 bg-red-50" placeholder="z.B. Geiz">
                  </div>
                  <div>
                    <label class="text-xs text-gray-500">‚úÖ Gegenwert</label>
                    <input type="text" value="${(w.wert3 || '').replace(/"/g, '&quot;')}"
                      onchange="updateWertequadrat('${w.id}', 'wert3', this.value)"
                      class="w-full text-sm p-2 rounded border border-green-200 bg-green-50" placeholder="z.B. Grossz√ºgigkeit">
                  </div>
                  <div>
                    <label class="text-xs text-gray-500">‚ö†Ô∏è Entwertung</label>
                    <input type="text" value="${(w.wert4 || '').replace(/"/g, '&quot;')}"
                      onchange="updateWertequadrat('${w.id}', 'wert4', this.value)"
                      class="w-full text-sm p-2 rounded border border-red-200 bg-red-50" placeholder="z.B. Verschwendung">
                  </div>
                </div>
                <div>
                  <label class="text-xs text-gray-500">Figuren-Zuordnung</label>
                  <div class="flex flex-wrap gap-1 mt-1">
                    ${state.figuren.map(fig => {
                      const selected = (w.figurIds || []).includes(fig.id);
                      return `<button onclick="toggleWerteFigur('${w.id}','${fig.id}')" 
                        class="text-xs px-2 py-1 rounded border ${selected ? 'bg-amber-200 border-amber-400 text-amber-800' : 'bg-white border-gray-200 text-gray-500 hover:border-amber-300'}">${fig.name}</button>`;
                    }).join('')}
                  </div>
                </div>
              </div>
            `).join('')}
          </div>
        `}
      `;
    }
    
    function renderKonzeptMotive() {
      const motive = state.konzept?.motive || [];
      return `
        <div class="mb-4 flex justify-between items-center">
          <p class="text-sm text-gray-500">Wiederkehrende Motive deiner Inszenierung.</p>
          <button onclick="addMotiv()" class="btn btn-sm bg-amber-50 text-amber-700 hover:bg-amber-100 border border-amber-200">+ Motiv</button>
        </div>
        ${motive.length === 0 ? `
          <div class="text-center text-gray-400 py-12">
            <div class="text-4xl mb-3">üîÑ</div>
            <p class="text-sm">Noch keine Motive definiert</p>
            <p class="text-xs mt-1">Welche Bilder, Symbole oder Themen kehren im St√ºck wieder?</p>
          </div>
        ` : `
          <div class="space-y-3">
            ${motive.map(m => `
              <div class="border border-amber-200 bg-amber-50 rounded-lg p-4">
                <div class="flex items-start justify-between mb-2">
                  <input type="text" value="${(m.name || '').replace(/"/g, '&quot;')}"
                    onchange="updateMotiv('${m.id}', 'name', this.value)"
                    class="font-medium bg-transparent border-b border-transparent hover:border-amber-300 focus:border-amber-500 outline-none"
                    placeholder="Motiv-Name...">
                  <button onclick="deleteMotiv('${m.id}')" class="text-gray-400 hover:text-red-500 text-sm">‚úï</button>
                </div>
                <textarea rows="2"
                  onchange="updateMotiv('${m.id}', 'bedeutung', this.value)"
                  class="w-full text-sm p-2 rounded border border-amber-200 bg-white resize-y mb-2"
                  placeholder="Bedeutung des Motivs...">${m.bedeutung || ''}</textarea>
                <textarea rows="2"
                  onchange="updateMotiv('${m.id}', 'betrachtungen', this.value)"
                  class="w-full text-sm p-2 rounded border border-amber-200 bg-white resize-y"
                  placeholder="Betrachtungen / Wo taucht es auf?">${m.betrachtungen || ''}</textarea>
              </div>
            `).join('')}
          </div>
        `}
      `;
    }
    
    // === KONZEPT CRUD ===
    function addTreatmentChapter() {
      pushUndo();
      if (!state.konzept.treatment) state.konzept.treatment = [];
      state.konzept.treatment.push({ id: genId(), titel: '', text: '', sortOrder: state.konzept.treatment.length });
      saveProjektDaten(); render();
    }
    function updateTreatmentChapter(id, field, value) {
      const ch = (state.konzept.treatment || []).find(c => c.id === id);
      if (ch) { ch[field] = value; saveProjektDaten(); }
    }
    function deleteTreatmentChapter(id) {
      if (!confirm('Kapitel l√∂schen?')) return;
      pushUndo();
      state.konzept.treatment = state.konzept.treatment.filter(c => c.id !== id);
      saveProjektDaten(); render();
    }
    function moveTreatmentChapter(id, direction) {
      const arr = state.konzept.treatment;
      const idx = arr.findIndex(c => c.id === id);
      if (idx < 0) return;
      const newIdx = idx + direction;
      if (newIdx < 0 || newIdx >= arr.length) return;
      pushUndo();
      [arr[idx], arr[newIdx]] = [arr[newIdx], arr[idx]];
      saveProjektDaten(); render();
    }
    
    function addWertequadrat() {
      pushUndo();
      if (!state.konzept.werte) state.konzept.werte = [];
      state.konzept.werte.push({ id: genId(), wert1: '', wert2: '', wert3: '', wert4: '', figurIds: [] });
      saveProjektDaten(); render();
    }
    function updateWertequadrat(id, field, value) {
      const w = (state.konzept.werte || []).find(x => x.id === id);
      if (w) { w[field] = value; saveProjektDaten(); }
    }
    function deleteWertequadrat(id) {
      if (!confirm('Wertequadrat l√∂schen?')) return;
      pushUndo();
      state.konzept.werte = state.konzept.werte.filter(x => x.id !== id);
      saveProjektDaten(); render();
    }
    function toggleWerteFigur(werteId, figurId) {
      const w = (state.konzept.werte || []).find(x => x.id === werteId);
      if (!w) return;
      if (!w.figurIds) w.figurIds = [];
      const idx = w.figurIds.indexOf(figurId);
      if (idx >= 0) w.figurIds.splice(idx, 1); else w.figurIds.push(figurId);
      saveProjektDaten(); render();
    }
    
    function addMotiv() {
      pushUndo();
      if (!state.konzept.motive) state.konzept.motive = [];
      state.konzept.motive.push({ id: genId(), name: '', bedeutung: '', betrachtungen: '' });
      saveProjektDaten(); render();
    }
    function updateMotiv(id, field, value) {
      const m = (state.konzept.motive || []).find(x => x.id === id);
      if (m) { m[field] = value; saveProjektDaten(); }
    }
    function deleteMotiv(id) {
      if (!confirm('Motiv l√∂schen?')) return;
      pushUndo();
      state.konzept.motive = state.konzept.motive.filter(x => x.id !== id);
      saveProjektDaten(); render();
    }
    
    // === BEZIEHUNGEN CRUD ===
    function addBeziehung() {
      if (state.figuren.length < 2) {
        alert('Du brauchst mindestens 2 Figuren f√ºr eine Beziehung.');
        return;
      }
      pushUndo();
      // Default: erste zwei Figuren
      state.beziehungen.push({
        id: genId(),
        figur1Id: state.figuren[0].id,
        figur2Id: state.figuren[1].id,
        art: '',
        beschreibung: '',
        richtung: 'beidseiting'
      });
      saveProjektDaten(); render();
      // Scroll to bottom
      setTimeout(() => {
        const container = document.querySelector('.flex-1.p-6.overflow-y-auto');
        if (container) container.scrollTop = container.scrollHeight;
      }, 50);
    }
    function updateBeziehung(id, field, value) {
      const b = (state.beziehungen || []).find(x => x.id === id);
      if (b) { b[field] = value; saveProjektDaten(); }
    }
    function deleteBeziehung(id) {
      if (!confirm('Beziehung l√∂schen?')) return;
      pushUndo();
      state.beziehungen = state.beziehungen.filter(x => x.id !== id);
      saveProjektDaten(); render();
    }
    function setBeziehungFigur(bezId, which, figurId) {
      const b = (state.beziehungen || []).find(x => x.id === bezId);
      if (b) { b[which] = figurId; saveProjektDaten(); render(); }
    }
    
    // ============================================
    // TEAM & PROBEN-MODUL (v3.0, read-only aus Propla)
    // ============================================
    function renderTeamProbenView() {
      const tab = state.teamProbenTab || 'ensemble';
      return `
        <div class="flex-1 flex flex-col overflow-hidden">
          <div class="px-6 py-4 border-b border-gray-200 bg-white">
            <div class="flex items-center justify-between mb-3">
              <div>
                <h2 class="text-lg font-semibold text-gray-900">üë• Team & Proben</h2>
                <p class="text-xs text-gray-400">Daten aus Propla-Import ¬∑ Bearbeitung im Probeplan</p>
              </div>
            </div>
            <div class="flex gap-1 border-b border-gray-200 -mb-4">
              ${[
                { id: 'ensemble', icon: 'üé≠', label: 'Ensemble' },
                { id: 'team', icon: 'üé®', label: 'K√ºnstl. Team' },
                { id: 'probeplan', icon: 'üìÖ', label: 'Probeplan' }
              ].map(t => `
                <button onclick="state.teamProbenTab='${t.id}'; render();"
                  class="px-4 py-2 text-sm font-medium border-b-2 transition-colors ${tab === t.id ? 'border-teal-500 text-teal-700' : 'border-transparent text-gray-500 hover:text-gray-700'}">
                  ${t.icon} ${t.label}
                </button>
              `).join('')}
            </div>
          </div>
          <div class="flex-1 overflow-y-auto p-6">
            ${tab === 'ensemble' ? renderEnsembleTab() : ''}
            ${tab === 'team' ? renderTeamTab() : ''}
            ${tab === 'probeplan' ? renderProbeplanTab() : ''}
          </div>
        </div>
      `;
    }
    
    function renderEnsembleTab() {
      const items = state.ensemble || [];
      return items.length === 0 ? `
        <div class="text-center text-gray-400 py-12">
          <div class="text-4xl mb-3">üé≠</div>
          <p class="text-sm">Noch kein Ensemble importiert</p>
          <p class="text-xs mt-2">Importiere Ensemble-Daten aus dem Probeplan (Propla)<br>√ºber <strong>Import ‚Üí NINA-Exchange</strong></p>
        </div>
      ` : `
        <div class="space-y-3">
          ${items.map(p => {
            const rollen = (p.rolleIds || []).map(rid => {
              const fig = state.figuren.find(f => f.id === rid);
              return fig ? fig.name : '';
            }).filter(Boolean).join(', ');
            return `
              <div class="border border-teal-200 bg-teal-50 rounded-lg p-4">
                <div class="flex items-center justify-between">
                  <div>
                    <span class="font-medium">${p.name || 'Unbenannt'}</span>
                    ${rollen ? `<span class="text-sm text-teal-600 ml-2">‚Üí ${rollen}</span>` : ''}
                  </div>
                </div>
                <div class="text-xs text-gray-500 mt-1 flex flex-wrap gap-3">
                  ${p.email ? `<span>‚úâÔ∏è ${p.email}</span>` : ''}
                  ${p.telefon ? `<span>üìû ${p.telefon}</span>` : ''}
                  ${p.adresse ? `<span>üìç ${p.adresse}</span>` : ''}
                </div>
                ${p.notizen ? `<p class="text-xs text-gray-500 mt-2 italic">${p.notizen}</p>` : ''}
              </div>
            `;
          }).join('')}
        </div>
      `;
    }
    
    function renderTeamTab() {
      const items = state.team || [];
      return items.length === 0 ? `
        <div class="text-center text-gray-400 py-12">
          <div class="text-4xl mb-3">üé®</div>
          <p class="text-sm">Noch kein k√ºnstlerisches Team importiert</p>
          <p class="text-xs mt-2">Importiere Team-Daten aus dem Probeplan (Propla)<br>√ºber <strong>Import ‚Üí NINA-Exchange</strong></p>
        </div>
      ` : `
        <div class="space-y-3">
          ${items.map(p => `
            <div class="border border-teal-200 bg-teal-50 rounded-lg p-4">
              <div class="flex items-center gap-3">
                <span class="font-medium">${p.name || 'Unbenannt'}</span>
                ${p.funktion ? `<span class="text-sm bg-teal-200 text-teal-800 px-2 py-0.5 rounded">${p.funktion}</span>` : ''}
              </div>
              <div class="text-xs text-gray-500 mt-1 flex flex-wrap gap-3">
                ${p.email ? `<span>‚úâÔ∏è ${p.email}</span>` : ''}
                ${p.telefon ? `<span>üìû ${p.telefon}</span>` : ''}
              </div>
              ${p.notizen ? `<p class="text-xs text-gray-500 mt-2 italic">${p.notizen}</p>` : ''}
            </div>
          `).join('')}
        </div>
      `;
    }
    
    function renderProbeplanTab() {
      const items = (state.probeplan || []).sort((a, b) => (a.datum || '').localeCompare(b.datum || ''));
      return items.length === 0 ? `
        <div class="text-center text-gray-400 py-12">
          <div class="text-4xl mb-3">üìÖ</div>
          <p class="text-sm">Noch kein Probeplan importiert</p>
          <p class="text-xs mt-2">Importiere Probeplan-Daten aus dem Probeplan (Propla)<br>√ºber <strong>Import ‚Üí NINA-Exchange</strong></p>
        </div>
      ` : `
        <div class="space-y-2">
          ${items.map(p => {
            const datum = p.datum ? new Date(p.datum).toLocaleDateString('de-CH', { weekday: 'short', day: '2-digit', month: '2-digit', year: 'numeric' }) : '?';
            const szenen = (p.szeneIds || []).map(sid => {
              const sz = state.szenen.find(s => s.id === sid);
              return sz ? sz.nummer : '';
            }).filter(Boolean).join(', ');
            return `
              <div class="border border-teal-200 bg-teal-50 rounded-lg p-3 flex items-center gap-4">
                <div class="text-sm font-medium w-32">${datum}</div>
                <div class="text-sm text-gray-600">${p.zeit || ''}</div>
                <div class="text-sm flex-1">
                  ${p.ort ? `<span class="text-gray-500">üìç ${p.ort}</span>` : ''}
                  ${szenen ? `<span class="ml-2 text-teal-600">üé¨ ${szenen}</span>` : ''}
                </div>
                ${p.typ ? `<span class="text-xs bg-teal-200 text-teal-800 px-2 py-0.5 rounded">${p.typ}</span>` : ''}
              </div>
            `;
          }).join('')}
        </div>
      `; 
    }
    
    // Speicherinfo im Header aktualisieren
    async function updateStorageInfo() {
      const infoEl = document.getElementById('storage-info');
      if (!infoEl) return;
      
      try {
        const info = await getAudioStorageInfo();
        infoEl.innerHTML = `
          <div>üíæ ${info.count} Audio${info.count !== 1 ? 's' : ''} gespeichert</div>
          <div>${info.totalSizeMB} MB verwendet</div>
        `;
      } catch (e) {
        infoEl.innerHTML = '';
      }
    }
    
    // File Picker - global reference to prevent garbage collection
    let globalFileInput = null;
    
    function openFilePicker() {
      // Neues Input-Element erstellen
      globalFileInput = document.createElement('input');
      globalFileInput.type = 'file';
      globalFileInput.accept = '.mp3,.wav,.ogg,.m4a,.mp4,.mov,.avi,.webm,audio/*,video/*';
      globalFileInput.style.display = 'none';
      document.body.appendChild(globalFileInput);
      
      globalFileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
          processFile(file);
        }
        // Aufr√§umen
        if (globalFileInput && globalFileInput.parentNode) {
          globalFileInput.parentNode.removeChild(globalFileInput);
        }
        globalFileInput = null;
      });
      
      globalFileInput.click();
    }
    
    // Drag & Drop Handlers
    function handleDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('border-blue-400', 'bg-blue-50');
    }
    
    function handleDragLeave(e) {
      e.currentTarget.classList.remove('border-blue-400', 'bg-blue-50');
    }
    
    function handleFileDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('border-blue-400', 'bg-blue-50');
      const file = e.dataTransfer.files[0];
      if (file) processFile(file);
    }
    
    async function processFile(file) {
      // MIME-Type pr√ºfen
      let isAudio = file.type.startsWith('audio/');
      let isVideo = file.type.startsWith('video/');
      
      // Fallback: Dateiendung pr√ºfen (f√ºr Dateien ohne MIME-Type)
      if (!isAudio && !isVideo) {
        const ext = file.name.split('.').pop().toLowerCase();
        const audioExtensions = ['mp3', 'wav', 'ogg', 'm4a', 'aac', 'flac', 'wma'];
        const videoExtensions = ['mp4', 'mov', 'avi', 'webm', 'mkv', 'm4v', 'wmv'];
        
        if (audioExtensions.includes(ext)) {
          isAudio = true;
        } else if (videoExtensions.includes(ext)) {
          isVideo = true;
        }
      }
      
      if (!isAudio && !isVideo) {
        alert('Nicht erkannt als Audio oder Video.\nBitte MP3, WAV, MP4, MOV oder √§hnliche Dateien verwenden.');
        return;
      }
      
      pushUndo();
      
      const mediumId = 'med_' + Date.now();
      
      const medium = {
        id: mediumId,
        name: file.name.replace(/\.[^/.]+$/, ''),
        source: 'local',
        url: '',
        filename: file.name,
        localFileUrl: URL.createObjectURL(file),
        type: isAudio ? 'audio' : 'video',
        szenen: [],
        notizen: '',
        audioStored: false
      };
      
      // Audio permanent in IndexedDB speichern
      if (isAudio) {
        try {
          await saveAudioToDB(mediumId, file);
          medium.audioStored = true;
          console.log('‚úÖ Audio permanent gespeichert');
        } catch (e) {
          console.error('Audio-Speicherung fehlgeschlagen:', e);
          // Fallback: nur tempor√§r
        }
      }
      
      state.medien.push(medium);
      saveProjektDaten();
      render();
      
      // Speicherinfo aktualisieren
      if (isAudio) {
        updateStorageInfo();
      }
    }
    
    function addFromUrl() {
      const urlInput = document.getElementById('url-input');
      const url = urlInput.value.trim();
      
      if (!url) return;
      
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        alert('Bitte eine g√ºltige URL eingeben (https://...)');
        return;
      }
      
      pushUndo();
      
      const isYouTube = url.includes('youtube.com') || url.includes('youtu.be');
      const isVideo = /\.(mp4|mov|avi|webm|mkv)(\?|$)/i.test(url) || 
                      isYouTube || url.includes('vimeo.com');
      
      // Name generieren
      let name = 'Neues Medium';
      if (isYouTube) {
        name = 'YouTube Video';
        // Versuche Video-ID als Hinweis zu nutzen
        const ytId = getYouTubeId(url);
        if (ytId) name = 'YouTube: ' + ytId;
      } else {
        try {
          const urlObj = new URL(url);
          const filename = urlObj.pathname.split('/').pop();
          if (filename && filename.length > 0) {
            name = decodeURIComponent(filename.replace(/\.[^/.]+$/, ''));
          }
        } catch(e) {}
      }
      
      const medium = {
        id: 'med_' + Date.now(),
        name: name,
        source: 'cloud',
        url: url,
        filename: '',
        type: isVideo ? 'video' : 'audio',
        szenen: [],
        notizen: ''
      };
      
      state.medien.push(medium);
      urlInput.value = '';
      saveProjektDaten();
      render();
    }
    
    function renderMediumCard(medium) {
      const isPlaying = state.currentlyPlaying === medium.id;
      const icon = medium.type === 'audio' ? 'üéµ' : 'üé¨';
      const hasFile = medium.source === 'cloud' ? !!medium.url : !!medium.localFileUrl;
      const isYouTube = isYouTubeUrl(medium.url);
      const youtubeId = isYouTube ? getYouTubeId(medium.url) : null;
      
      // Status-Hinweis f√ºr lokale Dateien
      let statusHint = '';
      if (medium.source === 'local') {
        if (medium.type === 'audio' && medium.audioStored) {
          statusHint = `
            <div class="bg-green-50 border border-green-200 rounded px-3 py-2 mb-3 text-sm text-green-700">
              ‚úÖ Audio permanent gespeichert
            </div>
          `;
        } else if (medium.type === 'video') {
          statusHint = `
            <div class="bg-amber-50 border border-amber-200 rounded px-3 py-2 mb-3 text-sm text-amber-700">
              ‚ö†Ô∏è¬è Video ‚Äì muss nach Browser-Neustart neu gew√§hlt werden
            </div>
          `;
        } else if (medium.type === 'audio' && !medium.audioStored) {
          statusHint = `
            <div class="bg-amber-50 border border-amber-200 rounded px-3 py-2 mb-3 text-sm text-amber-700">
              ‚è≥ Audio wird gespeichert...
            </div>
          `;
        }
      }
      
      return `
        <div class="bg-white border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow">
          <!-- Status-Hinweis -->
          ${statusHint}
          
          <!-- YouTube-Hinweis -->
          ${isYouTube ? `
            <div class="bg-red-50 border border-red-200 rounded px-3 py-2 mb-3 text-sm text-red-700">
              üì∫ YouTube-Video ‚Äì Tempo-Kontrolle nur √ºber YouTube-Player
            </div>
          ` : ''}
          
          <div class="flex items-start gap-4">
            <!-- Icon -->
            <div class="text-3xl">${icon}</div>
            
            <!-- Inline-Edit Felder -->
            <div class="flex-1 min-w-0 space-y-2">
              <!-- Name -->
              <input type="text" class="input w-full font-medium" value="${medium.name}"
                     onchange="updateMedium('${medium.id}', 'name', this.value)"
                     placeholder="Name eingeben...">
              
              <!-- Szenen-Auswahl -->
              <div class="flex items-center gap-2 flex-wrap">
                <span class="text-sm text-gray-500">Szenen:</span>
                ${state.szenen.length === 0 ? `
                  <span class="text-xs text-gray-400">Keine Szenen vorhanden</span>
                ` : state.szenen.map(s => `
                  <label class="inline-flex items-center gap-1 text-sm cursor-pointer hover:bg-gray-100 px-2 py-1 rounded">
                    <input type="checkbox" ${medium.szenen?.includes(s.id) ? 'checked' : ''}
                           onchange="toggleMediumSzene('${medium.id}', '${s.id}', this.checked)">
                    <span>${s.nummer}</span>
                  </label>
                `).join('')}
              </div>
              
              <!-- Notizen -->
              <input type="text" class="input w-full text-sm" value="${medium.notizen || ''}"
                     onchange="updateMedium('${medium.id}', 'notizen', this.value)"
                     placeholder="Notizen (z.B. Ab 2:30 neue Variante)">
              
              <!-- Player Controls -->
              <div class="flex items-center gap-2 flex-wrap pt-2">
                ${hasFile || isYouTube ? `
                  <button class="btn btn-sm ${isPlaying ? 'btn-primary' : 'btn-outline'}" 
                          data-play-btn="${medium.id}"
                          onclick="togglePlayMedium('${medium.id}')">
                    ${isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play'}
                  </button>
                ` : medium.source === 'local' ? `
                  <button class="btn btn-sm btn-outline" onclick="reloadLocalFile('${medium.id}')">
                    üìÇ Datei neu laden
                  </button>
                ` : ''}
                
                <!-- Tempo (nicht f√ºr YouTube) -->
                ${!isYouTube ? `
                  <div class="flex items-center gap-1">
                    <span class="text-xs text-gray-400 mr-1">Tempo:</span>
                    ${['0.5', '0.75', '1.0', '1.25', '1.5'].map(rate => `
                      <button class="btn btn-xs ${state.playbackRate == rate ? 'btn-primary' : 'btn-outline'}" 
                              data-tempo-btn="${rate}"
                              onclick="setPlaybackRate(${rate})" style="padding: 2px 6px;">
                        ${rate}x
                      </button>
                    `).join('')}
                  </div>
                ` : ''}
              </div>
            </div>
            
            <!-- Delete -->
            <button class="btn btn-sm btn-outline text-red-500 hover:bg-red-50" 
                    onclick="deleteMedium('${medium.id}')" title="L√∂schen">üóëÔ∏è¬è</button>
          </div>
          
          <!-- Player Element -->
          <div id="player-${medium.id}" class="mt-3 ${isPlaying ? '' : 'hidden'}">
            ${isYouTube && youtubeId ? `
              <iframe 
                width="100%" 
                height="250" 
                src="https://www.youtube.com/embed/${youtubeId}?autoplay=0" 
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                allowfullscreen
                class="rounded">
              </iframe>
            ` : medium.type === 'audio' ? `
              <audio id="media-${medium.id}" class="w-full" controls
                     src="${medium.source === 'cloud' ? convertToDirectUrl(medium.url) : (medium.localFileUrl || '')}"></audio>
            ` : `
              <video id="media-${medium.id}" class="w-full rounded" controls style="max-height: 300px;"
                     src="${medium.source === 'cloud' ? convertToDirectUrl(medium.url) : (medium.localFileUrl || '')}"></video>
            `}
          </div>
        </div>
      `;
    }
    
    function updateMedium(mediumId, field, value) {
      const medium = state.medien.find(m => m.id === mediumId);
      if (medium) {
        medium[field] = value;
        saveProjektDaten();
      }
    }
    
    function toggleMediumSzene(mediumId, szeneId, checked) {
      const medium = state.medien.find(m => m.id === mediumId);
      if (medium) {
        if (!medium.szenen) medium.szenen = [];
        
        if (checked && !medium.szenen.includes(szeneId)) {
          // Szene hinzuf√ºgen
          medium.szenen.push(szeneId);
          
          // ========== CUE ERSTELLEN ==========
          const existiertBereits = state.cues.some(c => 
            (c.typ === 'q' || c.typ === 'v') && c.mediumId === mediumId && c.szeneId === szeneId
          );
          if (!existiertBereits) {
            const cueTyp = medium.type === 'audio' ? 'q' : 'v';
            const cuesInSzene = state.cues.filter(c => c.typ === cueTyp && c.szeneId === szeneId);
            const nextNummer = cuesInSzene.length > 0 
              ? Math.max(...cuesInSzene.map(c => c.nummer)) + 1 
              : 1;
            
            state.cues.push({
              id: genId(),
              typ: cueTyp,
              nummer: nextNummer,
              szeneId: szeneId,
              beschreibung: medium.name,
              mediumId: mediumId,
              ausloeser: '',
              dauer: '',
            });
          }
          // ====================================
        } else if (!checked) {
          // Szene entfernen
          medium.szenen = medium.szenen.filter(id => id !== szeneId);
          
          // ========== CUE L√ñSCHEN ==========
          state.cues = state.cues.filter(c => 
            !((c.typ === 'q' || c.typ === 'v') && c.mediumId === mediumId && c.szeneId === szeneId)
          );
          // ==================================
        }
        
        saveProjektDaten();
      }
    }
    
    function reloadLocalFile(mediumId) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'audio/*,video/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const medium = state.medien.find(m => m.id === mediumId);
          if (medium) {
            medium.filename = file.name;
            medium.localFileUrl = URL.createObjectURL(file);
            saveProjektDaten();
            render();
          }
        }
      };
      input.click();
    }
    
    function convertToDirectUrl(url) {
      if (!url) return '';
      if (url.includes('drive.google.com')) {
        const match = url.match(/\/d\/([a-zA-Z0-9_-]+)/);
        if (match) return 'https://drive.google.com/uc?export=download&id=' + match[1];
      }
      if (url.includes('dropbox.com')) {
        return url.replace('dl=0', 'dl=1').replace('www.dropbox.com', 'dl.dropboxusercontent.com');
      }
      return url;
    }
    
    // YouTube URL zu Embed-ID extrahieren
    function getYouTubeId(url) {
      if (!url) return null;
      // Verschiedene YouTube URL-Formate
      const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
        /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/
      ];
      for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
      }
      return null;
    }
    
    function isYouTubeUrl(url) {
      return url && (url.includes('youtube.com') || url.includes('youtu.be'));
    }
    
    function togglePlayMedium(mediumId) {
      const medium = state.medien.find(m => m.id === mediumId);
      if (!medium) return;
      
      // YouTube braucht Sonderbehandlung
      if (isYouTubeUrl(medium.url)) {
        // Toggle visibility des Players
        const playerContainer = document.getElementById('player-' + mediumId);
        if (playerContainer) {
          const isHidden = playerContainer.classList.contains('hidden');
          
          // Andere Player verstecken
          document.querySelectorAll('[id^="player-"]').forEach(el => {
            el.classList.add('hidden');
          });
          
          if (isHidden) {
            playerContainer.classList.remove('hidden');
            state.currentlyPlaying = mediumId;
          } else {
            playerContainer.classList.add('hidden');
            state.currentlyPlaying = null;
          }
        }
        updatePlayButtons();
        return;
      }
      
      // Wenn bereits spielt ‚Üí Pause
      if (state.currentlyPlaying === mediumId) {
        const mediaElement = document.getElementById('media-' + mediumId);
        if (mediaElement) mediaElement.pause();
        state.currentlyPlaying = null;
        updatePlayButtons();
        // Bottom-Player entfernen
        updateBottomPlayer();
        return;
      }
      
      // Stop andere Player
      if (state.currentlyPlaying) {
        const otherMedia = document.getElementById('media-' + state.currentlyPlaying);
        const otherPlayer = document.getElementById('player-' + state.currentlyPlaying);
        if (otherMedia) otherMedia.pause();
        if (otherPlayer) otherPlayer.classList.add('hidden');
      }
      
      // State setzen
      state.currentlyPlaying = mediumId;
      
      // Versuche existierenden Player zu finden (Medien-View)
      const existingPlayer = document.getElementById('player-' + mediumId);
      const existingMedia = document.getElementById('media-' + mediumId);
      
      if (existingPlayer && existingMedia) {
        // Player existiert im DOM (z.B. in Medien-Ansicht)
        existingPlayer.classList.remove('hidden');
        existingMedia.playbackRate = state.playbackRate;
        existingMedia.play().catch(e => {
          console.warn('Wiedergabe fehlgeschlagen:', e);
          alert('Wiedergabe fehlgeschlagen. URL pr√ºfen oder Datei neu laden.');
        });
        updatePlayButtons();
        return;
      }
      
      // Player existiert noch nicht im DOM (Textbuch-Ansicht / Sidebar)
      // ‚Üí Bottom-Player erstellen und abspielen
      updateBottomPlayer();
      updatePlayButtons();
      
      // Nach DOM-Update abspielen
      requestAnimationFrame(() => {
        setTimeout(() => {
          const newMedia = document.getElementById('bottom-media-player');
          if (newMedia) {
            newMedia.playbackRate = state.playbackRate;
            newMedia.play().catch(e => {
              console.warn('Wiedergabe fehlgeschlagen:', e);
              alert('Wiedergabe fehlgeschlagen. URL pr√ºfen oder Datei neu laden.');
            });
          }
        }, 50);
      });
    }
    
    // Bottom-Player im Textbuch: volle Breite am unteren Rand der Schreibfl√§che
    function updateBottomPlayer() {
      let container = document.getElementById('bottom-player-bar');
      
      if (!state.currentlyPlaying) {
        if (container) container.remove();
        return;
      }
      
      const medium = state.medien.find(m => m.id === state.currentlyPlaying);
      if (!medium) {
        if (container) container.remove();
        return;
      }
      
      const isYouTube = isYouTubeUrl(medium.url);
      if (isYouTube) return; // YouTube handled separately
      
      const src = medium.source === 'cloud' ? convertToDirectUrl(medium.url) : (medium.localFileUrl || '');
      if (!src) return;
      
      // Finde den Editor-Bereich
      const editorColumn = document.querySelector('.flex-1.flex.flex-col.overflow-hidden');
      if (!editorColumn) return;
      
      if (!container) {
        container = document.createElement('div');
        container.id = 'bottom-player-bar';
        editorColumn.appendChild(container);
      }
      
      container.style.cssText = 'padding: 8px 16px; background: #eff6ff; border-top: 2px solid #3b82f6; display: flex; align-items: center; gap: 12px;';
      
      const tempoButtons = ['0.5', '0.75', '1.0', '1.25', '1.5'].map(rate => 
        `<button onclick="setPlaybackRate(${rate})" data-tempo-btn="${rate}" 
                style="padding: 2px 6px; font-size: 11px; border-radius: 4px; border: 1px solid #cbd5e1; cursor: pointer;
                       background: ${state.playbackRate == rate ? '#3b82f6' : '#fff'}; color: ${state.playbackRate == rate ? '#fff' : '#374151'};"
                >${rate}x</button>`
      ).join('');
      
      container.innerHTML = `
        <div style="display: flex; align-items: center; gap: 6px; white-space: nowrap;">
          <span style="font-size: 16px;">üéµ</span>
          <span style="font-size: 12px; color: #1e40af; font-weight: 500; max-width: 150px; overflow: hidden; text-overflow: ellipsis;">${medium.name}</span>
        </div>
        <${medium.type === 'audio' ? 'audio' : 'video'} id="bottom-media-player" controls 
            src="${src}" style="flex: 1; height: ${medium.type === 'audio' ? '36px' : '48px'}; min-width: 0;"></${medium.type === 'audio' ? 'audio' : 'video'}>
        <div style="display: flex; gap: 3px; align-items: center;">
          ${tempoButtons}
        </div>
        <button onclick="togglePlayMedium('${medium.id}')" 
                style="padding: 4px 8px; font-size: 12px; border-radius: 4px; border: 1px solid #cbd5e1; cursor: pointer; background: #fff;">
          ‚èπÔ∏è
        </button>
      `;
      
      // Event: Wenn fertig gespielt, aufr√§umen
      const playerEl = container.querySelector('#bottom-media-player');
      if (playerEl) {
        playerEl.addEventListener('ended', () => {
          state.currentlyPlaying = null;
          updatePlayButtons();
          updateBottomPlayer();
        });
        playerEl.addEventListener('pause', () => {
          // Nur wenn nicht manuell gestoppt
        });
      }
    }
    
    // Nur die Play-Buttons aktualisieren, ohne render()
    function updatePlayButtons() {
      document.querySelectorAll('[data-play-btn]').forEach(btn => {
        const mediumId = btn.getAttribute('data-play-btn');
        const isPlaying = state.currentlyPlaying === mediumId;
        btn.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        btn.className = btn.className.replace(/btn-primary|btn-outline/g, '').trim();
        btn.classList.add(isPlaying ? 'btn-primary' : 'btn-outline');
      });
      
      // Tempo-Buttons aktualisieren
      document.querySelectorAll('[data-tempo-btn]').forEach(btn => {
        const rate = btn.getAttribute('data-tempo-btn');
        btn.className = btn.className.replace(/btn-primary|btn-outline/g, '').trim();
        btn.classList.add(state.playbackRate == rate ? 'btn-primary' : 'btn-outline');
      });
    }
    
    function setPlaybackRate(rate) {
      state.playbackRate = rate;
      
      // Auf allen aktiven Media-Elementen setzen
      if (state.currentlyPlaying) {
        const mediaElement = document.getElementById('media-' + state.currentlyPlaying);
        if (mediaElement && mediaElement.playbackRate !== undefined) {
          mediaElement.playbackRate = rate;
        }
        // Auch Bottom-Player
        const bottomPlayer = document.getElementById('bottom-media-player');
        if (bottomPlayer && bottomPlayer.playbackRate !== undefined) {
          bottomPlayer.playbackRate = rate;
        }
      }
      
      updatePlayButtons();
      // Bottom-Player Tempo-Buttons aktualisieren
      updateBottomPlayer();
    }
    
    async function deleteMedium(mediumId) {
      if (!confirm('Medium wirklich l√∂schen?')) return;
      
      // Audio aus IndexedDB l√∂schen
      const medium = state.medien.find(m => m.id === mediumId);
      if (medium && medium.type === 'audio' && medium.audioStored) {
        try {
          await deleteAudioFromDB(mediumId);
        } catch (e) {
          console.warn('Audio-L√∂schung fehlgeschlagen:', e);
        }
      }
      
      // Zugeh√∂rige Cues l√∂schen
      state.cues = state.cues.filter(c => !((c.typ === 'q' || c.typ === 'v') && c.mediumId === mediumId));
      
      pushUndo();
      state.medien = state.medien.filter(m => m.id !== mediumId);
      if (state.currentlyPlaying === mediumId) state.currentlyPlaying = null;
      saveProjektDaten();
      render();
      updateStorageInfo();
    }

    // ============================================
    // PLACEHOLDER
    // ============================================
    function renderPlaceholder(moduleName) {
      const moduleInfo = {
        requisiten: { icon: 'üé≠', name: 'Requisiten', desc: 'Hier kannst du Requisiten verwalten und ihren Einsatz in Szenen tracken.' },
        medien: { icon: 'üìÅ', name: 'Medien', desc: 'Hier kannst du Bilder, Audio und andere Medien hochladen.' },
      };
      const info = moduleInfo[moduleName] || { icon: 'üöß', name: moduleName, desc: 'Dieses Modul wird entwickelt.' };
      
      return `
        <div class="flex-1 flex items-center justify-center">
          <div class="text-center text-gray-400 max-w-md">
            <div class="text-6xl mb-4">${info.icon}</div>
            <h2 class="text-xl font-semibold text-gray-600 mb-2">${info.name}</h2>
            <p class="mb-4">${info.desc}</p>
            <p class="text-sm">üöß Kommt in der n√§chsten Version</p>
          </div>
        </div>
      `;
    }

    // ============================================
    // MODALS
    // ============================================
    function renderImportModal() {
      const hasApiKey = !!localStorage.getItem('nina_rebu_api_key');
      
      return `
        <div class="modal-overlay" onclick="closeModal('showImportModal')">
          <div class="modal-content" style="max-width: 650px; max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">‚¨áÔ∏è¬è Importieren</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showImportModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <!-- Tab-Navigation -->
              <div class="flex border-b mb-4">
                <button class="import-tab px-4 py-2 border-b-2 border-blue-500 text-blue-600 font-medium" data-tab="word" onclick="showImportTab('word')">
                  üìÑ Word/PDF
                </button>
                <button class="import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="nina" onclick="showImportTab('nina')" style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(20,184,166,0.1)); border-radius: 4px 4px 0 0;">
                  üîÑ Dramera
                </button>
                <button class="import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="dramera" onclick="showImportTab('dramera')">
                  üíæ Backup
                </button>
                <button class="import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="text" onclick="showImportTab('text')">
                  üìù Text
                </button>
                <button class="import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="gdrive" onclick="showImportTab('gdrive')">
                  ‚òÅÔ∏è Drive
                </button>
              </div>
              
              <!-- Word/PDF Tab (NEU - Prim√§r) -->
              <div id="import-tab-word">
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-blue-400 cursor-pointer mb-4"
                     onclick="document.getElementById('import-word-input').click()">
                  <div class="text-4xl mb-2">üìÑ</div>
                  <p class="text-sm text-gray-600" id="import-word-name">Word (.docx) oder PDF ausw√§hlen...</p>
                  <input type="file" id="import-word-input" accept=".docx,.pdf" class="hidden" onchange="handleDocumentFile(this)">
                </div>
                
                <!-- Format-Info -->
                <div id="import-format-info" style="display: none; margin-bottom: 16px; padding: 12px; background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px;">
                  <div style="font-size: 12px; color: #166534; font-weight: 500; margin-bottom: 6px;">üîç Erkannte Formatierungen:</div>
                  <div id="import-format-details" style="font-size: 11px; color: #15803d;"></div>
                </div>
                
                <!-- Preview -->
                <div id="import-word-preview" style="display: none; margin-bottom: 16px;">
                  <div style="font-size: 14px; font-weight: 500; color: #374151; margin-bottom: 8px;">Vorschau:</div>
                  <div id="import-word-preview-text" style="border: 1px solid #e5e7eb; border-radius: 4px; background: #f9fafb; padding: 12px; max-height: 120px; overflow-y: auto; font-size: 11px; font-family: monospace; white-space: pre-wrap; word-break: break-word;"></div>
                </div>
                
                <!-- Status -->
                <div id="import-word-status" style="display: none; margin-bottom: 16px;">
                  <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #2563eb;">
                    <div style="width: 16px; height: 16px; border: 2px solid #2563eb; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    <span id="import-word-status-text">Analysiere...</span>
                  </div>
                </div>
                
                <div class="flex gap-2">
                  <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Abbrechen</button>
                  <button class="btn btn-primary flex-1" id="import-word-btn" onclick="doImportWord()" disabled>üì• Importieren</button>
                </div>
              </div>
              
              <!-- NINA-Exchange Tab (Dramera Import) -->
              <div id="import-tab-nina" style="display: none;">
                <div style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(20,184,166,0.1)); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                  <p style="font-size: 14px; color: #374151; margin-bottom: 8px;">
                    <strong>üîÑ Import aus Dramera Werkbank</strong>
                  </p>
                  <p style="font-size: 12px; color: #6b7280;">
                    Importiere Figuren und Szenen, die du in Dramera entwickelt hast.
                    Die Daten werden in dein aktuelles Projekt √ºbernommen.
                  </p>
                </div>
                
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-purple-400 cursor-pointer mb-4"
                     onclick="document.getElementById('import-nina-input').click()">
                  <div class="text-4xl mb-2">üîÑ</div>
                  <p class="text-sm text-gray-600" id="import-nina-name">NINA-Exchange Datei ausw√§hlen...</p>
                  <p class="text-xs text-gray-400 mt-1">(Projektname_NINA-Exchange_Datum.json)</p>
                  <input type="file" id="import-nina-input" accept=".json" class="hidden" onchange="handleNinaImportFile(this)">
                </div>
                
                <!-- Preview -->
                <div id="import-nina-preview" style="display: none; margin-bottom: 16px; padding: 12px; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px;">
                  <div style="font-size: 12px; font-weight: 600; color: #374151; margin-bottom: 8px;">üìã Gefundene Daten:</div>
                  <div id="import-nina-details" style="font-size: 12px; color: #6b7280;"></div>
                </div>
                
                <div class="flex gap-2">
                  <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Abbrechen</button>
                  <button class="btn flex-1" id="import-nina-btn" onclick="doImportNina()" disabled style="background: linear-gradient(135deg, #8b5cf6, #14b8a6); color: white;">üîÑ Importieren</button>
                </div>
              </div>
              
              <!-- Backup Tab -->
              <div id="import-tab-dramera" style="display: none;">
                <p class="text-sm text-gray-500 mb-4">
                  Importiere ein Projekt-Backup (.json) ‚Äì stellt alle Daten wieder her:
                </p>
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-purple-400 cursor-pointer"
                     onclick="document.getElementById('import-file-input').click()">
                  <div class="text-4xl mb-2">üíæ</div>
                  <p class="text-sm text-gray-600" id="import-file-name">Klicken zum Ausw√§hlen...</p>
                  <input type="file" id="import-file-input" accept=".json" class="hidden" onchange="handleImportFile(this)">
                </div>
                <div class="flex gap-2 mt-4">
                  <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Abbrechen</button>
                  <button class="btn btn-primary flex-1" id="import-btn" onclick="doImportFile()" disabled>Importieren</button>
                </div>
              </div>
              
              <!-- Text Tab -->
              <div id="import-tab-text" style="display: none;">
                <p class="text-sm font-medium text-gray-700 mb-2">Text einf√ºgen oder TXT-Datei hochladen:</p>
                <textarea id="import-text-content" rows="6" placeholder="Text hier einf√ºgen..."></textarea>
                
                <input type="file" id="import-txt-input" accept=".txt,.md" class="text-sm mt-2" onchange="handleTxtImportFile(this)">
                
                <div class="grid grid-cols-2 gap-4 mt-4">
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Szenen-Titel</label>
                    <input type="text" id="import-text-title" value="Importierter Text">
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Szenen-Nummer</label>
                    <input type="text" id="import-text-nummer" value="1.1">
                  </div>
                </div>
                
                <div class="flex gap-2 mt-4">
                  <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Abbrechen</button>
                  <button class="btn btn-primary flex-1" onclick="doImportText()">üì• Importieren</button>
                </div>
              </div>
              
              <!-- Google Drive Tab -->
              <div id="import-tab-gdrive" style="display: none;">
                ${renderGdriveImportTab()}
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // ============================================
    // TEXTMUSTER-ANALYSE v2.0
    // ============================================
    // LOGIK:
    // 1. WORD: Erst Formatvorlagen pr√ºfen ‚Üí wenn nicht vorhanden ‚Üí Analyse
    // 2. PDF: Direkt Analyse
    // 3. ANALYSE: Figurenliste ZUERST ‚Üí dann mit bekannten Namen Dialoge finden!
    // ============================================
    
    // Muster f√ºr Figurenliste-Header
    const FIGURENLISTE_HEADER = [
      /^(Personen|Figuren|Rollen|Besetzung|Dramatis\s+Personae):?\s*$/im,
      /^PERSONNAGES:?\s*$/im,
      /^Characters?:?\s*$/im,
      /^Cast(\s+of\s+Characters)?:?\s*$/im,
      /^Mitwirkende:?\s*$/im,
      /^Die\s+Auswanderer:/im  // Gruppierte Figuren
    ];
    
    // Muster f√ºr Struktur-Erkennung
    const STRUKTUR_PATTERNS = {
      akt: [
        /^(\d+)\.\s*Akt\b/im,
        /^(Erster?|Zweiter?|Dritter?|Vierter?|F√ºnfter?)\s+Akt\b/im,
        /^Akt\s+(\d+|[IVX]+)\b/im,
        /^([IVX]+)\.\s*Akt\b/im,
        /^(Prolog|Epilog|Vorspiel|Nachspiel)\b/im,
        /^(Erster?|Zweiter?|Dritter?)\s+Aufzug\b/im,
        /^(\d+)\.\s*Aufzug\b/im,
        /^Act\s+(\d+|[IVX]+|One|Two|Three)\b/im,
        /^Acte\s+(\d+|[IVX]+|Premier|Deuxi√®me)\b/im
      ],
      szene: [
        /^(\d+)\.\s*Szene\b/im,
        /^Szene\s+(\d+)\b/im,
        /^(Erste?|Zweite?|Dritte?)\s+Szene\b/im,
        /^(\d+)\.\s*Szene\s*[-‚Äì‚Äî/:]\s*(.+)/im,
        /^(Erster?|Zweiter?|Dritter?)\s+Auftritt\b/im,
        /^(\d+)\.\s*Auftritt\b/im,
        /^Scene\s+(\d+)\b/im,
        /^Sc√®ne\s+(\d+)\b/im
      ],
      bild: [
        /^(\d+)\.\s*$/m,           // Nur "1." auf eigener Zeile
        /^Bild\s+(\d+)\b/im,
        /^(\d+)\.\s*Bild\b/im,
        /^([A-Z])\.\s*$/m          // "A." "B." f√ºr Monologe
      ],
      nummeriert: [
        /^(\d+)\.(\d+)\.\s*$/m,    // "1.1." "2.3."
        /^(\d+)\.(\d+)\s+/m        // "1.1 Titel"
      ]
    };
    
    /**
     * SCHRITT 1: FIGURENLISTE aus Text extrahieren
     * Das ist der WICHTIGSTE Schritt - mit bekannten Figuren k√∂nnen Dialoge pr√§ziser erkannt werden!
     */
    function extractFigurenlisteFromText(text) {
      const lines = text.split('\n');
      const figuren = [];
      let inFigurenliste = false;
      let leerzeileNachHeader = false;
      
      for (let i = 0; i < Math.min(lines.length, 120); i++) {
        const line = lines[i].trim();
        
        // Figurenliste-Header gefunden?
        if (!inFigurenliste) {
          if (FIGURENLISTE_HEADER.some(p => p.test(line))) {
            inFigurenliste = true;
            // Pr√ºfe ob gruppierte Figuren im Header selbst
            const gruppiert = line.match(/^(.+?):\s*([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s,]+)$/);
            if (gruppiert && gruppiert[2].includes(',')) {
              const gruppe = gruppiert[1].trim();
              gruppiert[2].split(/,\s*/).forEach(name => {
                if (name.trim().length > 1) {
                  figuren.push({ name: name.trim(), beschreibung: gruppe });
                }
              });
            }
            continue;
          }
        }
        
        // In Figurenliste - Namen extrahieren
        if (inFigurenliste) {
          // Leere Zeile √ºberspringen
          if (!line) {
            leerzeileNachHeader = true;
            continue;
          }
          
          // Ende der Figurenliste erkennen
          if (/^(Ort|Zeit|Handlung|Synopsis|Schauplatz)/i.test(line)) break;
          if (/^(1\.|Erster|ERSTER|Prolog|I\.\s*Akt)/i.test(line)) break;
          if (STRUKTUR_PATTERNS.akt.some(p => p.test(line))) break;
          if (STRUKTUR_PATTERNS.szene.some(p => p.test(line))) break;
          if (STRUKTUR_PATTERNS.bild.some(p => p.test(line))) break;
          
          // Figur mit Beschreibung: "NAME - Beschreibung" oder "NAME, Beschreibung"
          const mitBeschreibung = line.match(/^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]{1,30}?)\s*[-‚Äì‚Äî,]\s*(.+)$/);
          if (mitBeschreibung) {
            figuren.push({
              name: mitBeschreibung[1].trim(),
              beschreibung: mitBeschreibung[2].trim()
            });
            continue;
          }
          
          // Gruppierte Figuren: "Die Bauern: Hans, Fritz, Karl"
          const gruppiert = line.match(/^(.+?):\s*([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s,]+)$/);
          if (gruppiert && !gruppiert[1].match(/^(Personen|Figuren|Rollen|Ort|Zeit)/i)) {
            const gruppe = gruppiert[1].trim();
            gruppiert[2].split(/,\s*/).forEach(name => {
              if (name.trim().length > 1) {
                figuren.push({ name: name.trim(), beschreibung: gruppe });
              }
            });
            continue;
          }
          
          // Einfacher Name (GROSSBUCHSTABEN)
          if (/^[A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√ú\s]{1,25}$/.test(line)) {
            figuren.push({ name: line, beschreibung: '' });
            continue;
          }
          
          // Name mit gemischter Schreibweise (ohne Sonderzeichen am Ende)
          if (/^[A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]{2,30}$/.test(line) && 
              !line.includes(':') && !line.includes('¬©')) {
            figuren.push({ name: line, beschreibung: '' });
          }
        }
      }
      
      // Wenn Figurenliste gefunden wurde, gib sie zur√ºck
      if (figuren.length > 0) {
        console.log('‚úì Figurenliste gefunden:', figuren.length, 'Figuren:', figuren.map(f => f.name).join(', '));
        return figuren;
      }
      
      // FALLBACK: Figuren aus Dialogen extrahieren (weniger pr√§zise)
      console.log('‚ö† Keine Figurenliste gefunden, extrahiere aus Dialogen...');
      return extractFigurenFromDialoge(text);
    }
    
    /**
     * Fallback: Figuren aus Dialog-Mustern extrahieren
     */
    function extractFigurenFromDialoge(text) {
      const figurenSet = new Set();
      const lines = text.split('\n');
      
      const dialogPatterns = [
        /^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√ú\s]{1,20}):\s/m,      // NAME:
        /^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√ú\s]{1,20})\.\s+[A-Z]/m, // NAME. Text
        /^([A-Z√Ñ√ñ√ú]{2,15})\s*$/m,                 // NAME (eigene Zeile)
        /^(CHOR|ALLE|MEHRERE|ERZ√ÑHLER|NARRATOR)[:\.]/im
      ];
      
      for (const line of lines) {
        for (const pattern of dialogPatterns) {
          const match = line.match(pattern);
          if (match && match[1]) {
            const name = match[1].trim();
            if (name.length >= 2 && name.length <= 25) {
              figurenSet.add(name);
            }
            break;
          }
        }
      }
      
      console.log('  Aus Dialogen erkannt:', figurenSet.size, 'Figuren');
      return Array.from(figurenSet).map(name => ({ name, beschreibung: '' }));
    }
    
    /**
     * SCHRITT 2: Mit bekannten Figurennamen DIALOGE erkennen
     * Viel pr√§ziser als blind nach Mustern zu suchen!
     */
    function findDialogeWithKnownFiguren(text, figurenNamen) {
      const dialoge = [];
      const lines = text.split('\n');
      
      // Pattern aus bekannten Figuren bauen (pr√§zise!)
      const figurenPattern = figurenNamen.length > 0 
        ? new RegExp(`^(${figurenNamen.map(n => escapeRegex(n)).join('|')})\\s*[:\\.)]`, 'im')
        : null;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Mit bekannten Figuren pr√ºfen (pr√§ziser!)
        if (figurenPattern) {
          const match = line.match(figurenPattern);
          if (match) {
            dialoge.push({ lineIndex: i, figur: match[1].trim(), line: line });
          }
        }
      }
      
      return dialoge;
    }
    
    // Hilfsfunktion f√ºr Regex-Escape
    function escapeRegex(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    /**
     * SCHRITT 3: Strukturtyp erkennen
     */
    function detectStrukturTyp(text) {
      const lines = text.split('\n').slice(0, 200);
      let scores = { akte: 0, bilder: 0, nummeriert: 0, keine: 0 };
      
      for (const line of lines) {
        const t = line.trim();
        if (STRUKTUR_PATTERNS.akt.some(p => p.test(t))) scores.akte += 3;
        if (STRUKTUR_PATTERNS.szene.some(p => p.test(t))) scores.akte += 2;
        if (STRUKTUR_PATTERNS.bild.some(p => p.test(t))) scores.bilder += 2;
        if (STRUKTUR_PATTERNS.nummeriert.some(p => p.test(t))) scores.nummeriert += 2;
      }
      
      const maxScore = Math.max(...Object.values(scores));
      if (maxScore < 2) return 'keine';
      
      for (const [typ, score] of Object.entries(scores)) {
        if (score === maxScore) return typ;
      }
      return 'akte';
    }
    
    /**
     * SCHRITT 4: Szenen-Grenzen finden
     */
    function findSzenenGrenzen(text, strukturTyp) {
      const lines = text.split('\n');
      const grenzen = [];
      let patterns = [...STRUKTUR_PATTERNS.akt, ...STRUKTUR_PATTERNS.szene];
      
      if (strukturTyp === 'bilder') patterns = [...STRUKTUR_PATTERNS.bild, ...STRUKTUR_PATTERNS.akt];
      if (strukturTyp === 'nummeriert') patterns = [...STRUKTUR_PATTERNS.nummeriert, ...STRUKTUR_PATTERNS.akt];
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        for (const pattern of patterns) {
          if (pattern.test(line)) {
            grenzen.push({
              lineIndex: i,
              text: line,
              isAkt: STRUKTUR_PATTERNS.akt.some(p => p.test(line))
            });
            break;
          }
        }
      }
      return grenzen;
    }
    
    /**
     * SCHRITT 5: Metadaten extrahieren (Titel, Autor, Gattung)
     */
    function extractMetadatenFromText(text) {
      const lines = text.split('\n').slice(0, 80);
      const meta = { titel: '', untertitel: '', autor: '', copyright: '', gattung: '' };
      
      const AUTOR_PATTERNS = [
        /^von\s+([A-Z√Ñ√ñ√úa-z√§√∂√º][\w√§√∂√º√Ñ√ñ√ú√ü\s\.\-]+)$/im,
        /^Autor:?\s*(.+)$/im,
        /^Une\s+pi√®ce\s+de\s+(.+)$/im,
        /^Deutsch\s+von\s+(.+)$/im,
        /^By:?\s+(.+)$/im
      ];
      
      const GATTUNG_PATTERNS = [
        /^(Ein|Eine)\s+(Kom√∂die|Trag√∂die|Drama|Schauspiel|Lustspiel|Musical|Oper|Singspiel)/i,
        /^(Komische\s+)?Oper\s+in\s+.+\s+Akten/i,
        /^(Eine\s+)?(musikalische\s+)?(Chronik|Revue|Kom√∂die|Farce)/i,
        /in\s+(\d+|zwei|drei|vier|f√ºnf)\s+(Akten|Bildern|Szenen|Aufz√ºgen)/i
      ];
      
      for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        
        // Autor
        for (const p of AUTOR_PATTERNS) {
          const m = t.match(p);
          if (m && !meta.autor) { meta.autor = m[1].trim(); break; }
        }
        
        // Gattung
        for (const p of GATTUNG_PATTERNS) {
          if (p.test(t) && !meta.gattung) { meta.gattung = t; meta.untertitel = t; break; }
        }
        
        // Copyright
        if (/¬©|Copyright|Alle Rechte/i.test(t) && !meta.copyright) {
          meta.copyright = t;
        }
        
        // Titel (erste substantielle Zeile die kein Autor/Copyright ist)
        if (!meta.titel && t.length >= 3 && t.length <= 80 &&
            !AUTOR_PATTERNS.some(p => p.test(t)) &&
            !GATTUNG_PATTERNS.some(p => p.test(t)) &&
            !/^(¬©|Alle Rechte|Copyright|\d+$)/i.test(t)) {
          meta.titel = t;
        }
      }
      
      return meta;
    }
    
    // Word-Import Variablen
    let importedWordData = null;
    
    // NINA-Exchange Import Variablen
    let ninaImportData = null;
    
    function showImportTab(tab) {
      // Alle Tabs ausblenden
      document.getElementById('import-tab-word').style.display = tab === 'word' ? 'block' : 'none';
      document.getElementById('import-tab-nina').style.display = tab === 'nina' ? 'block' : 'none';
      document.getElementById('import-tab-dramera').style.display = tab === 'dramera' ? 'block' : 'none';
      document.getElementById('import-tab-text').style.display = tab === 'text' ? 'block' : 'none';
      const gdriveTab = document.getElementById('import-tab-gdrive');
      if (gdriveTab) gdriveTab.style.display = tab === 'gdrive' ? 'block' : 'none';
      
      // Bei Drive-Tab: Dateien laden wenn verbunden
      if (tab === 'gdrive' && gdriveIsConnected() && gdriveFolderId && gdriveImportFiles.length === 0) {
        gdriveRefreshFiles();
      }
      
      // Tab-Buttons aktualisieren
      document.querySelectorAll('.import-tab').forEach(btn => {
        if (btn.dataset.tab === tab) {
          btn.className = 'import-tab px-4 py-2 border-b-2 border-blue-500 text-blue-600 font-medium';
        } else {
          btn.className = 'import-tab px-4 py-2 border-b-2 border-transparent text-gray-500 hover:text-gray-700';
        }
      });
    }
    
    // NINA-Exchange Import Handler
    function handleNinaImportFile(input) {
      const file = input.files[0];
      if (!file) return;
      
      document.getElementById('import-nina-name').textContent = '‚è≥ Lese ' + file.name + '...';
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          
          // Pr√ºfen ob es ein NINA-Exchange Format ist
          if (data.format !== 'nina-exchange') {
            alert('‚ùå Diese Datei ist kein NINA-Exchange Format.\n\nBitte exportiere das Projekt zuerst aus Dramera mit "F√ºr Rebu/Propla" Export.');
            document.getElementById('import-nina-name').textContent = 'NINA-Exchange Datei ausw√§hlen...';
            return;
          }
          
          ninaImportData = data;
          
          // Preview anzeigen
          document.getElementById('import-nina-name').textContent = '‚úÖ ' + file.name;
          
          const preview = document.getElementById('import-nina-preview');
          const details = document.getElementById('import-nina-details');
          
          let html = [];
          html.push('<div style="margin-bottom: 8px;"><strong>üìÅ Projekt:</strong> ' + escapeHtml(data.project?.name || 'Unbenannt') + '</div>');
          
          if (data.figures?.length) {
            html.push('<div style="margin-bottom: 4px;">üë§ <strong>' + data.figures.length + ' Figuren:</strong> ');
            html.push(data.figures.slice(0, 5).map(f => escapeHtml(f.name)).join(', '));
            if (data.figures.length > 5) html.push(' ...');
            html.push('</div>');
          }
          
          if (data.scenes?.length) {
            html.push('<div style="margin-bottom: 4px;">üé¨ <strong>' + data.scenes.length + ' Szenen:</strong> ');
            html.push(data.scenes.slice(0, 3).map(s => escapeHtml(s.name)).join(', '));
            if (data.scenes.length > 3) html.push(' ...');
            html.push('</div>');
          }
          
          if (data.themes?.length) {
            html.push('<div>üí° <strong>' + data.themes.length + ' Themen</strong></div>');
          }
          
          html.push('<div style="margin-top: 8px; font-size: 11px; color: #9ca3af;">Exportiert: ' + new Date(data.exportedAt).toLocaleString('de-CH') + '</div>');
          
          details.innerHTML = html.join('');
          preview.style.display = 'block';
          
          document.getElementById('import-nina-btn').disabled = false;
          
        } catch (err) {
          console.error('NINA Import Fehler:', err);
          alert('‚ùå Fehler beim Lesen der Datei: ' + err.message);
          document.getElementById('import-nina-name').textContent = 'NINA-Exchange Datei ausw√§hlen...';
        }
      };
      reader.readAsText(file);
    }
    
    // ============================================
    // NINA-EXCHANGE IMPORT v2.0
    // Vollst√§ndiger Import inkl. Texte!
    // ============================================
    async function doImportNina() {
      if (!ninaImportData) return;
      
      const data = ninaImportData;
      const projektId = state.projektId;
      
      if (!projektId) {
        alert('‚ùå Bitte zuerst ein Projekt √∂ffnen oder erstellen!');
        return;
      }
      
      try {
        // === PROJEKT-METADATEN IMPORTIEREN ===
        if (data.project) {
          const p = data.project;
          state.projektMeta = {
            ...state.projektMeta,
            titel: p.name || state.projektMeta.titel,
            untertitel: p.subtitle || state.projektMeta.untertitel || '',
            autor: p.author || state.projektMeta.autor || '',
            regie: p.director || state.projektMeta.regie || '',
            tagline: p.tagline || state.projektMeta.tagline || '',
            logline: p.logline || p.description || state.projektMeta.logline || '',
            copyright: p.copyright || state.projektMeta.copyright || '',
            titelbild: p.cover_image || state.projektMeta.titelbild || '',
            premiere: p.premiere_date || state.projektMeta.premiere || '',
            spielort: p.venue || state.projektMeta.spielort || '',
            fassung: p.version_name || state.projektMeta.fassung || 'Arbeitsfassung',
            fassungsDatum: p.version_date || state.projektMeta.fassungsDatum || '',
            strukturTyp: p.structure_type || state.projektMeta.strukturTyp || 'akte'
          };
          save(KEYS.projektMeta(projektId), state.projektMeta);
        }
        
        // Bestehende Daten laden
        const existingFiguren = load(KEYS.figuren(projektId), []);
        const existingFigurenNames = existingFiguren.map(f => f.name.toLowerCase());
        const existingSzenen = load(KEYS.szenen(projektId), []);
        const existingSzenenNames = existingSzenen.map(s => (s.titel || s.name || '').toLowerCase());
        const existingTextbuch = load(KEYS.textbuch(projektId), {});
        
        let importedFiguren = 0;
        let importedSzenen = 0;
        let importedTexte = 0;
        let skippedFiguren = 0;
        let skippedSzenen = 0;
        
        // === FIGUREN IMPORTIEREN (v2.0 Felder) ===
        const newFiguren = [...existingFiguren];
        const figurenIdMap = {};
        
        for (const fig of (data.figures || [])) {
          if (existingFigurenNames.includes(fig.name.toLowerCase())) {
            skippedFiguren++;
            const existing = existingFiguren.find(f => f.name.toLowerCase() === fig.name.toLowerCase());
            if (existing) figurenIdMap[fig.id] = existing.id;
            continue;
          }
          
          const newId = genId();
          figurenIdMap[fig.id] = newId;
          
          newFiguren.push({
            id: newId,
            name: fig.name,
            kuerzel: fig.short_name || fig.abbreviation || fig.name.substring(0, 3).toUpperCase(),
            beschreibung: fig.description || fig.biography || '',
            farbe: fig.color || '#3b82f6',
            typ: fig.figure_type || 'main',
            // v2.0 Dramaturgie-Felder
            want: fig.want_external || fig.want || '',
            wantInternal: fig.want_internal || '',
            need: fig.need || '',
            ghost: fig.ghost || '',
            biografie: fig.biography || fig.description || '',
            schwaeche: fig.weakness || '',
            staerke: fig.strength || '',
            charakteristik: fig.characteristic || '',
            archetyp: fig.archetype || '',
            beruf: fig.profession || '',
            ziel: fig.goal || '',
            hindernis: fig.obstacle || '',
            konflikt: fig.conflict || '',
            entwicklung: fig.development || ''
          });
          importedFiguren++;
        }
        
        save(KEYS.figuren(projektId), newFiguren);
        // === SZENEN IMPORTIEREN (inkl. TEXT!) ===
        const newSzenen = [...existingSzenen];
        const newTextbuch = { ...existingTextbuch };
        const szenenIdMap = {};
        
        for (const scene of (data.scenes || [])) {
          if (existingSzenenNames.includes((scene.name || '').toLowerCase())) {
            skippedSzenen++;
            // Aber Text trotzdem importieren wenn vorhanden!
            const existing = existingSzenen.find(s => (s.titel || s.name || '').toLowerCase() === (scene.name || '').toLowerCase());
            if (existing && scene.content && !newTextbuch[existing.id]) {
              newTextbuch[existing.id] = scene.content;
              importedTexte++;
            }
            if (existing) szenenIdMap[scene.id] = existing.id;
            continue;
          }
          
          const newId = genId();
          szenenIdMap[scene.id] = newId;
          
          // Figuren-IDs mappen
          let figurenIds = [];
          if (scene.figures && Array.isArray(scene.figures)) {
            figurenIds = scene.figures.map(fId => {
              if (figurenIdMap[fId]) return figurenIdMap[fId];
              const foundFig = newFiguren.find(f => f.name === fId || f.id === fId);
              return foundFig?.id || fId;
            }).filter(Boolean);
          }
          
          newSzenen.push({
            id: newId,
            nummer: scene.number || String(newSzenen.length + 1),
            titel: scene.name,
            name: scene.name,
            ort: scene.location || '',
            zeit: scene.time || '',
            zusammenfassung: scene.summary || scene.description || '',
            gruppe: scene.act || scene.group || '',
            figuren: figurenIds,
            dauer: scene.estimated_duration || null
          });
          
          // ‚úÖ KRITISCH: Szenentext ins Textbuch importieren!
          if (scene.content) {
            newTextbuch[newId] = scene.content;
            importedTexte++;
          }
          
          importedSzenen++;
        }
        
        save(KEYS.szenen(projektId), newSzenen);
        save(KEYS.textbuch(projektId), newTextbuch);
        
        // === CUES IMPORTIEREN ===
        let importedCues = 0;
        if (data.cues && data.cues.length > 0) {
          const existingCues = load(KEYS.cues(projektId), []);
          const newCues = [...existingCues];
          
          for (const cue of data.cues) {
            const szeneId = szenenIdMap[cue.scene_id] || cue.scene_id;
            newCues.push({
              id: genId(),
              szeneId: szeneId,
              typ: cue.cue_type || cue.type || 'lx',
              nummer: cue.cue_number || cue.number || newCues.length + 1,
              beschreibung: cue.description || '',
              ankerText: cue.anchor_text || '',
              dauer: cue.duration || ''
            });
            importedCues++;
          }
          
          save(KEYS.cues(projektId), newCues);
          state.cues = newCues;
        }
        
        // === KONZEPT IMPORTIEREN ===
        let importedKonzept = false;
        if (data.konzept) {
          const k = data.konzept;
          const existingKonzept = load(KEYS.konzept(projektId), {
            treatment: [], fundament: { kern: '', logline: '', unaussprechliches: '', emotionalerBogen: '', konflikt: '' },
            werte: [], motive: []
          });
          
          // Treatment
          if (k.treatment) {
            if (typeof k.treatment === 'string' && k.treatment) {
              existingKonzept.treatment = [{ id: genId(), titel: 'Treatment', text: k.treatment, sortOrder: 0 }];
            } else if (Array.isArray(k.treatment) && k.treatment.length > 0) {
              existingKonzept.treatment = k.treatment;
            }
          }
          
          // Fundament
          if (k.fundament) {
            existingKonzept.fundament = {
              kern: k.fundament.kern || existingKonzept.fundament.kern || '',
              logline: k.fundament.logline || existingKonzept.fundament.logline || '',
              unaussprechliches: k.fundament.unaussprechliches || existingKonzept.fundament.unaussprechliches || '',
              emotionalerBogen: k.fundament.emotionaler_bogen || k.fundament.emotionalerBogen || existingKonzept.fundament.emotionalerBogen || '',
              konflikt: k.fundament.konflikt || existingKonzept.fundament.konflikt || ''
            };
          }
          
          // Werte (Wertequadrate)
          if (k.werte && k.werte.length > 0) {
            existingKonzept.werte = k.werte.map(w => ({
              id: w.id || genId(),
              wert1: w.virtue_a || w.wert1 || '',
              wert2: w.virtue_b || w.wert2 || '',
              wert3: w.excess_a || w.exaggeration_a || w.wert3 || '',
              wert4: w.excess_b || w.exaggeration_b || w.wert4 || '',
              figurIds: w.zuordnung ? Object.keys(w.zuordnung).map(fId => figurenIdMap[fId] || fId) : (w.figurIds || [])
            }));
          }
          
          // Motive
          if (k.motive && k.motive.length > 0) {
            existingKonzept.motive = k.motive.map(m => ({
              id: m.id || genId(),
              name: m.text || m.name || '',
              bedeutung: m.beschreibung || m.bedeutung || '',
              betrachtungen: m.betrachtungen || ''
            }));
          }
          
          state.konzept = existingKonzept;
          save(KEYS.konzept(projektId), state.konzept);
          importedKonzept = true;
        }
        
        // === THEMES ‚Üí KONZEPT.MOTIVE (falls kein konzept.motive vorhanden) ===
        let importedThemes = 0;
        if (data.themes && data.themes.length > 0 && (!state.konzept.motive || state.konzept.motive.length === 0)) {
          state.konzept.motive = data.themes.map(t => ({
            id: t.id || genId(),
            name: t.text || t.name || '',
            bedeutung: t.beschreibung || '',
            betrachtungen: ''
          }));
          save(KEYS.konzept(projektId), state.konzept);
          importedThemes = data.themes.length;
        }
        
        // === RECHERCHE ‚Üí RECHERCHEMATERIAL ===
        let importedRecherche = 0;
        if (data.recherche && data.recherche.length > 0) {
          const existingRecherche = load(KEYS.rechercheMaterial(projektId), []);
          const newRecherche = [...existingRecherche];
          
          for (const r of data.recherche) {
            newRecherche.push({
              id: r.id || genId(),
              typ: r.kategorie === 'Bild' ? 'bild' : (r.url ? 'link' : 'text'),
              titel: r.titel || r.title || 'Material',
              inhalt: r.text || r.inhalt || '',
              url: r.url || r.quelle || '',
              bildData: r.bildData || r.image_data || '',
              szeneIds: r.szeneIds || [],
              tags: r.tags || (r.kategorie ? [r.kategorie] : [])
            });
            importedRecherche++;
          }
          
          state.rechercheMaterial = newRecherche;
          save(KEYS.rechercheMaterial(projektId), state.rechercheMaterial);
        }
        
        // === MUSIKKONZEPT ===
        let importedMusik = false;
        if (data.musikkonzept) {
          const mk = data.musikkonzept;
          state.musikkonzept = {
            text: mk.konzept_text || mk.text || '',
            stuecke: (mk.stueckliste || mk.stuecke || []).map(s => ({
              id: s.id || genId(),
              titel: s.titel || '',
              kuenstler: s.kuenstler || '',
              szeneIds: s.szeneIds || [],
              einsatz: s.einsatz || '',
              notizen: s.notizen || ''
            }))
          };
          save(KEYS.musikkonzept(projektId), state.musikkonzept);
          importedMusik = (state.musikkonzept.text || state.musikkonzept.stuecke.length > 0);
        }
        
        // === BEZIEHUNGEN ===
        let importedBeziehungen = 0;
        if (data.beziehungen && data.beziehungen.length > 0) {
          const existingBez = load(KEYS.beziehungen(projektId), []);
          const newBez = [...existingBez];
          
          for (const b of data.beziehungen) {
            const figur1 = figurenIdMap[b.figure_a] || b.figure_a || b.figur1Id;
            const figur2 = figurenIdMap[b.figure_b] || b.figure_b || b.figur2Id;
            
            // Duplikate vermeiden
            const exists = newBez.some(eb => 
              (eb.figur1Id === figur1 && eb.figur2Id === figur2) ||
              (eb.figur1Id === figur2 && eb.figur2Id === figur1)
            );
            
            if (!exists && figur1 && figur2) {
              newBez.push({
                id: b.id || genId(),
                figur1Id: figur1,
                figur2Id: figur2,
                art: b.type || b.art || '',
                beschreibung: b.description || b.beschreibung || '',
                richtung: b.richtung || 'beidseiting'
              });
              importedBeziehungen++;
            }
          }
          
          state.beziehungen = newBez;
          save(KEYS.beziehungen(projektId), state.beziehungen);
        }
        
        // === ENSEMBLE (aus persons mit category=ensemble) ===
        let importedEnsemble = 0;
        const ensemblePersons = (data.persons || []).filter(p => p.category === 'ensemble' || !p.category);
        if (ensemblePersons.length > 0) {
          const existingEnsemble = load(KEYS.ensemble(projektId), []);
          const newEnsemble = [...existingEnsemble];
          const personIdMap = {};
          
          for (const person of ensemblePersons) {
            const name = (person.name || '').toLowerCase();
            const existing = newEnsemble.find(e => (e.name || '').toLowerCase() === name);
            if (existing) { personIdMap[person.id] = existing.id; continue; }
            
            const newId = genId();
            personIdMap[person.id] = newId;
            
            // Rollen-IDs ermitteln via Castings
            const rolleIds = (data.castings || [])
              .filter(c => c.person_id === person.id)
              .map(c => figurenIdMap[c.figure_id] || c.figure_id)
              .filter(Boolean);
            
            const addr = person.address || {};
            const adresse = [addr.street, addr.number, addr.zip, addr.city].filter(Boolean).join(' ');
            
            newEnsemble.push({
              id: newId,
              name: person.name || '',
              email: person.email || '',
              telefon: person.phone || person.telefon || '',
              adresse: adresse,
              rolleIds: rolleIds,
              notizen: person.notes || ''
            });
            importedEnsemble++;
          }
          
          state.ensemble = newEnsemble;
          save(KEYS.ensemble(projektId), state.ensemble);
        }
        
        // === K√úNSTLERISCHES TEAM (aus persons mit category=artistic_team) ===
        let importedTeam = 0;
        const teamPersons = (data.persons || []).filter(p => p.category === 'artistic_team');
        if (teamPersons.length > 0) {
          const existingTeam = load(KEYS.team(projektId), []);
          const newTeam = [...existingTeam];
          
          for (const person of teamPersons) {
            const name = (person.name || '').toLowerCase();
            const existing = newTeam.find(t => (t.name || '').toLowerCase() === name);
            if (existing) continue;
            
            newTeam.push({
              id: genId(),
              name: person.name || '',
              funktion: person.function || person.role || '',
              email: person.email || '',
              telefon: person.phone || person.telefon || '',
              notizen: person.notes || ''
            });
            importedTeam++;
          }
          
          state.team = newTeam;
          save(KEYS.team(projektId), state.team);
        }
        
        // === PROBEPLAN (aus rehearsals) ===
        let importedProben = 0;
        if (data.rehearsals && data.rehearsals.length > 0) {
          const existingProben = load(KEYS.probeplan(projektId), []);
          const newProben = [...existingProben];
          
          for (const r of data.rehearsals) {
            // Duplikat-Check: gleiches Datum + gleiche Zeit
            const exists = newProben.some(p => p.datum === r.date && p.zeit === (r.start_time + '‚Äì' + r.end_time));
            if (exists) continue;
            
            newProben.push({
              id: genId(),
              datum: r.date || '',
              zeit: (r.start_time || '') + (r.end_time ? '‚Äì' + r.end_time : ''),
              ort: r.location || '',
              typ: r.rehearsal_type || '',
              szeneIds: (r.scene_ids || []).map(sid => szenenIdMap[sid] || sid),
              figurIds: [],
              notizen: r.notes || ''
            });
            importedProben++;
          }
          
          state.probeplan = newProben;
          save(KEYS.probeplan(projektId), state.probeplan);
        }
        
        // State aktualisieren
        state.figuren = newFiguren;
        state.szenen = newSzenen;
        state.textbuch = newTextbuch;
        
        // Cloud-Sync wenn aktiv
        if (isCloudMode && currentCloudProjectId) {
          // Projekt-Meta in Cloud
          await db.from('projects').update({
            name: state.projektMeta.titel,
            author: state.projektMeta.autor,
            subtitle: state.projektMeta.untertitel,
            tagline: state.projektMeta.tagline,
            logline: state.projektMeta.logline,
            premiere_date: state.projektMeta.premiere || null,
            venue: state.projektMeta.spielort
          }).eq('id', currentCloudProjectId);
          
          // Neue Figuren in Cloud
          for (const fig of newFiguren) {
            if (!existingFiguren.find(ef => ef.id === fig.id)) {
              await db.from('figures').upsert({
                id: fig.id,
                project_id: currentCloudProjectId,
                name: fig.name,
                abbreviation: fig.kuerzel,
                description: fig.beschreibung,
                color: fig.farbe,
                figure_type: fig.typ,
                want: fig.want,
                need: fig.need
              });
            }
          }
          
          // Neue Szenen in Cloud (inkl. Text!)
          for (const sz of newSzenen) {
            if (!existingSzenen.find(es => es.id === sz.id)) {
              await db.from('scenes').upsert({
                id: sz.id,
                project_id: currentCloudProjectId,
                number: sz.nummer,
                name: sz.titel || sz.name,
                title: sz.titel,
                description: sz.zusammenfassung,
                location: sz.ort,
                time_of_day: sz.zeit,
                scene_group: sz.gruppe
              });
              
              // ‚úÖ Szenentext in Cloud speichern!
              if (newTextbuch[sz.id]) {
                await db.from('scene_texts').upsert({
                  scene_id: sz.id,
                  project_id: currentCloudProjectId,
                  content: newTextbuch[sz.id]
                });
              }
            }
          }
        }
        
        closeModal('showImportModal');
        render();
        
        // Erfolgsmeldung
        let msg = '‚úÖ NINA-Exchange Import erfolgreich!\n\n';
        msg += 'üë§ Figuren: ' + importedFiguren + ' neu';
        if (skippedFiguren > 0) msg += ', ' + skippedFiguren + ' √ºbersprungen';
        msg += '\nüé¨ Szenen: ' + importedSzenen + ' neu';
        if (skippedSzenen > 0) msg += ', ' + skippedSzenen + ' √ºbersprungen';
        msg += '\nüìù Texte: ' + importedTexte + ' importiert';
        if (importedCues > 0) msg += '\nüéõÔ∏è Cues: ' + importedCues + ' importiert';
        if (importedKonzept) msg += '\nüéØ Konzept importiert';
        if (importedThemes > 0) msg += '\nüè∑Ô∏è Themen: ' + importedThemes + ' als Motive';
        if (importedRecherche > 0) msg += '\nüìö Recherche: ' + importedRecherche + ' Eintr√§ge';
        if (importedMusik) msg += '\nüéµ Musikkonzept importiert';
        if (importedBeziehungen > 0) msg += '\nüîó Beziehungen: ' + importedBeziehungen + ' importiert';
        if (importedEnsemble > 0) msg += '\nüé≠ Ensemble: ' + importedEnsemble + ' Mitglieder';
        if (importedTeam > 0) msg += '\nüé® K√ºnstl. Team: ' + importedTeam + ' Mitglieder';
        if (importedProben > 0) msg += '\nüìÖ Probeplan: ' + importedProben + ' Termine';
        
        if (state.projektMeta.autor) {
          msg += '\n\n‚úçÔ∏è Autor: ' + state.projektMeta.autor;
        }
        
        if (isCloudMode) {
          msg += '\n\n‚òÅÔ∏è Daten wurden in die Cloud synchronisiert.';
        }
        
        alert(msg);
        
        ninaImportData = null;
        
      } catch (err) {
        console.error('NINA Import Fehler:', err);
        alert('‚ùå Import fehlgeschlagen: ' + err.message);
      }
    }
    
    // Neue universelle Dokumenten-Handler-Funktion
    async function handleDocumentFile(input) {
      const file = input.files[0];
      if (!file) return;
      
      const fileName = file.name.toLowerCase();
      const isPDF = fileName.endsWith('.pdf');
      const isWord = fileName.endsWith('.docx');
      
      document.getElementById('import-word-name').textContent = '‚è≥ ' + file.name + ' wird gelesen...';
      document.getElementById('import-format-info').style.display = 'none';
      
      try {
        let result;
        
        if (isPDF) {
          result = await extractPDFContent(file);
        } else if (isWord) {
          result = await extractWordContent(file);
        } else {
          throw new Error('Nicht unterst√ºtztes Format. Bitte .docx oder .pdf verwenden.');
        }
        
        importedWordData = {
          html: result.html,
          text: result.text,
          richText: result.richText, // Text mit Formatierungsmarkern
          formatInfo: result.formatInfo,
          fileName: file.name,
          fileType: isPDF ? 'pdf' : 'word'
        };
        
        // UI aktualisieren
        document.getElementById('import-word-name').textContent = '‚úÖ ' + file.name;
        
        // Format-Info anzeigen
        if (result.formatInfo && Object.keys(result.formatInfo).length > 0) {
          const formatDetails = document.getElementById('import-format-details');
          let infoHtml = [];
          
          // Echte Formatvorlagen (h√∂chste Priorit√§t)
          if (result.hasRealStyles) {
            infoHtml.push('<strong style="color: #059669;">‚úì Echte Formatvorlagen erkannt!</strong>');
            if (result.formatInfo.stuecktitelCount > 0) infoHtml.push(`üìñ ${result.formatInfo.stuecktitelCount}x St√ºcktitel`);
            if (result.formatInfo.aktCount > 0) infoHtml.push(`üé≠ ${result.formatInfo.aktCount}x Akt`);
            if (result.formatInfo.szeneCount > 0) infoHtml.push(`üé¨ ${result.formatInfo.szeneCount}x Szene`);
            if (result.formatInfo.dialogCount > 0) infoHtml.push(`üí¨ ${result.formatInfo.dialogCount}x Dialog`);
            if (result.formatInfo.regieCount > 0) infoHtml.push(`üìù ${result.formatInfo.regieCount}x Regie`);
            if (result.formatInfo.liedCount > 0) infoHtml.push(`üéµ ${result.formatInfo.liedCount}x Lied`);
          } else {
            // Fallback auf Zeichenformate
            if (result.formatInfo.italicCount > 0) infoHtml.push(`üìù ${result.formatInfo.italicCount}x kursiv (‚Üí evtl. Regie)`);
            if (result.formatInfo.boldCount > 0) infoHtml.push(`<b>B</b> ${result.formatInfo.boldCount}x fett`);
            if (result.formatInfo.headingCount > 0) infoHtml.push(`üìë ${result.formatInfo.headingCount}x √úberschriften`);
          }
          
          formatDetails.innerHTML = infoHtml.join(' ‚Ä¢ ') || 'Standardformat erkannt';
          document.getElementById('import-format-info').style.display = 'block';
        }
        
        // Preview
        const preview = document.getElementById('import-word-preview');
        const previewText = document.getElementById('import-word-preview-text');
        preview.style.display = 'block';
        previewText.textContent = result.text.substring(0, 1500) + (result.text.length > 1500 ? '\n...' : '');
        
        // Button aktivieren
        document.getElementById('import-word-btn').disabled = false;
        
      } catch (error) {
        console.error('Import Fehler:', error);
        document.getElementById('import-word-name').textContent = '‚ùå Fehler: ' + error.message;
        alert('Fehler beim Lesen der Datei:\n\n' + error.message);
      }
    }
    
    // Word-Datei mit mammoth.js laden (mit Styling-Erkennung)
    async function extractWordContent(file) {
      const arrayBuffer = await file.arrayBuffer();
      
      // === ERWEITERTE StyleMap v2.0 ===
      // Basierend auf Analyse von 11 Theaterst√ºcken (DE, EN, FR)
      const options = {
        styleMap: [
          // === DEUTSCHE FORMATVORLAGEN ===
          "p[style-name='St√ºcktitel'] => h1.stuecktitel:fresh",
          "p[style-name='Untertitel'] => p.untertitel:fresh",
          "p[style-name='Akt'] => h2.akt:fresh",
          "p[style-name='Akttitel'] => h2.akt:fresh",
          "p[style-name='Akt-Titel'] => h2.akt:fresh",
          "p[style-name='Aufzug'] => h2.akt:fresh",
          "p[style-name='Szene Titel'] => h3.szene-titel:fresh",
          "p[style-name='Szenentitel'] => h3.szene-titel:fresh",
          "p[style-name='Szenen-Titel'] => h3.szene-titel:fresh",
          "p[style-name='Szene'] => h3.szene-titel:fresh",
          "p[style-name='Auftritt'] => h3.szene-titel:fresh",
          "p[style-name='Bild'] => h3.szene-titel:fresh",
          "p[style-name='Dialog'] => p.dialog:fresh",
          "p[style-name='Sprecher'] => p.dialog:fresh",
          "p[style-name='Figurentext'] => p.dialog:fresh",
          "p[style-name='Figurenname'] => p.dialog:fresh",
          "p[style-name='Regieanweisung'] => p.regie:fresh",
          "p[style-name='Regie'] => p.regie:fresh",
          "p[style-name='B√ºhnenanweisung'] => p.regie:fresh",
          "p[style-name='Nebentext'] => p.regie:fresh",
          "p[style-name='Liedtext'] => p.lied:fresh",
          "p[style-name='Lied'] => p.lied:fresh",
          "p[style-name='Song'] => p.lied:fresh",
          "p[style-name='Vers'] => p.vers:fresh",
          "p[style-name='Text'] => p.text:fresh",
          "p[style-name='Titel'] => h1.stuecktitel:fresh",
          "p[style-name='Personen'] => p.figurenliste:fresh",
          "p[style-name='Figuren'] => p.figurenliste:fresh",
          
          // === ENGLISCHE FORMATVORLAGEN ===
          "p[style-name='Title'] => h1.stuecktitel:fresh",
          "p[style-name='Subtitle'] => p.untertitel:fresh",
          "p[style-name='Act'] => h2.akt:fresh",
          "p[style-name='Act Title'] => h2.akt:fresh",
          "p[style-name='Scene'] => h3.szene-titel:fresh",
          "p[style-name='Scene Title'] => h3.szene-titel:fresh",
          "p[style-name='Scene Heading'] => h3.szene-titel:fresh",
          "p[style-name='Dialogue'] => p.dialog:fresh",
          "p[style-name='Character'] => p.dialog:fresh",
          "p[style-name='Character Name'] => p.dialog:fresh",
          "p[style-name='Stage Direction'] => p.regie:fresh",
          "p[style-name='Action'] => p.regie:fresh",
          "p[style-name='Parenthetical'] => p.regie:fresh",
          "p[style-name='Lyrics'] => p.lied:fresh",
          "p[style-name='Cast'] => p.figurenliste:fresh",
          
          // === FRANZ√ñSISCHE FORMATVORLAGEN ===
          "p[style-name='Titre'] => h1.stuecktitel:fresh",
          "p[style-name='Sous-titre'] => p.untertitel:fresh",
          "p[style-name='Acte'] => h2.akt:fresh",
          "p[style-name='Sc√®ne'] => h3.szene-titel:fresh",
          "p[style-name='Didascalie'] => p.regie:fresh",
          "p[style-name='R√©plique'] => p.dialog:fresh",
          "p[style-name='Personnage'] => p.dialog:fresh",
          "p[style-name='Personnages'] => p.figurenliste:fresh",
          
          // === √úBERSCHRIFTEN (Fallback) ===
          "p[style-name='Heading 1'] => h1.heading:fresh",
          "p[style-name='Heading 2'] => h2.heading:fresh",
          "p[style-name='Heading 3'] => h3.heading:fresh",
          "p[style-name='√úberschrift 1'] => h1.heading:fresh",
          "p[style-name='√úberschrift 2'] => h2.heading:fresh",
          "p[style-name='√úberschrift 3'] => h3.heading:fresh",
          
          // === ZEICHENFORMATE ===
          "r[style-name='Figurenname'] => span.figur",
          "r[style-name='Figur'] => span.figur",
          "r[style-name='Character Name'] => span.figur",
          "r[style-name='Sprecher'] => span.figur",
          "b => strong",
          "i => em"
        ]
      };
      
      const result = await mammoth.convertToHtml({ arrayBuffer }, options);
      const html = result.value;
      
      // Debug: Welche Styles wurden erkannt?
      console.log('Mammoth Messages:', result.messages);
      
      // Formatierungen analysieren
      const formatInfo = {
        stuecktitelCount: (html.match(/class="stuecktitel"/g) || []).length,
        untertitelCount: (html.match(/class="untertitel"/g) || []).length,
        aktCount: (html.match(/class="akt"/g) || []).length,
        szeneCount: (html.match(/class="szene-titel"/g) || []).length,
        dialogCount: (html.match(/class="dialog"/g) || []).length,
        regieCount: (html.match(/class="regie"/g) || []).length,
        liedCount: (html.match(/class="lied"/g) || []).length,
        italicCount: (html.match(/<em>/g) || []).length,
        boldCount: (html.match(/<strong>/g) || []).length,
        headingCount: (html.match(/<h[1-6]/g) || []).length
      };
      
      // Pr√ºfen ob echte Formatvorlagen erkannt wurden
      const hasRealStyles = formatInfo.dialogCount > 0 || formatInfo.regieCount > 0 || 
                           formatInfo.aktCount > 0 || formatInfo.szeneCount > 0;
      
      // HTML in strukturierten Text mit Markern konvertieren
      let richText = html
        // Echte Formatvorlagen -> Marker
        .replace(/<h1 class="stuecktitel">([^<]+)<\/h1>/g, '[[STUECKTITEL:$1]]\n')
        .replace(/<p class="untertitel">([^<]+)<\/p>/g, '[[UNTERTITEL:$1]]\n')
        .replace(/<h2 class="akt">([^<]+)<\/h2>/g, '[[AKT:$1]]\n')
        .replace(/<h3 class="szene-titel">([^<]+)<\/h3>/g, '[[SZENE:$1]]\n')
        .replace(/<p class="dialog">([^<]+)<\/p>/g, '[[DIALOG:$1]]\n')
        .replace(/<p class="regie">([^<]+)<\/p>/g, '[[REGIE:$1]]\n')
        .replace(/<p class="lied">([^<]+)<\/p>/g, '[[LIED:$1]]\n')
        .replace(/<p class="text">([^<]+)<\/p>/g, '$1\n')
        // Headings als Fallback
        .replace(/<h1 class="heading">([^<]+)<\/h1>/g, '[[HEADING1:$1]]\n')
        .replace(/<h2 class="heading">([^<]+)<\/h2>/g, '[[HEADING2:$1]]\n')
        .replace(/<h3 class="heading">([^<]+)<\/h3>/g, '[[HEADING3:$1]]\n')
        // Zeichenformate
        .replace(/<em>([^<]+)<\/em>/g, '[[ITALIC:$1]]')
        .replace(/<strong>([^<]+)<\/strong>/g, '[[BOLD:$1]]')
        .replace(/<span class="figur">([^<]+)<\/span>/g, '[[FIGUR:$1]]');
      
      // Reiner Text
      const textOnly = html.replace(/<[^>]+>/g, '\n').replace(/\n+/g, '\n').trim();
      
      return {
        html: html,
        text: textOnly,
        richText: richText.replace(/<[^>]+>/g, '\n').replace(/\n+/g, '\n').trim(),
        formatInfo: formatInfo,
        hasRealStyles: hasRealStyles
      };
    }
    
    // PDF-Datei mit pdf.js laden
    async function extractPDFContent(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      
      let fullText = '';
      let richText = '';
      let formatInfo = {
        italicCount: 0,
        boldCount: 0,
        dialogCount: 0,
        headingCount: 0
      };
      
      // Alle Seiten durchgehen
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const textContent = await page.getTextContent();
        
        let pageText = '';
        let lastY = null;
        let lastFontSize = null;
        
        for (const item of textContent.items) {
          const text = item.str;
          const y = item.transform[5];
          const fontName = item.fontName || '';
          const fontSize = item.height || 12;
          
          // Neue Zeile erkennen (Y-Position √§ndert sich)
          if (lastY !== null && Math.abs(y - lastY) > 5) {
            pageText += '\n';
            richText += '\n';
          }
          
          // Formatierung aus Schriftname erkennen
          const isItalic = fontName.toLowerCase().includes('italic') || fontName.toLowerCase().includes('oblique');
          const isBold = fontName.toLowerCase().includes('bold');
          const isHeading = fontSize > 14;
          
          if (isItalic) {
            formatInfo.italicCount++;
            richText += `[[ITALIC:${text}]]`;
          } else if (isBold) {
            formatInfo.boldCount++;
            richText += `[[BOLD:${text}]]`;
          } else if (isHeading && text.length > 2) {
            formatInfo.headingCount++;
            richText += `[[HEADING:${text}]]`;
          } else {
            richText += text;
          }
          
          pageText += text;
          lastY = y;
          lastFontSize = fontSize;
        }
        
        fullText += pageText + '\n\n';
      }
      
      // Dialog-Muster z√§hlen
      formatInfo.dialogCount = (fullText.match(/^[A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√ú\s]{1,20}[:\.]/gm) || []).length;
      
      return {
        html: fullText.replace(/\n/g, '<br>'),
        text: fullText.trim(),
        richText: richText.trim(),
        formatInfo: formatInfo
      };
    }
    
    // Alte Funktion als Wrapper behalten f√ºr Kompatibilit√§t
    async function handleWordFile(input) {
      return handleDocumentFile(input);
    }
    
    // Word-Import durchf√ºhren (ohne KI - Formatvorlagen funktionieren besser!)
    async function doImportWord() {
      if (!importedWordData) {
        alert('Bitte zuerst eine Datei ausw√§hlen.');
        return;
      }
      
      // Import immer mit Formatvorlagen/Textmuster (kein KI)
      doSimpleWordImport(importedWordData);
    }
    
    // ============================================
    // IMPORT-LOGIK v2.0
    // ============================================
    // WORD: 1. Formatvorlagen ‚Üí 2. Textmuster-Analyse
    // PDF:  Direkt Textmuster-Analyse
    // ANALYSE: Figurenliste ZUERST ‚Üí dann Dialoge erkennen!
    // ============================================
    
    function doSimpleWordImport(data) {
      const richText = data.richText || data.text;
      const plainText = data.text;
      const hasRealStyles = data.hasRealStyles || false;
      
      console.log('=== IMPORT START (v2.4) ===');
      console.log('Dateityp:', data.fileType || 'word');
      console.log('Hat Formatvorlagen:', hasRealStyles);
      
      // v2.4: Vereinfachter Import
      // - Formatvorlagen vorhanden? ‚Üí Als formatierten Text in EINE Szene importieren
      // - Keine Formatvorlagen? ‚Üí Als Plaintext in EINE Szene importieren
      // - NIEMALS versuchen Figuren, Szenen oder Akte automatisch zu erkennen!
      //   Der Benutzer definiert die Struktur nachtr√§glich in der App.
      
      if (hasRealStyles) {
        console.log('‚Üí Formatvorlagen erkannt, importiere formatierten Text');
        importWithStylesSimple(richText, plainText, data.fileName);
      } else {
        console.log('‚Üí Keine Formatvorlagen, importiere als Text');
        importBasic(richText, data.fileName);
      }
    }
    
    /**
     * NEU: Import mit Textmuster-Analyse
     * Nutzt die erkannte Figurenliste f√ºr pr√§zise Dialog-Erkennung!
     */
    function importWithPatternAnalysis(data, figuren) {
      const text = data.text;
      const richText = data.richText || text;
      const lines = text.split('\n');
      
      // Figurennamen f√ºr Dialog-Erkennung
      const figurenNamen = figuren.map(f => f.name);
      console.log('Bekannte Figuren:', figurenNamen.join(', '));
      
      // Strukturtyp erkennen
      const strukturTyp = detectStrukturTyp(text);
      console.log('Erkannter Strukturtyp:', strukturTyp);
      
      // Metadaten extrahieren
      const meta = extractMetadatenFromText(text);
      console.log('Metadaten:', meta);
      
      // Szenen-Grenzen finden
      const grenzen = findSzenenGrenzen(text, strukturTyp);
      console.log('Szenen-Grenzen gefunden:', grenzen.length);
      
      // Szenen erstellen
      const newSzenen = [];
      const newTextbuch = {};
      let currentAkt = '1';
      
      if (grenzen.length === 0) {
        // Keine Struktur erkannt - als eine Szene importieren
        console.log('Keine Szenen-Grenzen, importiere als eine Szene');
        const szene = {
          id: genId(),
          nummer: '1.1',
          titel: meta.titel || data.fileName.replace(/\.(docx|pdf)$/i, ''),
          gruppe: '1',
          zusammenfassung: meta.gattung || '',
          figuren: []
        };
        newSzenen.push(szene);
        newTextbuch[szene.id] = formatImportedText(richText);
      } else {
        // Szenen aus erkannten Grenzen erstellen
        for (let i = 0; i < grenzen.length; i++) {
          const grenze = grenzen[i];
          const nextGrenze = grenzen[i + 1];
          
          // Akt-Wechsel erkennen
          if (grenze.isAkt) {
            const aktMatch = grenze.text.match(/(\d+)/);
            if (aktMatch) {
              currentAkt = aktMatch[1];
            } else if (/prolog|vorspiel/i.test(grenze.text)) {
              currentAkt = '0';
            } else {
              currentAkt = (parseInt(currentAkt) + 1).toString();
            }
          }
          
          // Szenen-Nummer berechnen
          const szenenInAkt = newSzenen.filter(s => s.gruppe === currentAkt && !s.nummer.endsWith('.0')).length;
          const istAktHeader = grenze.isAkt && !STRUKTUR_PATTERNS.szene.some(p => p.test(grenze.text));
          const nummer = istAktHeader ? currentAkt + '.0' : currentAkt + '.' + (szenenInAkt + 1);
          
          // Text f√ºr diese Szene extrahieren
          const startLine = grenze.lineIndex;
          const endLine = nextGrenze ? nextGrenze.lineIndex : lines.length;
          const szeneText = lines.slice(startLine, endLine).join('\n');
          
          // Titel bereinigen
          let titel = grenze.text
            .replace(/^\d+\.\s*(Szene|Akt|Bild|Auftritt|Aufzug)\s*[-‚Äì‚Äî/:]*\s*/i, '')
            .replace(/^(Erster?|Zweiter?|Dritter?)\s+(Szene|Akt|Auftritt|Aufzug)\s*[-‚Äì‚Äî/:]*\s*/i, '')
            .substring(0, 60);
          if (!titel || titel === grenze.text) titel = grenze.text.substring(0, 50);
          
          const szene = {
            id: genId(),
            nummer: nummer,
            titel: titel,
            gruppe: currentAkt,
            zusammenfassung: '',
            figuren: []
          };
          newSzenen.push(szene);
          newTextbuch[szene.id] = formatImportedText(szeneText);
        }
      }
      
      // Figuren-Objekte erstellen
      const newFiguren = figuren.map(f => ({
        id: genId(),
        name: f.name || 'Unbenannt',
        kuerzel: (f.name || '').substring(0, 2).toUpperCase(),
        beschreibung: f.beschreibung || ''
      }));
      
      // Figuren den Szenen zuordnen (basierend auf Vorkommen im Text)
      newSzenen.forEach(szene => {
        const szeneText = newTextbuch[szene.id] || '';
        szene.figuren = newFiguren
          .filter(f => {
            // Pr√ºfe ob Figur in dieser Szene spricht/vorkommt
            const namePattern = new RegExp(escapeRegex(f.name) + '\\s*[:\\.\\)]', 'i');
            return namePattern.test(szeneText);
          })
          .map(f => f.id);
      });
      
      // State aktualisieren
      state.szenen = newSzenen;
      state.textbuch = newTextbuch;
      state.figuren = newFiguren;
      state.aktiveSzene = newSzenen[0]?.id;
      
      // Projekt-Meta aktualisieren
      if (meta.titel) state.projektMeta.titel = meta.titel;
      if (meta.gattung) state.projektMeta.untertitel = meta.gattung;
      if (meta.autor) state.projektMeta.autor = meta.autor;
      if (meta.copyright) state.projektMeta.copyright = meta.copyright;
      
      state.projektMeta.strukturTyp = strukturTyp === 'bilder' ? 'bilder' : 
                                       strukturTyp === 'nummeriert' ? 'sequenzen' : 'akte';
      
      if (!state.projektMeta.titel) {
        state.projektMeta.titel = data.fileName.replace(/\.(docx|pdf)$/i, '');
      }
      
      // Projektname in Liste aktualisieren
      const projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === state.projektId);
      if (idx !== -1 && state.projektMeta.titel) {
        projekte[idx].name = state.projektMeta.titel;
        save(KEYS.projekte, projekte);
      }
      
      saveProjektDaten();
      closeModal('showImportModal');
      importedWordData = null;
      render();
      
      console.log('=== IMPORT FERTIG ===');
      
      alert(`‚úÖ Import erfolgreich!

üìÑ ${state.projektMeta.titel || 'St√ºck'}
üë§ ${newFiguren.length} Figuren erkannt
üé¨ ${newSzenen.length} Szenen erstellt
üèõÔ∏è Struktur: ${strukturTyp === 'bilder' ? 'Bilder' : strukturTyp === 'nummeriert' ? 'Nummeriert' : 'Akte/Szenen'}

Die Figuren wurden aus der Figurenliste erkannt und den Szenen zugeordnet.`);
    }
    
    // v2.4.1: Import mit Formatvorlagen ‚Äì nur Formatierung √ºbernehmen, keine Struktur-Erkennung
    function importWithStylesSimple(richText, plainText, fileName, meta) {
      // Den gesamten Text als EINE Szene importieren
      // aber mit korrekter Formatierung (Dialog, Regie, Lied etc.)
      
      const lines = richText.split('\n');
      let stuecktitel = '';
      let untertitel = '';
      let formattedHtml = [];
      
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) {
          formattedHtml.push('<p class="format-standard"><br></p>');
          continue;
        }
        
        // St√ºcktitel extrahieren (f√ºr Projekt-Meta)
        if (trimmed.includes('[[STUECKTITEL:')) {
          const match = trimmed.match(/\[\[STUECKTITEL:([^\]]+)\]\]/);
          if (match) stuecktitel = match[1].trim();
          formattedHtml.push('<p class="format-standard"><strong>' + escapeHtml(match ? match[1].trim() : trimmed) + '</strong></p>');
          continue;
        }
        
        // Untertitel
        if (trimmed.includes('[[UNTERTITEL:')) {
          const match = trimmed.match(/\[\[UNTERTITEL:([^\]]+)\]\]/);
          if (match) untertitel += (untertitel ? ' ' : '') + match[1].trim();
          formattedHtml.push('<p class="format-standard"><em>' + escapeHtml(match ? match[1].trim() : trimmed) + '</em></p>');
          continue;
        }
        
        // Akt-Titel ‚Üí als √úberschrift formatieren
        if (trimmed.includes('[[AKT:')) {
          const match = trimmed.match(/\[\[AKT:([^\]]+)\]\]/);
          const text = match ? match[1].trim() : trimmed;
          formattedHtml.push('<p class="format-standard"><strong style="font-size: 1.2em;">' + escapeHtml(text) + '</strong></p>');
          continue;
        }
        
        // Szene-Titel ‚Üí als √úberschrift formatieren
        if (trimmed.includes('[[SZENE:')) {
          const match = trimmed.match(/\[\[SZENE:([^\]]+)\]\]/);
          const text = match ? match[1].trim() : trimmed;
          formattedHtml.push('<p class="format-standard"><strong>' + escapeHtml(text) + '</strong></p>');
          continue;
        }
        
        // Dialog ‚Üí als Dialog-Format
        if (trimmed.includes('[[DIALOG:')) {
          const match = trimmed.match(/\[\[DIALOG:([^\]]+)\]\]/);
          const text = match ? match[1].trim() : trimmed;
          const dialogMatch = text.match(/^([A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s.\-]+?)\s*[:.](.*)/);
          if (dialogMatch) {
            formattedHtml.push('<div class="format-dialog"><div class="dialog-grid"><span class="figur-name">' + escapeHtml(dialogMatch[1].trim()) + '</span><span class="dialog-text">' + escapeHtml(dialogMatch[2].trim()) + '</span></div></div>');
          } else {
            formattedHtml.push('<p class="format-dialog">' + escapeHtml(text) + '</p>');
          }
          continue;
        }
        
        // Regieanweisung ‚Üí als Regie-Format
        if (trimmed.includes('[[REGIE:')) {
          const match = trimmed.match(/\[\[REGIE:([^\]]+)\]\]/);
          const text = match ? match[1].trim() : trimmed;
          formattedHtml.push('<p class="format-regie">' + escapeHtml(text) + '</p>');
          continue;
        }
        
        // Lied ‚Üí als kursiv
        if (trimmed.includes('[[LIED:')) {
          const match = trimmed.match(/\[\[LIED:([^\]]+)\]\]/);
          const text = match ? match[1].trim() : trimmed;
          formattedHtml.push('<p class="format-standard"><em>üéµ ' + escapeHtml(text) + '</em></p>');
          continue;
        }
        
        // Heading Fallback
        if (trimmed.includes('[[HEADING1:') || trimmed.includes('[[HEADING2:') || trimmed.includes('[[HEADING3:') || trimmed.includes('[[HEADING:')) {
          const match = trimmed.match(/\[\[HEADING\d?:([^\]]+)\]\]/);
          const text = match ? match[1].trim() : trimmed;
          formattedHtml.push('<p class="format-standard"><strong>' + escapeHtml(text) + '</strong></p>');
          continue;
        }
        
        // Inline-Formatierung verarbeiten (BOLD, ITALIC)
        let cleanLine = trimmed;
        cleanLine = cleanLine.replace(/\[\[BOLD:([^\]]+)\]\]/g, '<strong>$1</strong>');
        cleanLine = cleanLine.replace(/\[\[ITALIC:([^\]]+)\]\]/g, '<em>$1</em>');
        cleanLine = cleanLine.replace(/\[\[FIGUR:([^\]]+)\]\]/g, '<strong>$1</strong>');
        // Alle verbleibenden Marker entfernen
        cleanLine = cleanLine.replace(/\[\[[A-Z_]+:([^\]]*)\]\]/g, '$1');
        
        formattedHtml.push('<p class="format-standard">' + cleanLine + '</p>');
      }
      
      // Als eine Szene importieren
      const neueSzene = {
        id: genId(),
        nummer: '1.1',
        titel: stuecktitel || meta?.titel || fileName.replace(/\.(docx|pdf)$/i, ''),
        ort: '',
        zeit: '',
        gruppe: state.projektMeta.eigeneGruppen?.[0] || 'Erster Akt',
        zusammenfassung: '',
        figuren: []
      };
      
      state.szenen = [neueSzene];
      state.textbuch = { [neueSzene.id]: formattedHtml.join('\n') };
      state.figuren = []; // User definiert Figuren selbst
      state.aktiveSzene = neueSzene.id;
      
      // Projekt-Meta
      if (stuecktitel) state.projektMeta.titel = stuecktitel;
      if (untertitel) state.projektMeta.untertitel = untertitel;
      if (meta?.autor) state.projektMeta.autor = meta.autor;
      if (meta?.copyright) state.projektMeta.copyright = meta.copyright;
      if (!state.projektMeta.titel) {
        state.projektMeta.titel = fileName.replace(/\.(docx|pdf)$/i, '');
      }
      
      // Projektname aktualisieren
      const projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === state.projektId);
      if (idx !== -1 && state.projektMeta.titel) {
        projekte[idx].name = state.projektMeta.titel;
        save(KEYS.projekte, projekte);
      }
      
      saveProjektDaten();
      closeModal('showImportModal');
      importedWordData = null;
      render();
      
      alert('‚úÖ Import mit Formatvorlagen erfolgreich!\n\n' +
            'üìÑ ' + (state.projektMeta.titel || 'St√ºck') + '\n' +
            'üé¨ 1 Szene erstellt (gesamter Text)\n\n' +
            'Formatierungen (Dialog, Regieanweisungen etc.) wurden √ºbernommen.\n\n' +
            'üí° Tipp: Nutze ¬´‚úÇÔ∏è Teilen¬ª um den Text in mehrere Szenen aufzuteilen,\n' +
            'und definiere Figuren im Figuren-Modul.');
    }
    
    // Basis-Import ohne Struktur (Fallback)
    function importBasic(text, fileName, meta) {
      // Als eine Szene importieren
      const neueSzene = {
        id: genId(),
        nummer: '1.1',
        titel: meta?.titel || fileName.replace(/\.(docx|pdf)$/i, ''),
        ort: '',
        zeit: '',
        gruppe: state.projektMeta.eigeneGruppen?.[0] || 'Erster Akt',
        zusammenfassung: '',
        figuren: []
      };
      
      // HTML formatieren
      let html = formatImportedText(text);
      
      state.szenen = [neueSzene];
      state.textbuch = { [neueSzene.id]: html };
      state.figuren = []; // User definiert Figuren selbst
      state.aktiveSzene = neueSzene.id;
      
      // Projekt-Meta
      if (meta?.titel) state.projektMeta.titel = meta.titel;
      if (meta?.autor) state.projektMeta.autor = meta.autor;
      if (meta?.copyright) state.projektMeta.copyright = meta.copyright;
      if (meta?.gattung) state.projektMeta.untertitel = meta.gattung;
      if (!state.projektMeta.titel) {
        state.projektMeta.titel = fileName.replace(/\.(docx|pdf)$/i, '');
      }
      
      // Projektname aktualisieren
      const projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === state.projektId);
      if (idx !== -1 && state.projektMeta.titel) {
        projekte[idx].name = state.projektMeta.titel;
        save(KEYS.projekte, projekte);
      }
      
      saveProjektDaten();
      closeModal('showImportModal');
      importedWordData = null;
      render();
      
      alert('‚úÖ Dokument importiert!\n\n' +
            'üìÑ ' + (state.projektMeta.titel || 'St√ºck') + '\n' +
            'üé¨ 1 Szene erstellt (gesamter Text)\n\n' +
            '‚ö†Ô∏è Keine Formatvorlagen erkannt ‚Äì Text wurde als Fliesstext importiert.\n\n' +
            'üí° Tipps:\n' +
            '‚Ä¢ Nutze ¬´‚úÇÔ∏è Teilen¬ª um den Text in mehrere Szenen aufzuteilen\n' +
            '‚Ä¢ Definiere Figuren im Figuren-Modul\n' +
            '‚Ä¢ Formatiere Dialoge und Regieanweisungen mit den Toolbar-Buttons');
    }


    // KI-gest√ºtzter Import
    async function doImportWithAI(text, apiKey) {
      const status = document.getElementById('import-word-status');
      const statusText = document.getElementById('import-word-status-text');
      status.style.display = 'block';
      statusText.textContent = 'Analysiere mit KI...';
      document.getElementById('import-word-btn').disabled = true;
      
      // Nutze richText falls vorhanden (enth√§lt Formatierungsmarker)
      const analysisText = importedWordData?.richText || text;
      const formatInfo = importedWordData?.formatInfo || {};
      
      try {
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 16000,
            messages: [{
              role: 'user',
              content: `Du bist ein erfahrener Dramaturg. Analysiere dieses Theaterst√ºck SEHR SORGF√ÑLTIG.

WICHTIG - SCHWEIZER RECHTSCHREIBUNG: Verwende IMMER "ss" statt "√ü" (z.B. "Strasse", "gross", "weiss").

=== FORMATIERUNGSMARKER IM TEXT ===
Der Text enth√§lt m√∂glicherweise diese Marker:
- [[ITALIC:text]] = Kursiver Text ‚Üí Meist REGIEANWEISUNGEN
- [[BOLD:text]] = Fetter Text ‚Üí Meist FIGURENNAMEN oder √úBERSCHRIFTEN  
- [[HEADING:text]] = √úberschrift ‚Üí Meist AKT-/SZENEN-TITEL
- [[REGIE:text]] = Als Regieanweisung formatiert
- [[DIALOG:text]] = Als Dialog formatiert
- [[SZENE:text]] = Als Szenentitel formatiert
- [[AKT:text]] = Als Akttitel formatiert
- [[LIED:text]] = Als Liedtext formatiert

Erkannte Formatierungen: ${formatInfo.italicCount || 0}x kursiv, ${formatInfo.boldCount || 0}x fett, ${formatInfo.headingCount || 0}x √úberschriften

=== FIGURENLISTE ZUERST! (WICHTIG!) ===
Suche am ANFANG des Textes nach einer Figurenliste:
- "Personen:" / "Figuren:" / "Rollen:" / "Besetzung:"
- "PERSONNAGES:" (franz√∂sisch) / "Characters:" (englisch)
- Format: "NAME - Beschreibung" oder "NAME, Rolle"
- Gruppiert: "Die Bauern: Hans, Fritz, Karl"
Die dort genannten Namen helfen bei der Dialog-Erkennung!

=== STRUKTUR-TYPEN ===
Erkenne welcher Strukturtyp vorliegt:
1. AKTE & SZENEN: "1. Akt", "Erste Szene", "Akt II" ‚Üí strukturTyp: "akte"
2. AUFZ√úGE & AUFTRITTE: "Erster Aufzug", "2. Auftritt" ‚Üí strukturTyp: "akte"
3. BILDER: Nur Nummern "1." "2." "3." oder "A." "B." ‚Üí strukturTyp: "bilder"
4. NUMMERIERT: "1.1", "1.2", "2.1" ‚Üí strukturTyp: "sequenzen"
5. SCHAUPL√ÑTZE: Ortsnamen als √úberschriften ‚Üí strukturTyp: "sequenzen"
6. KEINE GLIEDERUNG: Fortlaufender Text ‚Üí strukturTyp: "episodisch"

=== DIALOG-FORMATE ===
Erkenne das verwendete Format:
- NAME: Text (Doppelpunkt) = h√§ufigstes Format
- NAME. Text (Punkt) = Oper, Klassik (z.B. "LUCENTIO. Holde Bianca...")
- NAME (ohne Zeichen, eigene Zeile) = modernes Theater
- 1. BAUER: / 2. SOLDAT: = Nummerierte generische Figuren
- ERSTER MANN: / ZWEITE FRAU: = Generische Figuren
- CHOR. / ALLE: = Gruppen-Sprecher

=== SZENEN-ERKENNUNG ===
Szenenwechsel erkennen:
1. Explizite Marker: "1. Szene", "Szene 2", "Erste Szene"
2. Akt-Wechsel: "2. Akt", "ERSTER AKT" ‚Üí danach neue Szene
3. Bild-Nummern: "1." "2." "3." (allein auf Zeile)
4. Ortswechsel: Neue √úberschrift oder (Klammern)
5. Zeitsprung: "Am n√§chsten Morgen", "Sp√§ter"
6. "Vorhang" oder "Verwandlung"

REGEL: Jeder ORTSWECHSEL oder ZEITSPRUNG = NEUE SZENE!

=== REGIEANWEISUNGEN ===
- Text in (Klammern) der NICHT in einem Dialog steht
- [[ITALIC:text]] = Kursiv (h√§ufigstes Format!)
- Eigenst√§ndig: "(Er geht zur T√ºr)", "(Stille)", "(Ab)"
- B√ºhne: "(Licht:...)", "(Musik:...)"

=== MUSICAL/OPER ===
Wenn Lieder vorhanden:
- "Musik Nr.X" / "Lied Nr.X" / "Text Nr.X"
- "REFRAIN:" / "(singt)" / "singt:"
- Setze hatLieder: true

Antworte NUR mit validem JSON:

{
  "titel": "Haupttitel des St√ºcks",
  "untertitel": "Untertitel/Gattung falls vorhanden",
  "autor": "Autor:in falls erkennbar",
  "uebersetzer": "√úbersetzer falls erkennbar",
  "copyright": "¬© Jahr falls erkennbar",
  "tagline": "Werbeslogan (max 8 W√∂rter)",
  "logline": "Worum geht es? (2-3 S√§tze)",
  "strukturTyp": "akte|sequenzen|bilder|episodisch",
  "istMusical": false,
  "figuren": [
    {
      "name": "FIGURENNAME",
      "kuerzel": "FN",
      "beschreibung": "Wer ist diese Figur? Was will sie? (2-3 S√§tze)"
    }
  ],
  "szenen": [
    {
      "nummer": "1.1",
      "titel": "Aussagekr√§ftiger Titel",
      "gruppe": "1",
      "ort": "Wo?",
      "zeit": "Wann?",
      "zusammenfassung": "Was passiert? (2-3 S√§tze)",
      "figuren": ["FIGUR1", "FIGUR2"],
      "textAnfang": "Die ersten 50 Zeichen exakt",
      "hatLieder": false
    }
  ]
}

QUALIT√ÑTSREGELN:
- Suche ZUERST nach der Figurenliste!
- Erkenne ALLE Szenen und ALLE Figuren
- "gruppe": "1" = Akt 1, "2" = Akt 2, etc.
- textAnfang: EXAKT die ersten 50 Zeichen (ohne Marker)

TEXT ZUR ANALYSE:
${analysisText.substring(0, 35000)}${analysisText.length > 35000 ? '\n[gek√ºrzt]' : ''}`
            }]
          })
        });
        
        if (!response.ok) {
          throw new Error('API-Fehler: ' + response.status);
        }
        
        const data = await response.json();
        const aiText = data.content[0].text;
        
        // JSON parsen
        let analysis;
        try {
          const jsonMatch = aiText.match(/\{[\s\S]*\}/);
          analysis = JSON.parse(jsonMatch ? jsonMatch[0] : aiText);
        } catch (e) {
          console.error('JSON Parse Error:', aiText);
          throw new Error('KI-Antwort konnte nicht verarbeitet werden.');
        }
        
        statusText.textContent = 'Erstelle Projekt...';
        applyAIAnalysis(analysis, text);
        
      } catch (error) {
        console.error('KI-Import Fehler:', error);
        status.style.display = 'none';
        document.getElementById('import-word-btn').disabled = false;
        
        if (confirm('KI-Analyse fehlgeschlagen: ' + error.message + '\n\nOhne KI importieren?')) {
          doSimpleWordImport(importedWordData);
        }
      }
    }
    
    // KI-Analyse anwenden
    function applyAIAnalysis(analysis, fullText) {
      // Projekt-Meta
      if (analysis.titel) state.projektMeta.titel = analysis.titel;
      if (analysis.untertitel) state.projektMeta.untertitel = analysis.untertitel;
      if (analysis.autor) state.projektMeta.autor = analysis.autor;
      if (analysis.copyright) state.projektMeta.copyright = analysis.copyright;
      if (analysis.tagline) state.projektMeta.tagline = analysis.tagline;
      if (analysis.logline) state.projektMeta.logline = analysis.logline;
      if (analysis.strukturTyp) state.projektMeta.strukturTyp = analysis.strukturTyp;
      
      // Projektname aktualisieren
      const projekte = load(KEYS.projekte, []);
      const idx = projekte.findIndex(p => p.id === state.projektId);
      if (idx !== -1 && analysis.titel) {
        projekte[idx].name = analysis.titel;
        save(KEYS.projekte, projekte);
      }
      
      // Figuren
      state.figuren = (analysis.figuren || []).map(f => ({
        id: genId(),
        name: f.name || 'Unbenannt',
        kuerzel: f.kuerzel || (f.name || '').substring(0, 2).toUpperCase(),
        beschreibung: f.beschreibung || ''
      }));
      
      // Szenen
      state.szenen = [];
      state.textbuch = {};
      
      const szenenDefs = analysis.szenen || [];
      
      if (szenenDefs.length === 0) {
        // Fallback
        const szene = {
          id: genId(),
          nummer: '1.1',
          titel: analysis.titel || 'Importiert',
          gruppe: '1',
          zusammenfassung: analysis.logline || '',
          figuren: state.figuren.map(f => f.id)
        };
        state.szenen.push(szene);
        state.textbuch[szene.id] = formatImportedText(fullText);
      } else {
        szenenDefs.forEach((sDef, i) => {
          const szene = {
            id: genId(),
            nummer: sDef.nummer || `${Math.floor(i/5)+1}.${(i%5)+1}`,
            titel: sDef.titel || `Szene ${i+1}`,
            gruppe: sDef.gruppe || '1',
            ort: sDef.ort || '',
            zeit: sDef.zeit || '',
            zusammenfassung: sDef.zusammenfassung || '',
            figuren: (sDef.figuren || []).map(fName => {
              const fig = state.figuren.find(f => f.name.toUpperCase() === fName.toUpperCase());
              return fig?.id;
            }).filter(Boolean)
          };
          state.szenen.push(szene);
          
          // Text-Zuordnung (vereinfacht)
          let szeneText = '';
          if (sDef.textAnfang && fullText.includes(sDef.textAnfang.substring(0, 20))) {
            const startIdx = fullText.indexOf(sDef.textAnfang.substring(0, 20));
            const nextDef = szenenDefs[i + 1];
            let endIdx = fullText.length;
            if (nextDef?.textAnfang) {
              const nextStart = fullText.indexOf(nextDef.textAnfang.substring(0, 20), startIdx + 50);
              if (nextStart > startIdx) endIdx = nextStart;
            }
            szeneText = fullText.substring(startIdx, endIdx);
          }
          
          state.textbuch[szene.id] = formatImportedText(szeneText || `[Szene ${szene.nummer}]`);
        });
      }
      
      state.aktiveSzene = state.szenen[0]?.id;
      
      saveProjektDaten();
      closeModal('showImportModal');
      importedWordData = null;
      render();
      
      alert(`‚úÖ KI-Import erfolgreich!

üìÑ ${analysis.titel || 'St√ºck'}
üë§ ${state.figuren.length} Figuren erkannt
üé¨ ${state.szenen.length} Szenen erstellt
üèõÔ∏è Struktur: ${analysis.strukturTyp || 'Frei'}

Pr√ºfe die Ergebnisse und passe sie bei Bedarf an.`);
    }
    
    // Text f√ºr Editor formatieren (mit Marker-Unterst√ºtzung)
    function formatImportedText(text) {
      if (!text) return '<p class="format-standard"><br></p>';
      
      // Marker entfernen aber Information nutzen
      let processedText = text;
      
      // Erst Marker in tempor√§re Tags umwandeln
      processedText = processedText
        // Neue echte Formatvorlagen-Marker
        .replace(/\[\[STUECKTITEL:([^\]]+)\]\]/g, '<STUECKTITEL>$1</STUECKTITEL>')
        .replace(/\[\[UNTERTITEL:([^\]]+)\]\]/g, '<UNTERTITEL>$1</UNTERTITEL>')
        .replace(/\[\[LIED:([^\]]+)\]\]/g, '<LIED>$1</LIED>')
        .replace(/\[\[FIGUR:([^\]]+)\]\]/g, '<FIGUR>$1</FIGUR>')
        .replace(/\[\[HEADING1:([^\]]+)\]\]/g, '<HEADING1>$1</HEADING1>')
        .replace(/\[\[HEADING2:([^\]]+)\]\]/g, '<HEADING2>$1</HEADING2>')
        .replace(/\[\[HEADING3:([^\]]+)\]\]/g, '<HEADING3>$1</HEADING3>')
        // Bestehende Marker
        .replace(/\[\[REGIE:([^\]]+)\]\]/g, '<REGIE>$1</REGIE>')
        .replace(/\[\[DIALOG:([^\]]+)\]\]/g, '<DIALOG>$1</DIALOG>')
        .replace(/\[\[SZENE:([^\]]+)\]\]/g, '<SZENE>$1</SZENE>')
        .replace(/\[\[AKT:([^\]]+)\]\]/g, '<AKT>$1</AKT>')
        .replace(/\[\[HEADING:([^\]]+)\]\]/g, '<HEADING>$1</HEADING>')
        .replace(/\[\[ITALIC:([^\]]+)\]\]/g, '<ITALIC>$1</ITALIC>')
        .replace(/\[\[BOLD:([^\]]+)\]\]/g, '<BOLD>$1</BOLD>');
      
      return processedText
        .split(/\n+/)
        .map(line => {
          line = line.trim();
          if (!line) return '';
          
          // === ECHTE FORMATVORLAGEN (h√∂chste Priorit√§t) ===
          
          // St√ºcktitel (ignorieren wir im Editor, wird in Projekt-Meta gespeichert)
          if (line.includes('<STUECKTITEL>')) {
            const content = line.replace(/<\/?STUECKTITEL>/g, '').trim();
            return `<p class="format-akt-titel" style="font-size: 18pt; text-align: center;">${content}</p>`;
          }
          
          // Untertitel
          if (line.includes('<UNTERTITEL>')) {
            const content = line.replace(/<\/?UNTERTITEL>/g, '').trim();
            return `<p class="format-standard" style="text-align: center; font-style: italic;">${content}</p>`;
          }
          
          // Akt
          if (line.includes('<AKT>')) {
            const content = line.replace(/<\/?AKT>/g, '').trim();
            return `<p class="format-akt-titel">${content}</p>`;
          }
          
          // Szene
          if (line.includes('<SZENE>')) {
            const content = line.replace(/<\/?SZENE>/g, '').trim();
            return `<p class="format-szene-titel">${content}</p>`;
          }
          
          // Regieanweisung
          if (line.includes('<REGIE>')) {
            let content = line.replace(/<\/?REGIE>/g, '').trim();
            // Klammern hinzuf√ºgen falls nicht vorhanden
            if (!content.startsWith('(')) content = '(' + content;
            if (!content.endsWith(')')) content = content + ')';
            return `<p class="format-regieanweisung">${content}</p>`;
          }
          
          // Dialog - MIT Figurenname:Text Erkennung
          if (line.includes('<DIALOG>')) {
            const content = line.replace(/<\/?DIALOG>/g, '').replace(/<\/?[A-Z]+>/g, '').trim();
            // Dialog-Format: NAME: Text oder NAME.Text
            const dialogMatch = content.match(/^([A-Z√Ñ√ñ√úa-z√§√∂√º][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]*?)\s*[:\.]\s*(.*)$/);
            if (dialogMatch) {
              const figurName = dialogMatch[1].trim();
              const dialogText = dialogMatch[2] || '';
              return `<div class="format-dialog"><span class="figur-name">${figurName}:</span><span class="dialog-text">${dialogText}</span></div>`;
            }
            // Fallback: Ganzer Text als Dialog ohne erkannten Namen
            return `<p class="format-standard">${content}</p>`;
          }
          
          // Lied
          if (line.includes('<LIED>')) {
            const content = line.replace(/<\/?LIED>/g, '').replace(/<\/?[A-Z]+>/g, '').trim();
            return `<p class="format-lied">${content}</p>`;
          }
          
          // Headings als Fallback
          if (line.includes('<HEADING1>') || line.includes('<HEADING2>')) {
            const content = line.replace(/<\/?HEADING[12]>/g, '').trim();
            // Pr√ºfe ob es ein Akt ist
            if (/^(ERSTER|ZWEITER|DRITTER|I+V?|V?I*|\d+\.?)\s*(AKT|AUFZUG|TEIL)/i.test(content) || /^\d+\.\s*Akt/i.test(content)) {
              return `<p class="format-akt-titel">${content}</p>`;
            }
            return `<p class="format-szene-titel">${content}</p>`;
          }
          
          if (line.includes('<HEADING3>') || line.includes('<HEADING>')) {
            const content = line.replace(/<\/?HEADING3?>/g, '').trim();
            return `<p class="format-szene-titel">${content}</p>`;
          }
          
          // Kursiv = Regieanweisung (wenn keine anderen Marker)
          if (line.includes('<ITALIC>') && !line.match(/^[A-Z√Ñ√ñ√ú]{2,}[:\.]?\s/)) {
            let content = line.replace(/<\/?ITALIC>/g, '').replace(/<\/?[A-Z]+>/g, '').trim();
            if (!content.startsWith('(')) content = '(' + content;
            if (!content.endsWith(')')) content = content + ')';
            return `<p class="format-regieanweisung">${content}</p>`;
          }
          
          // Restliche Marker entfernen
          line = line.replace(/<\/?[A-Z]+[0-9]*>/g, '').trim();
          if (!line) return '';
          
          // === MUSTER-BASIERTE ERKENNUNG (Fallback) ===
          
          // Dialog (NAME: text)
          const dialogMatch = line.match(/^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü\s\.\-]*?)\s*[:\.]{1}\s*(.+)$/);
          if (dialogMatch && dialogMatch[1].length < 30 && dialogMatch[1].length > 1) {
            return `<div class="format-dialog"><span class="figur-name">${dialogMatch[1].trim()}:</span><span class="dialog-text">${dialogMatch[2]}</span></div>`;
          }
          
          // Regieanweisung (in Klammern)
          if (line.startsWith('(') && line.endsWith(')')) {
            return `<p class="format-regieanweisung">${line}</p>`;
          }
          
          // Akt-Titel
          if (/^(ERSTER|ZWEITER|DRITTER|VIERTER|F√úNFTER|I+V?|V?I*|\d+\.?)\s*(AKT|AUFZUG|TEIL)/i.test(line)) {
            return `<p class="format-akt-titel">${line}</p>`;
          }
          
          // Szenen-Titel (nummeriert)
          if (/^\d+\.\s*(Szene|SZENE)/i.test(line) || /^(SZENE|Szene)\s*\d/i.test(line)) {
            return `<p class="format-szene-titel">${line}</p>`;
          }
          
          // Lied-Erkennung
          if (line.startsWith('üéµ') || /^\s*(singt|singend|Lied)/i.test(line)) {
            return `<p class="format-lied">${line}</p>`;
          }
          
          return `<p class="format-standard">${line}</p>`;
        })
        .filter(Boolean)
        .join('\n');
    }
    
    function doImportText() {
      const content = document.getElementById('import-text-content').value.trim();
      if (!content) {
        alert('Bitte Text einf√ºgen.');
        return;
      }
      
      const titel = document.getElementById('import-text-title').value.trim() || 'Importierter Text';
      const nummer = document.getElementById('import-text-nummer').value.trim() || '1.1';
      const ersetzen = document.getElementById('import-text-replace').checked;
      
      // Text zu HTML konvertieren (einfache Abs√§tze)
      let html = content
        .split(/\n\n+/)  // Abs√§tze bei Leerzeilen
        .map(para => para.trim())
        .filter(para => para)
        .map(para => {
          // Einfache Heuristik f√ºr Dialog-Erkennung
          const dialogMatch = para.match(/^([A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü]*(?:\s+[A-Z√Ñ√ñ√ú][A-Z√Ñ√ñ√úa-z√§√∂√º√ü]*)?)[\s]*[:\.]\s*(.+)$/s);
          if (dialogMatch) {
            const figurName = dialogMatch[1].toUpperCase();
            const text = dialogMatch[2].replace(/\n/g, ' ');
            return `<div class="format-dialog"><span class="figur-name">${figurName}:</span><span class="dialog-text">${text}</span></div>`;
          }
          
          // Regieanweisung in Klammern
          if (para.startsWith('(') && para.endsWith(')')) {
            return `<p class="format-regieanweisung">${para}</p>`;
          }
          
          // Akt-Titel erkennen
          if (/^(ERSTER|ZWEITER|DRITTER|VIERTER|F√úNFTER|I+V?|V?I*)\s*(AKT|AUFZUG|TEIL)/i.test(para)) {
            return `<p class="format-akt-titel">${para}</p>`;
          }
          
          // Szenen-Titel erkennen
          if (/^(SZENE|SCENE|BILD|\d+[\.:])/.test(para)) {
            return `<p class="format-szene-titel">${para}</p>`;
          }
          
          // Sonst Standard
          return `<p>${para.replace(/\n/g, '<br>')}</p>`;
        })
        .join('\n');
      
      if (ersetzen) {
        // Alle Szenen l√∂schen
        state.szenen = [];
        state.textbuch = {};
        state.cues = [];
      }
      
      // Neue Szene erstellen
      const neueSzene = {
        id: genId(),
        nummer: nummer,
        titel: titel,
        ort: '',
        zeit: '',
        gruppe: '1',
        zusammenfassung: 'Importierter Text - bitte bearbeiten',
        figuren: []
      };
      
      state.szenen.push(neueSzene);
      state.textbuch[neueSzene.id] = html;
      state.aktiveSzene = neueSzene.id;
      
      saveProjektDaten();
      closeModal('showImportModal');
      render();
      
      alert(`‚úÖ Text importiert!\n\n${content.split(/\n\n+/).length} Abs√§tze wurden als Szene "${titel}" importiert.\n\nNutze "‚úÇÔ∏è¬è Teilen" in der Toolbar um den Text in mehrere Szenen aufzuteilen.`);
    }
    
    function handleTxtImportFile(input) {
      const file = input.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        document.getElementById('import-text-content').value = e.target.result;
        document.getElementById('import-text-title').value = file.name.replace(/\.[^/.]+$/, '');
      };
      reader.readAsText(file);
    }

    // ============================================
    // GOOGLE DRIVE UI
    // ============================================
    let gdriveImportFiles = [];
    let gdriveImportLoading = false;
    let gdriveSaving = false;
    let gdriveFolderSetup = false;
    
    function renderGdriveImportTab() {
      if (!gdriveIsConnected()) {
        return `
          <div class="text-center py-6">
            <div class="text-4xl mb-3">‚òÅÔ∏è</div>
            <p class="text-sm text-gray-600 mb-4">Mit Google Drive verbinden, um Exchange-Dateien direkt aus einem geteilten Projektordner zu laden.</p>
            <button class="btn btn-primary" onclick="gdriveSignIn()" style="background: #4285f4; border-color: #4285f4;">
              <span style="font-weight: 500;">üîë Mit Google anmelden</span>
            </button>
            <p class="text-xs text-gray-400 mt-3">Deine Daten bleiben in deinem eigenen Google Drive.</p>
          </div>
        `;
      }
      
      // Connected
      let html = `
        <div class="flex items-center justify-between mb-3 p-2 bg-green-50 rounded-lg border border-green-200">
          <div class="flex items-center gap-2">
            <span class="text-green-600">‚úÖ</span>
            <span class="text-sm text-green-800">${gdriveUser?.email || 'Verbunden'}</span>
          </div>
          <button class="text-xs text-gray-400 hover:text-red-500" onclick="gdriveSignOut()">Abmelden</button>
        </div>
      `;
      
      if (!gdriveFolderId) {
        html += `
          <div class="text-center py-4">
            <p class="text-sm text-gray-600 mb-3">W√§hle einen Projektordner auf Google Drive:</p>
            <button class="btn btn-outline" onclick="gdriveShowFolderPicker()">üìÅ Ordner w√§hlen / erstellen</button>
          </div>
        `;
      } else {
        html += `
          <div class="flex items-center gap-2 mb-3 p-2 bg-blue-50 rounded border border-blue-200">
            <span>üìÅ</span>
            <span class="text-sm text-blue-800 flex-1">${gdriveFolderName || 'Ordner'}</span>
            <button class="text-xs text-blue-600 hover:text-blue-800" onclick="gdriveShowFolderPicker()">√Ñndern</button>
          </div>
        `;
        
        if (gdriveImportLoading) {
          html += `<div class="text-center py-4"><div class="text-sm text-gray-500">‚è≥ Dateien werden geladen...</div></div>`;
        } else if (gdriveImportFiles.length === 0) {
          html += `
            <div class="text-center py-4 text-gray-400">
              <p class="text-sm">Keine JSON-Dateien in diesem Ordner gefunden.</p>
              <button class="btn btn-outline btn-sm mt-2" onclick="gdriveRefreshFiles()">üîÑ Aktualisieren</button>
            </div>
          `;
        } else {
          html += `
            <div class="flex items-center justify-between mb-2">
              <p class="text-xs text-gray-500">${gdriveImportFiles.length} Datei(en) gefunden</p>
              <button class="text-xs text-blue-600 hover:text-blue-800" onclick="gdriveRefreshFiles()">üîÑ Aktualisieren</button>
            </div>
            <div style="max-height: 250px; overflow-y: auto;" class="space-y-1">
          `;
          for (const file of gdriveImportFiles) {
            const date = new Date(file.modifiedTime).toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
            const isExchange = file.name.toLowerCase().includes('exchange');
            const isBackup = file.name.toLowerCase().includes('backup');
            const icon = isExchange ? 'üîÑ' : isBackup ? 'üíæ' : 'üìÑ';
            const label = isExchange ? 'Exchange' : isBackup ? 'Backup' : 'JSON';
            html += `
              <div class="border rounded-lg p-2 hover:bg-blue-50 cursor-pointer flex items-center gap-2" onclick="gdriveImportFile('${file.id}', '${file.name.replace(/'/g, "\\'")}')">
                <span>${icon}</span>
                <div class="flex-1 min-w-0">
                  <p class="text-sm font-medium truncate">${file.name}</p>
                  <p class="text-xs text-gray-400">${date}</p>
                </div>
                <span class="text-xs px-2 py-0.5 rounded" style="background: ${isExchange ? '#f3e8ff' : '#ecfdf5'}; color: ${isExchange ? '#7c3aed' : '#059669'};">${label}</span>
              </div>
            `;
          }
          html += `</div>`;
        }
      }
      
      html += `
        <div class="flex gap-2 mt-4">
          <button class="btn btn-outline flex-1" onclick="closeModal('showImportModal')">Schliessen</button>
        </div>
      `;
      return html;
    }
    
    async function gdriveRefreshFiles() {
      gdriveImportLoading = true;
      render();
      try {
        gdriveImportFiles = await gdriveListFiles();
      } catch (err) {
        alert('‚ùå Fehler: ' + err.message);
        gdriveImportFiles = [];
      }
      gdriveImportLoading = false;
      render();
      // Re-open the import modal and switch to drive tab
      openModal('showImportModal');
      setTimeout(() => showImportTab('gdrive'), 50);
    }
    
    async function gdriveImportFile(fileId, fileName) {
      try {
        const data = await gdriveLoadFile(fileId);
        
        if (data.format === 'nina-exchange') {
          // Exchange-Import
          pendingNinaImportData = data;
          document.getElementById('import-nina-name').textContent = '‚úÖ ' + fileName;
          document.getElementById('import-nina-btn').disabled = false;
          
          // Preview anzeigen
          let details = [];
          if (data.figures?.length) details.push(`üë§ ${data.figures.length} Figuren`);
          if (data.scenes?.length) details.push(`üé¨ ${data.scenes.length} Szenen`);
          if (data.persons?.length) details.push(`üë• ${data.persons.length} Personen`);
          if (data.rehearsals?.length) details.push(`üìÖ ${data.rehearsals.length} Proben`);
          if (data.konzept) details.push('üìã Konzept');
          if (data.recherche?.length) details.push(`üîç ${data.recherche.length} Recherche`);
          if (data.beziehungen?.length) details.push(`üîó ${data.beziehungen.length} Beziehungen`);
          
          showImportTab('nina');
          setTimeout(() => {
            const previewEl = document.getElementById('import-nina-preview');
            const detailsEl = document.getElementById('import-nina-details');
            if (previewEl && detailsEl) {
              previewEl.style.display = 'block';
              detailsEl.innerHTML = details.join('<br>');
            }
          }, 50);
        } else if (data.projektId || data.figuren) {
          // Backup-Import ‚Äì direkt verarbeiten
          if (confirm(`üíæ Backup "${fileName}" laden?\n\nDies √ºberschreibt das aktuelle Projekt.`)) {
            importFromDramera(data);
            closeModal('showImportModal');
            alert('‚úÖ Backup erfolgreich geladen!');
          }
        } else {
          alert('‚ö†Ô∏è Unbekanntes Dateiformat: ' + fileName);
        }
      } catch (err) {
        alert('‚ùå Fehler beim Laden: ' + err.message);
      }
    }
    
    function gdriveOnConnected() {
      if (gdriveFolderId) {
        gdriveRefreshFiles();
      }
    }
    
    async function gdriveShowFolderPicker() {
      console.log('GDrive: Folder Picker ge√∂ffnet, Token:', !!gdriveToken);
      gdriveFolderSetup = true;
      
      try {
        // Suche nach NiNA-Ordnern
        let folders = [];
        try {
          folders = await gdriveListFolders();
        } catch(e) {
          console.warn('Keine NiNA-Ordner gefunden:', e);
        }
        
        let html = `<div style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10000;display:flex;align-items:center;justify-content:center;" onclick="if(event.target===this) document.getElementById('gdrive-folder-modal').remove()">
          <div style="background:white;border-radius:12px;padding:24px;max-width:450px;width:90%;max-height:80vh;overflow-y:auto;box-shadow:0 20px 60px rgba(0,0,0,0.3);" onclick="event.stopPropagation()">
            <h3 style="font-size:18px;font-weight:600;margin-bottom:16px;">üìÅ Projektordner w√§hlen</h3>
        `;
        
        if (folders.length > 0) {
          html += `<p style="font-size:13px;color:#6b7280;margin-bottom:12px;">Bestehende NiNA-Ordner:</p><div style="display:flex;flex-direction:column;gap:4px;margin-bottom:16px;">`;
          for (const f of folders) {
            html += `
              <div style="border:1px solid #e5e7eb;border-radius:8px;padding:12px;cursor:pointer;display:flex;align-items:center;gap:8px;" 
                   onmouseover="this.style.background='#eff6ff'" onmouseout="this.style.background='white'"
                   onclick="gdriveSelectFolder('${f.id}', '${f.name.replace(/'/g, "\\'")}')">
                <span>üìÅ</span>
                <span style="font-size:14px;flex:1;">${f.name}</span>
              </div>
            `;
            // Sub-Ordner laden
            try {
              const subs = await gdriveListProjectFolders(f.id);
              for (const sub of subs) {
                html += `
                  <div style="border:1px solid #e5e7eb;border-radius:8px;padding:12px;cursor:pointer;display:flex;align-items:center;gap:8px;margin-left:24px;" 
                       onmouseover="this.style.background='#eff6ff'" onmouseout="this.style.background='white'"
                       onclick="gdriveSelectFolder('${sub.id}', '${f.name} / ${sub.name.replace(/'/g, "\\'")}')">
                    <span>üìÇ</span>
                    <span style="font-size:14px;flex:1;">${sub.name}</span>
                  </div>
                `;
              }
            } catch(e) { console.warn('Sub-Ordner Fehler:', e); }
          }
          html += `</div><hr style="margin:12px 0;">`;
        }
        
        html += `
            <p style="font-size:13px;color:#6b7280;margin-bottom:12px;">Neuen Ordner erstellen:</p>
            <div style="display:flex;gap:8px;margin-bottom:8px;">
              <input type="text" id="gdrive-new-folder" placeholder="z.B. NiNA Projekte" value="NiNA Projekte" style="flex:1;padding:8px 12px;border:1px solid #d1d5db;border-radius:6px;font-size:14px;">
              <button onclick="gdriveCreateNewFolder()" style="padding:8px 16px;background:#4285f4;color:white;border:none;border-radius:6px;font-size:14px;cursor:pointer;">Erstellen</button>
            </div>
            <p style="font-size:11px;color:#9ca3af;margin-bottom:16px;">Tipp: Erstelle zuerst "NiNA Projekte", dann darin Unterordner f√ºr jedes Projekt.</p>
            <button onclick="document.getElementById('gdrive-folder-modal').remove()" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px;background:white;font-size:14px;cursor:pointer;">Abbrechen</button>
          </div>
        </div>`;
        
        // Altes Modal entfernen falls vorhanden
        const old = document.getElementById('gdrive-folder-modal');
        if (old) old.remove();
        
        const modal = document.createElement('div');
        modal.id = 'gdrive-folder-modal';
        modal.innerHTML = html;
        document.body.appendChild(modal);
        
      } catch (err) {
        console.error('Folder picker error:', err);
        alert('‚ùå Fehler beim Laden der Ordner: ' + err.message);
      }
      gdriveFolderSetup = false;
    }
    
    async function gdriveSelectFolder(id, name) {
      await gdriveSetFolder(id, name);
      const modal = document.getElementById('gdrive-folder-modal');
      if (modal) modal.remove();
      gdriveRefreshFiles();
    }
    
    async function gdriveCreateNewFolder() {
      const nameInput = document.getElementById('gdrive-new-folder');
      const name = nameInput?.value?.trim();
      if (!name) { alert('Bitte einen Namen eingeben'); return; }
      
      try {
        const folder = await gdriveCreateFolder(name);
        await gdriveSetFolder(folder.id, name);
        const modal = document.getElementById('gdrive-folder-modal');
        if (modal) modal.remove();
        alert('‚úÖ Ordner "' + name + '" erstellt!');
        gdriveRefreshFiles();
      } catch (err) {
        alert('‚ùå Fehler: ' + err.message);
      }
    }
    
    // ---- DRIVE EXPORT ----
    async function gdriveSaveExchange() {
      if (!gdriveIsConnected()) { gdriveSignIn(); return; }
      if (!gdriveFolderId) { gdriveShowFolderPicker(); return; }
      
      gdriveSaving = true;
      render();
      
      try {
        const exchangeData = buildNinaExchangeData();
        const projektName = (state.projektMeta.titel || 'Projekt').replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√©√®√™√†√°√¢\s\-_]/g, '').replace(/\s+/g, '_');
        const fileName = projektName + '_Rebu_Exchange.json';
        
        await gdriveSaveFile(fileName, exchangeData);
        alert('‚úÖ Exchange-Datei gespeichert!\n\nüìÅ ' + gdriveFolderName + '\nüìÑ ' + fileName);
      } catch (err) {
        alert('‚ùå Speichern fehlgeschlagen: ' + err.message);
      }
      
      gdriveSaving = false;
      render();
    }
    
    async function gdriveSaveBackup() {
      if (!gdriveIsConnected()) { gdriveSignIn(); return; }
      if (!gdriveFolderId) { gdriveShowFolderPicker(); return; }
      
      gdriveSaving = true;
      render();
      
      try {
        const backupData = exportToDramera();
        const projektName = (state.projektMeta.titel || 'Projekt').replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√©√®√™√†√°√¢\s\-_]/g, '').replace(/\s+/g, '_');
        const fileName = projektName + '_Rebu_Backup.json';
        
        await gdriveSaveFile(fileName, backupData);
        alert('‚úÖ Backup gespeichert!\n\nüìÅ ' + gdriveFolderName + '\nüìÑ ' + fileName);
      } catch (err) {
        alert('‚ùå Speichern fehlgeschlagen: ' + err.message);
      }
      
      gdriveSaving = false;
      render();
    }
    
    function renderExportModal() {
      const aktiveSzene = state.szenen.find(s => s.id === state.aktiveSzene);
      
      // Cue-Typ-Z√§hlung
      const lxCount = state.cues.filter(c => c.typ === 'lx').length;
      const qCount = state.cues.filter(c => c.typ === 'q').length;
      const vCount = state.cues.filter(c => c.typ === 'v').length;
      const rCueCount = state.cues.filter(c => c.typ === 'r').length;
      const uCount = state.cues.filter(c => c.typ === 'u').length;
      const hasCues = state.cues.length > 0;
      const hasRequisiten = state.requisiten.length > 0;
      const hasKostueme = state.kostueme.length > 0;
      const hasBuehne = state.buehne.length > 0;
      const hasListen = hasCues || hasRequisiten || hasKostueme || hasBuehne;
      
      return `
        <div class="modal-overlay" onclick="closeModal('showExportModal')">
          <div class="modal-content" style="max-width: 550px; max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">Exportieren</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showExportModal')">x</button>
            </div>
            <div class="modal-body">
              <div class="bg-gray-50 rounded-lg p-3 mb-4">
                <p class="font-medium">${state.projektMeta.titel}</p>
                <p class="text-xs text-gray-500">
                  ${state.szenen.length} Szenen ¬∑ ${state.figuren.length} Figuren ¬∑ ${state.cues.length} Cues ¬∑ ${state.requisiten.length} Requisiten
                </p>
              </div>
              
              <div class="border-2 border-blue-200 rounded-lg p-4 mb-4 bg-blue-50">
                <p class="text-xs font-bold text-blue-400 uppercase tracking-wide mb-2">Textexport</p>
                
                <div class="mb-3">
                  <label style="font-size: 11px; color: #1d4ed8; font-weight: 500;">Was exportieren?</label>
                  <select id="export-szenen-auswahl" style="width: 100%; margin-top: 4px; font-size: 13px; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px;" onchange="document.getElementById('export-szenen-liste').style.display = this.value === 'auswahl' ? 'block' : 'none'">
                    <option value="alle">Ganzes St√ºck (alle ${state.szenen.length} Szenen)</option>
                    ${aktiveSzene ? `<option value="aktuelle">Nur aktuelle Szene (${aktiveSzene.nummer} ${aktiveSzene.titel})</option>` : ''}
                    <option value="auswahl">Szenen ausw√§hlen...</option>
                  </select>
                </div>
                
                <div id="export-szenen-liste" style="display: none; max-height: 150px; overflow-y: auto; border: 1px solid #bfdbfe; border-radius: 4px; padding: 8px; margin-bottom: 12px; background: white;">
                  ${state.szenen.map(s => `
                    <div style="display: block; font-size: 12px; padding: 4px 0;">
                      <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="export-szene-check" value="${s.id}" checked style="width: 14px; height: 14px; margin-right: 8px; flex-shrink: 0;">
                        <span>${s.nummer} ${s.titel}</span>
                      </label>
                    </div>
                  `).join('')}
                </div>
                
                <div class="flex gap-2">
                  <button class="btn btn-sm btn-primary flex-1" onclick="exportTextfassungWord()">
                    Textfassung (.docx)
                  </button>
                  <button class="btn btn-sm btn-outline flex-1" onclick="exportTextfassungPDF()">
                    PDF (Druck)
                  </button>
                </div>
                ${hasCues ? `
                <div class="mt-2">
                  <button class="btn btn-sm w-full" style="background: #7c3aed; color: white;" onclick="exportTechnikfassungWord()">
                    Technikfassung (.docx)
                  </button>
                </div>
                ` : ''}
              </div>
              
              ${hasListen ? `
              <div class="border-2 border-gray-200 rounded-lg p-4 mb-4">
                <p class="text-xs font-bold text-gray-400 uppercase tracking-wide mb-3">Einzellisten</p>
                <div class="grid grid-cols-2 gap-2">
                  ${lxCount > 0 ? `
                  <button class="btn btn-sm btn-outline text-left flex items-center gap-2" onclick="exportCueByType('lx')">
                    <span style="background:#fef3c7;color:#92400e;padding:1px 6px;border-radius:8px;font-size:10px;font-weight:bold;">LX</span>
                    <span>Licht (${lxCount})</span>
                  </button>` : ''}
                  ${qCount > 0 ? `
                  <button class="btn btn-sm btn-outline text-left flex items-center gap-2" onclick="exportCueByType('q')">
                    <span style="background:#d1fae5;color:#065f46;padding:1px 6px;border-radius:8px;font-size:10px;font-weight:bold;">Q</span>
                    <span>Ton (${qCount})</span>
                  </button>` : ''}
                  ${vCount > 0 ? `
                  <button class="btn btn-sm btn-outline text-left flex items-center gap-2" onclick="exportCueByType('v')">
                    <span style="background:#e0e7ff;color:#3730a3;padding:1px 6px;border-radius:8px;font-size:10px;font-weight:bold;">V</span>
                    <span>Video (${vCount})</span>
                  </button>` : ''}
                  ${rCueCount > 0 ? `
                  <button class="btn btn-sm btn-outline text-left flex items-center gap-2" onclick="exportCueByType('r')">
                    <span style="background:#fce7f3;color:#9d174d;padding:1px 6px;border-radius:8px;font-size:10px;font-weight:bold;">R</span>
                    <span>Req.-Cues (${rCueCount})</span>
                  </button>` : ''}
                  ${uCount > 0 ? `
                  <button class="btn btn-sm btn-outline text-left flex items-center gap-2" onclick="exportCueByType('u')">
                    <span style="background:#fed7aa;color:#9a3412;padding:1px 6px;border-radius:8px;font-size:10px;font-weight:bold;">U</span>
                    <span>Umbau (${uCount})</span>
                  </button>` : ''}
                  ${hasRequisiten ? `
                  <button class="btn btn-sm btn-outline text-left flex items-center gap-2" onclick="exportRequisitenList()">
                    <span>Requisiten (${state.requisiten.length})</span>
                  </button>` : ''}
                  ${hasKostueme ? `
                  <button class="btn btn-sm btn-outline text-left flex items-center gap-2" onclick="exportKostuemeList()">
                    <span>Kost√ºme (${state.kostueme.length})</span>
                  </button>` : ''}
                  ${hasBuehne ? `
                  <button class="btn btn-sm btn-outline text-left flex items-center gap-2" onclick="exportBuehneList()">
                    <span>B√ºhne (${state.buehne.length})</span>
                  </button>` : ''}
                </div>
                ${hasCues ? `
                <button class="btn btn-sm btn-outline w-full mt-2 text-xs" onclick="exportCueByType('alle')">
                  Alle Cue-Listen kombiniert (${state.cues.length})
                </button>` : ''}
              </div>
              ` : ''}
              
              <div class="space-y-2">
                <p class="text-xs font-bold text-gray-400 uppercase tracking-wide mb-1">Datenaustausch</p>
                
                <div class="border-2 border-green-400 rounded-lg p-3 bg-green-50 hover:bg-green-100 cursor-pointer" onclick="downloadDrameraExport()">
                  <div class="flex items-center gap-3">
                    <div class="flex-1">
                      <p class="font-medium text-green-800 text-sm">Projekt-Backup (.json)</p>
                      <p class="text-xs text-green-700">Vollst√§ndige Sicherung ‚Äì kann wieder importiert werden</p>
                    </div>
                    <span class="px-2 py-0.5 bg-green-600 text-white text-xs font-bold rounded">SICHER</span>
                  </div>
                </div>
                
                <div class="border-2 rounded-lg p-3 hover:opacity-90 cursor-pointer" style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(168,113,89,0.15)); border-color: #a87159;" onclick="exportForDramera()">
                  <div class="flex items-center gap-3">
                    <div>
                      <p class="font-medium text-sm" style="color: #78350f;">F√ºr Dramera / Propla</p>
                      <p class="text-xs" style="color: #92400e;">NINA-Exchange ‚Äì f√ºr Werkbank & Probenplanung</p>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Google Drive -->
              <div class="border-2 border-blue-300 rounded-lg p-4 mb-4" style="background: linear-gradient(135deg, rgba(66,133,244,0.05), rgba(52,168,83,0.05));">
                <p class="text-xs font-bold text-blue-500 uppercase tracking-wide mb-2">‚òÅÔ∏è Google Drive</p>
                ${gdriveIsConnected() ? `
                  <div class="flex items-center gap-2 mb-3 text-xs text-green-700">
                    <span>‚úÖ ${gdriveUser?.email || 'Verbunden'}</span>
                    ${gdriveFolderName ? `<span class="text-gray-400">¬∑</span> <span>üìÅ ${gdriveFolderName}</span>` : ''}
                  </div>
                  ${gdriveFolderId ? `
                    <div class="space-y-2">
                      <button class="btn btn-sm w-full" style="background: #4285f4; color: white; border: none;" onclick="gdriveSaveExchange()" ${gdriveSaving ? 'disabled' : ''}>
                        ${gdriveSaving ? '‚è≥ Speichern...' : '‚òÅÔ∏è Exchange in Drive speichern'}
                      </button>
                      <button class="btn btn-sm btn-outline w-full text-xs" onclick="gdriveSaveBackup()" ${gdriveSaving ? 'disabled' : ''}>
                        ${gdriveSaving ? '‚è≥ ...' : 'üíæ Backup in Drive speichern'}
                      </button>
                    </div>
                  ` : `
                    <button class="btn btn-sm btn-outline w-full" onclick="gdriveShowFolderPicker()">üìÅ Erst Ordner w√§hlen</button>
                  `}
                ` : `
                  <p class="text-xs text-gray-500 mb-2">Exchange-Dateien direkt in einen geteilten Projektordner speichern.</p>
                  <button class="btn btn-sm w-full" style="background: #4285f4; color: white; border: none;" onclick="gdriveSignIn()">
                    üîë Mit Google anmelden
                  </button>
                `}
              </div>
              
              <button class="btn btn-outline w-full mt-4" onclick="closeModal('showExportModal')">Schliessen</button>
            </div>
          </div>
        </div>
      `;
    }

    
    // Gew√§hlte Szenen f√ºr Export ermitteln
    function getExportSzenen() {
      const select = document.getElementById('export-szenen-auswahl');
      if (!select) return state.szenen;
      
      switch (select.value) {
        case 'aktuelle':
          const aktuelle = state.szenen.find(s => s.id === state.aktiveSzene);
          return aktuelle ? [aktuelle] : state.szenen;
        case 'auswahl':
          const checks = document.querySelectorAll('.export-szene-check:checked');
          const ids = Array.from(checks).map(c => c.value);
          return state.szenen.filter(s => ids.includes(s.id));
        default:
          return state.szenen;
      }
    }
    
    // ============================================
    // TEXTFASSUNG EXPORT (Word & PDF)
    // ============================================
    
    function generateTextfassungHTML(szenenFilter = null) {
      const meta = state.projektMeta;
      const exportSzenen = szenenFilter || getExportSzenen();
      const eigeneGruppen = meta.eigeneGruppen || ['Erster Akt'];
      
      // Pr√ºfen ob vollst√§ndiger Export oder nur einzelne Szenen
      const istVollstaendig = exportSzenen.length === state.szenen.length;
      const istEinzelszene = exportSzenen.length === 1;
      
      // Szenen nach Gruppen sortieren (nur exportierte Szenen)
      const szenenNachGruppen = {};
      eigeneGruppen.forEach(g => { szenenNachGruppen[g] = []; });
      exportSzenen.forEach(s => {
        const gruppe = s.gruppe || eigeneGruppen[0] || 'Ohne Gruppe';
        if (!szenenNachGruppen[gruppe]) szenenNachGruppen[gruppe] = [];
        szenenNachGruppen[gruppe].push(s);
      });
      
      // HTML generieren
      let html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${meta.titel || 'Regiebuch'}</title>
  <style>
    @page { 
      size: A4; 
      margin: 2.5cm 2cm;
    }
    body { 
      font-family: 'Times New Roman', Times, serif;
      font-size: 12pt;
      line-height: 1.5;
      color: #000;
    }
    
    /* Titelseite */
    .titelseite {
      page-break-after: always;
      text-align: center;
      padding-top: 2cm;
    }
    .titelseite .titelbild {
      max-width: 14cm;
      max-height: 10cm;
      width: auto;
      height: auto;
      object-fit: contain;
      margin-bottom: 1.5cm;
    }
    .titelseite h1 {
      font-size: 28pt;
      margin-bottom: 0.5cm;
      text-transform: uppercase;
    }
    .titelseite .untertitel {
      font-size: 16pt;
      font-style: italic;
      margin-bottom: 2cm;
    }
    .titelseite .autor {
      font-size: 14pt;
      margin-bottom: 1cm;
    }
    .titelseite .logline {
      font-size: 11pt;
      font-style: italic;
      max-width: 12cm;
      margin: 2cm auto;
      text-align: center;
    }
    .titelseite .meta {
      font-size: 10pt;
      color: #666;
      margin-top: 2cm;
    }
    
    /* Figurenliste */
    .figurenliste {
      page-break-before: always;
      page-break-after: always;
    }
    .figurenliste h2 {
      font-size: 16pt;
      border-bottom: 2px solid #000;
      padding-bottom: 0.3cm;
      margin-bottom: 1cm;
    }
    .figur-eintrag {
      margin-bottom: 0.8cm;
    }
    .figur-eintrag .name {
      font-weight: bold;
      text-transform: uppercase;
    }
    .figur-eintrag .beschreibung {
      margin-left: 1cm;
      font-style: italic;
    }
    
    /* Szenen */
    .szenen-inhalt h2 {
      font-size: 18pt;
      text-align: center;
      margin: 2cm 0 1cm;
      page-break-before: always;
    }
    .szene {
      margin-bottom: 1.5cm;
    }
    .szene-header {
      font-weight: bold;
      font-size: 14pt;
      border-bottom: 1px solid #999;
      padding-bottom: 0.2cm;
      margin-bottom: 0.5cm;
    }
    .szene-meta {
      font-size: 10pt;
      color: #666;
      font-style: italic;
      margin-bottom: 0.5cm;
    }
    
    /* Dialog Export Format */
    .dialog-export {
      margin: 0.2cm 0;
    }
    .dialog-export b {
      font-weight: bold;
      text-transform: uppercase;
    }
    
    /* Fallback f√ºr format-dialog falls nicht konvertiert */
    .format-dialog {
      margin: 0.3cm 0;
    }
    .format-dialog .figur-name {
      font-weight: bold;
      text-transform: uppercase;
    }
    .figur-name {
      font-weight: bold;
      text-transform: uppercase;
    }
    
    .format-regieanweisung {
      font-style: italic;
      margin: 0.3cm 0;
      margin-left: 3.3cm;
      color: #444;
    }
    .format-szene-titel {
      font-weight: bold;
      font-size: 14pt;
      margin: 1cm 0 0.5cm;
      border-bottom: 1px solid #ccc;
    }
    .format-akt-titel {
      font-weight: bold;
      font-size: 18pt;
      text-align: center;
      margin: 2cm 0 1cm;
      text-transform: uppercase;
    }
    .format-lied {
      font-style: italic;
      margin: 0.05cm 0;
      margin-left: 2cm;
      color: #333;
    }
    .format-vers {
      margin: 0.05cm 0;
      margin-left: 2cm;
      font-style: italic;
    }
    .format-pause {
      text-align: center;
      font-weight: bold;
      margin: 1.5cm 0;
      font-size: 14pt;
    }
    .format-standard {
      margin: 0.3cm 0;
    }
    
    /* Cue-Markierungen entfernen f√ºr Druck */
    .cue-marker { display: none; }
    
    @media print {
      body { font-size: 11pt; }
    }
  </style>
</head>
<body>
  
  ${istVollstaendig ? `
  <!-- TITELSEITE -->
  <div class="titelseite">
    ${meta.titelbild ? `<img src="${meta.titelbild}" class="titelbild" alt="Titelbild">` : ''}
    <h1>${meta.titel || 'Ohne Titel'}</h1>
    ${meta.untertitel ? `<div class="untertitel">${meta.untertitel}</div>` : ''}
    ${meta.autor ? `<div class="autor">von ${meta.autor}</div>` : ''}
    ${meta.tagline ? `<div style="font-size: 12pt; margin-top: 1cm;">${meta.tagline}</div>` : ''}
    ${meta.logline ? `<div class="logline">${meta.logline}</div>` : ''}
    <div class="meta">
      ${meta.fassung || 'Arbeitsfassung'}<br>
      ${meta.fassungsDatum ? formatDateTime(new Date(meta.fassungsDatum)) : formatDateTime(new Date())}<br>
      ${meta.spielort ? `Spielort: ${meta.spielort}` : ''}
      ${meta.premiere ? `<br>Premiere: ${new Date(meta.premiere).toLocaleDateString('de-CH')}` : ''}
      ${meta.copyright ? `<br>${meta.copyright}` : ''}
    </div>
  </div>
  
  <!-- FIGURENLISTE -->
  ${state.figuren.length > 0 ? `
    <div class="figurenliste">
      <h2>Figuren</h2>
      ${state.figuren.map(f => `
        <div class="figur-eintrag">
          <span class="name">${f.name}</span>${f.kuerzel ? ` (${f.kuerzel})` : ''}
          ${f.beschreibung ? `<div class="beschreibung">${f.beschreibung}</div>` : ''}
        </div>
      `).join('')}
    </div>
  ` : ''}
  ` : `
  <!-- TEILEXPORT HEADER -->
  <div style="margin-bottom: 1cm;">
    <p style="font-size: 10pt; color: #666;">${meta.titel || 'Regiebuch'} ‚Äì Auszug (${exportSzenen.length} ${exportSzenen.length === 1 ? 'Szene' : 'Szenen'})</p>
  </div>
  `}
  
  <!-- SZENEN -->
  <div class="szenen-inhalt">
    ${istVollstaendig ? eigeneGruppen.map(gruppe => {
      const szenen = szenenNachGruppen[gruppe] || [];
      if (szenen.length === 0) return '';
      
      return `
        <h2>${gruppe}</h2>
        ${szenen.map(szene => {
          let content = state.textbuch[szene.id] || '';
          // Cue-Marker entfernen
          content = content.replace(/<span class="cue-marker[^"]*"[^>]*>[^<]*<\/span>/g, '');
          // Szenen-Titel aus Content entfernen (wird schon im Header angezeigt)
          content = content.replace(/<p[^>]*class\s*=\s*["']format-szene-titel["'][^>]*>[\s\S]*?<\/p>/gi, '');
          // Dialoge Word-kompatibel machen
          content = makeDialogsWordCompatible(content);
          
          return `
            <div class="szene">
              <div class="szene-header">${szene.nummer} ${szene.titel}</div>
              ${(szene.ort || szene.zeit) ? `
                <div class="szene-meta">
                  ${szene.ort ? `Ort: ${szene.ort}` : ''}
                  ${szene.ort && szene.zeit ? ' ¬∑ ' : ''}
                  ${szene.zeit ? `Zeit: ${szene.zeit}` : ''}
                </div>
              ` : ''}
              ${szene.zusammenfassung ? `<div style="font-style:italic;color:#999;font-size:10pt;margin:0.2cm 0 0.4cm;">${szene.zusammenfassung.length > 250 ? szene.zusammenfassung.substring(0,250) + '...' : szene.zusammenfassung}</div>` : ''}
              <div class="szene-text">${content}</div>
            </div>
          `;
        }).join('')}
      `;
    }).join('') : exportSzenen.map(szene => {
      let content = state.textbuch[szene.id] || '';
      // Cue-Marker entfernen
      content = content.replace(/<span class="cue-marker[^"]*"[^>]*>[^<]*<\/span>/g, '');
      // Szenen-Titel aus Content entfernen (wird schon im Header angezeigt)
      content = content.replace(/<p[^>]*class\s*=\s*["']format-szene-titel["'][^>]*>[\s\S]*?<\/p>/gi, '');
      // Dialoge Word-kompatibel machen
      content = makeDialogsWordCompatible(content);
      
      return `
        <div class="szene">
          <div class="szene-header">${szene.nummer} ${szene.titel}</div>
          ${(szene.ort || szene.zeit) ? `
            <div class="szene-meta">
              ${szene.ort ? `Ort: ${szene.ort}` : ''}
              ${szene.ort && szene.zeit ? ' ¬∑ ' : ''}
              ${szene.zeit ? `Zeit: ${szene.zeit}` : ''}
            </div>
          ` : ''}
          ${szene.zusammenfassung ? `<div style="font-style:italic;color:#999;font-size:10pt;margin:0.2cm 0 0.4cm;">${szene.zusammenfassung.length > 250 ? szene.zusammenfassung.substring(0,250) + '...' : szene.zusammenfassung}</div>` : ''}
          <div class="szene-text">${content}</div>
        </div>
      `;
    }).join('')}
  </div>
  
</body>
</html>`;
      
      return html;
    }
    
    // Dialoge f√ºr Word/PDF-Export kompatibel machen - als Tabelle f√ºr korrekte Ausrichtung
    function makeDialogsWordCompatible(html) {
      // format-dialog divs in einfache Paragraphen umwandeln
      // Von: <div class="format-dialog"><span class="figur-name">NAME:</span><span class="dialog-text">Text</span></div>
      // Zu:  <p class="dialog-export"><b>NAME:</b> Text</p>
      
      let result = html.replace(
        /<div[^>]*class\s*=\s*["']format-dialog["'][^>]*>([\s\S]*?)<\/div>/gi,
        function(match, innerContent) {
          // Figur-Name extrahieren
          const nameMatch = innerContent.match(/<span[^>]*class\s*=\s*["']figur-name["'][^>]*>([\s\S]*?)<\/span>/i);
          const textMatch = innerContent.match(/<span[^>]*class\s*=\s*["']dialog-text["'][^>]*>([\s\S]*?)<\/span>/i);
          
          if (nameMatch && textMatch) {
            return '<p class="dialog-export"><b>' + nameMatch[1] + '</b> ' + textMatch[1] + '</p>';
          }
          return match; // Fallback: Original behalten
        }
      );
      
      return result;
    }
    
    function exportTextfassungWord() {
      exportDocx(false);
    }
    
    function exportTechnikfassungWord() {
      exportDocx(true);
    }
    
    async function exportDocx(includeCues) {
      const meta = state.projektMeta;
      const exportSzenen = getExportSzenen();
      const istVollstaendig = exportSzenen.length === state.szenen.length;
      
      const { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell, 
              WidthType, AlignmentType, HeadingLevel, BorderStyle, 
              PageBreak, Header, Footer, ImageRun } = docx;
      
      const children = [];
      
      // === TITELSEITE (nur bei vollstaendigem Export) ===
      if (istVollstaendig) {
        children.push(new Paragraph({ spacing: { before: 2000 }, children: [] }));
        
        // Titelbild einf√ºgen wenn vorhanden
        if (meta.titelbild) {
          try {
            const base64Match = meta.titelbild.match(/^data:image\/(png|jpe?g|gif|webp|bmp);base64,(.+)$/i);
            if (base64Match) {
              const mimeSubtype = base64Match[1].toLowerCase();
              const base64Data = base64Match[2];
              const binaryStr = atob(base64Data);
              const bytes = new Uint8Array(binaryStr.length);
              for (let i = 0; i < binaryStr.length; i++) bytes[i] = binaryStr.charCodeAt(i);
              
              // Bildgr√∂sse ermitteln via tempor√§res Image
              const imgDims = await new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight });
                img.onerror = () => resolve(null);
                img.src = meta.titelbild;
              });
              
              if (imgDims) {
                // Max 14cm breit, 10cm hoch (in EMU: 1cm = 360000)
                const maxW = 14 * 360000;
                const maxH = 10 * 360000;
                let w = imgDims.w * 9525; // px to EMU
                let h = imgDims.h * 9525;
                const scale = Math.min(1, maxW / w, maxH / h);
                w = Math.round(w * scale);
                h = Math.round(h * scale);
                
                children.push(new Paragraph({
                  children: [new ImageRun({
                    data: bytes,
                    transformation: { width: Math.round(w / 9525), height: Math.round(h / 9525) },
                    type: mimeSubtype === 'png' ? 'png' : 'jpg'
                  })],
                  alignment: AlignmentType.CENTER,
                  spacing: { after: 400 }
                }));
              }
            }
          } catch (e) {
            console.warn('Titelbild konnte nicht in Word eingef√ºgt werden:', e);
          }
        }
        
        children.push(new Paragraph({
          children: [new TextRun({ text: meta.titel || 'Ohne Titel', bold: true, size: 56 })],
          alignment: AlignmentType.CENTER,
          spacing: { after: 200 }
        }));
        
        if (meta.untertitel) {
          children.push(new Paragraph({
            children: [new TextRun({ text: meta.untertitel, italics: true, size: 28 })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 }
          }));
        }
        
        if (meta.autor) {
          children.push(new Paragraph({
            children: [new TextRun({ text: 'von ' + meta.autor, size: 24 })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 300 }
          }));
        }
        
        if (meta.tagline) {
          children.push(new Paragraph({
            children: [new TextRun({ text: String.fromCharCode(171) + meta.tagline + String.fromCharCode(187), italics: true, size: 22 })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 }
          }));
        }
        
        if (meta.logline) {
          children.push(new Paragraph({
            children: [new TextRun({ text: meta.logline, size: 20, color: '555555' })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 }
          }));
        }
        
        const metaLines = [];
        if (meta.fassung) metaLines.push(meta.fassung);
        if (meta.premiere) metaLines.push('Premiere: ' + meta.premiere);
        if (meta.spielort) metaLines.push('Spielort: ' + meta.spielort);
        if (meta.copyright) metaLines.push(meta.copyright);
        metaLines.push(formatDateTime(new Date()));
        if (includeCues) metaLines.push('TECHNIKFASSUNG (mit Cues)');
        
        children.push(new Paragraph({
          children: metaLines.map((line, i) => {
            const runs = [new TextRun({ text: line, size: 20, color: '666666' })];
            if (i < metaLines.length - 1) runs.push(new TextRun({ break: 1 }));
            return runs;
          }).flat(),
          alignment: AlignmentType.CENTER,
          spacing: { before: 400 }
        }));
        
        children.push(new Paragraph({ children: [new PageBreak()] }));
        
        // === FIGURENLISTE ===
        if (state.figuren.length > 0) {
          children.push(new Paragraph({
            text: 'Figuren',
            heading: HeadingLevel.HEADING_1,
            spacing: { after: 200 }
          }));
          
          state.figuren.forEach(f => {
            const runs = [new TextRun({ text: f.name, bold: true, size: 24 })];
            if (f.kuerzel) runs.push(new TextRun({ text: ' (' + f.kuerzel + ')', size: 24 }));
            if (f.beschreibung) runs.push(new TextRun({ text: ' ‚Äì ' + f.beschreibung, italics: true, size: 22 }));
            children.push(new Paragraph({ children: runs, spacing: { after: 80 } }));
          });
          
          children.push(new Paragraph({ spacing: { before: 300 }, children: [] }));
        }
        
        // === SZENEN-UEBERSICHT ===
        children.push(new Paragraph({
          text: 'Szenen√ºbersicht',
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }));
        
        exportSzenen.forEach(szene => {
          const figurenNamen = (szene.figuren || []).map(fId => {
            const fig = state.figuren.find(f => f.id === fId);
            return fig ? fig.name : '';
          }).filter(Boolean).join(', ');
          
          const headerRuns = [new TextRun({ text: szene.nummer + ' ', bold: true, size: 22 })];
          headerRuns.push(new TextRun({ text: szene.titel || '', bold: true, size: 22 }));
          if (szene.ort || szene.zeit) {
            headerRuns.push(new TextRun({ text: '  ‚Äì  ' + [szene.ort, szene.zeit].filter(Boolean).join(' / '), size: 20, color: '666666' }));
          }
          children.push(new Paragraph({ children: headerRuns, spacing: { before: 100, after: 20 } }));
          
          if (figurenNamen) {
            children.push(new Paragraph({
              children: [new TextRun({ text: 'Figuren: ' + figurenNamen, size: 18, color: '888888' })],
              spacing: { after: 20 },
              indent: { left: 400 }
            }));
          }
          
          if (szene.zusammenfassung) {
            const kurzText = szene.zusammenfassung.length > 250 
              ? szene.zusammenfassung.substring(0, 250) + '...' 
              : szene.zusammenfassung;
            children.push(new Paragraph({
              children: [new TextRun({ text: kurzText, italics: true, size: 18, color: '999999' })],
              spacing: { after: 60 },
              indent: { left: 400 }
            }));
          }
        });
        
        children.push(new Paragraph({ children: [new PageBreak()] }));
        
        // === SZENEN√úBERSICHT (PDF): Zusammenfassung wird oben bereits gerendert ===
        
      } else {
        children.push(new Paragraph({
          children: [new TextRun({ 
            text: (meta.titel || 'Regiebuch') + ' ‚Äì Auszug (' + exportSzenen.length + (exportSzenen.length === 1 ? ' Szene)' : ' Szenen)') + (includeCues ? ' ‚Äì TECHNIKFASSUNG' : ''),
            size: 20, color: '666666'
          })],
          spacing: { after: 300 }
        }));
      }
      
      // === SZENEN-INHALT ===
      const eigeneGruppen = meta.eigeneGruppen || ['Erster Akt'];
      const szenenNachGruppen = {};
      eigeneGruppen.forEach(g => { szenenNachGruppen[g] = []; });
      
      exportSzenen.forEach(s => {
        const gruppe = s.gruppe || eigeneGruppen[0] || '';
        if (!szenenNachGruppen[gruppe]) szenenNachGruppen[gruppe] = [];
        szenenNachGruppen[gruppe].push(s);
      });
      
      if (istVollstaendig && eigeneGruppen.length > 1) {
        eigeneGruppen.forEach(gruppe => {
          const szenen = szenenNachGruppen[gruppe] || [];
          if (szenen.length === 0) return;
          
          children.push(new Paragraph({
            children: [new TextRun({ text: gruppe, bold: true, size: 36, allCaps: true })],
            alignment: AlignmentType.CENTER,
            spacing: { before: 600, after: 300 },
            style: 'AktTitel'
          }));
          
          szenen.forEach(szene => {
            addSzeneToDocNew(children, szene, includeCues, { Paragraph, TextRun, PageBreak, AlignmentType, BorderStyle });
          });
        });
      } else {
        exportSzenen.forEach(szene => {
          addSzeneToDocNew(children, szene, includeCues, { Paragraph, TextRun, PageBreak, AlignmentType, BorderStyle });
        });
      }
      
      // === DOKUMENT ERSTELLEN ===
      const doc = new Document({
        styles: {
          paragraphStyles: [
            { id: 'Dialog', name: 'Dialog', basedOn: 'Normal', next: 'Normal',
              run: { size: 24 }, paragraph: { spacing: { before: 40, after: 40 } } },
            { id: 'Regieanweisung', name: 'Regieanweisung', basedOn: 'Normal', next: 'Normal',
              run: { italics: true, size: 22, color: '555555' }, paragraph: { indent: { left: 1440 }, spacing: { before: 80, after: 80 } } },
            { id: 'Lied', name: 'Lied', basedOn: 'Normal', next: 'Normal',
              run: { italics: true, size: 22, color: '1e40af' }, paragraph: { indent: { left: 1200 }, spacing: { before: 20, after: 20 } } },
            { id: 'Vers', name: 'Vers', basedOn: 'Normal', next: 'Normal',
              run: { italics: true, size: 22 }, paragraph: { indent: { left: 1200 }, spacing: { before: 20, after: 20 } } },
            { id: 'AktTitel', name: 'Akt-Titel', basedOn: 'Normal', next: 'Normal',
              run: { bold: true, size: 36, allCaps: true }, paragraph: { alignment: AlignmentType.CENTER, spacing: { before: 600, after: 300 } } },
            { id: 'SzenenTitel', name: 'Szenen-Titel', basedOn: 'Normal', next: 'Normal',
              run: { bold: true, size: 28 }, paragraph: { spacing: { before: 300, after: 100 } } },
            { id: 'Pause', name: 'Pause', basedOn: 'Normal', next: 'Normal',
              run: { bold: true, size: 28 }, paragraph: { alignment: AlignmentType.CENTER, spacing: { before: 400, after: 400 } } },
            { id: 'Standard', name: 'Standard', basedOn: 'Normal', next: 'Normal',
              run: { size: 24 }, paragraph: { spacing: { after: 60 } } },
            { id: 'TechnikCue', name: 'Technik-Cue', basedOn: 'Normal', next: 'Normal',
              run: { bold: true, size: 18, color: '7c3aed' }, paragraph: { spacing: { before: 20, after: 20 } } }
          ]
        },
        sections: [{
          properties: {
            page: { margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 } }
          },
          headers: {
            default: new Header({
              children: [new Paragraph({
                children: [
                  new TextRun({ text: meta.titel || 'Regiebuch', size: 18 }),
                  new TextRun({ text: includeCues ? ' ‚Äì Technikfassung' : '', size: 18 }),
                  new TextRun({ text: '\t\t' + formatDateTime(new Date()), size: 18 })
                ]
              })]
            })
          },
          children: children
        }]
      });
      
      const blob = await Packer.toBlob(doc);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = makeExportFilename(includeCues ? 'Technikfassung' : 'Textfassung', 'docx');
      a.click();
      URL.revokeObjectURL(url);
      
      state.dirty = false; // Export erstellt
      closeModal('showExportModal');
    }
    
    // === Szene zum Dokument hinzufuegen ===
    function addSzeneToDocNew(children, szene, includeCues, { Paragraph, TextRun, PageBreak, AlignmentType, BorderStyle }) {
      children.push(new Paragraph({
        children: [new TextRun({ text: szene.nummer + ' ' + szene.titel, bold: true, size: 28 })],
        spacing: { before: 300, after: 60 },
        style: 'SzenenTitel',
        border: { bottom: { style: BorderStyle.SINGLE, size: 6, color: 'CCCCCC' } }
      }));
      
      if (szene.ort || szene.zeit) {
        children.push(new Paragraph({
          children: [new TextRun({ 
            text: [szene.ort ? 'Ort: ' + szene.ort : '', szene.zeit ? 'Zeit: ' + szene.zeit : ''].filter(Boolean).join(' ¬∑ '),
            italics: true, size: 20, color: '666666'
          })],
          spacing: { after: 60 }
        }));
      }
      
      if (szene.figuren && szene.figuren.length > 0) {
        const namen = szene.figuren.map(fId => {
          const fig = state.figuren.find(f => f.id === fId);
          return fig ? fig.name : '';
        }).filter(Boolean).join(', ');
        if (namen) {
          children.push(new Paragraph({
            children: [
              new TextRun({ text: 'Figuren: ', bold: true, size: 20, color: '666666' }),
              new TextRun({ text: namen, size: 20, color: '666666' })
            ],
            spacing: { after: 60 }
          }));
        }
      }
      
      if (szene.zusammenfassung) {
        children.push(new Paragraph({
          children: [new TextRun({ text: szene.zusammenfassung, italics: true, size: 18, color: '999999' })],
          spacing: { after: 120 }
        }));
      }
      
      children.push(new Paragraph({ spacing: { before: 80 }, children: [] }));
      
      const szeneCues = includeCues ? state.cues.filter(c => c.szeneId === szene.id) : [];
      const content = state.textbuch[szene.id] || '';
      parseContentToDocxNew(content, children, szeneCues, includeCues, { Paragraph, TextRun, AlignmentType });
    }
    
    // === ROBUSTER HTML-zu-DOCX PARSER ===
    function parseContentToDocxNew(html, children, szeneCues, includeCues, { Paragraph, TextRun, AlignmentType }) {
      const temp = document.createElement('div');
      temp.innerHTML = html;
      
      // Cue-Marker immer entfernen (wir fuegen eigene ein bei Technikfassung)
      temp.querySelectorAll('.cue-inline-marker, .cue-marker, .cue-badge').forEach(m => m.remove());
      
      // === Paragraph hinzufuegen ===
      function addParagraph(text, style, figurName) {
        if (!text || !text.trim()) return;
        text = text.trim();
        
        const runs = [];
        if (figurName) {
          runs.push(new TextRun({ text: figurName + ' ', bold: true, size: 24 }));
        }
        
        // Cue-Marker einfuegen (Technikfassung)
        if (includeCues && szeneCues.length > 0) {
          let remaining = text;
          let addedCue = false;
          
          for (const cue of szeneCues) {
            if (!cue.ankerText) continue;
            const anker = cue.ankerText.trim();
            const idx = remaining.indexOf(anker);
            if (idx !== -1) {
              if (idx > 0) runs.push(new TextRun({ text: remaining.substring(0, idx), size: 24 }));
              runs.push(new TextRun({ text: remaining.substring(idx, idx + anker.length), size: 24 }));
              const prefix = CUE_TYPEN[cue.typ] ? CUE_TYPEN[cue.typ].prefix : (cue.typ ? cue.typ.toUpperCase() : 'CUE');
              runs.push(new TextRun({ text: ' [' + prefix + cue.nummer + (cue.beschreibung ? ': ' + cue.beschreibung : '') + '] ', bold: true, size: 18, color: '7c3aed' }));
              remaining = remaining.substring(idx + anker.length);
              addedCue = true;
            }
          }
          if (remaining) runs.push(new TextRun({ text: remaining, size: 24 }));
          if (!addedCue && runs.length === (figurName ? 1 : 0)) {
            runs.push(new TextRun({ text: text, size: 24 }));
          }
        } else {
          runs.push(new TextRun({ text: text, size: 24 }));
        }
        
        children.push(new Paragraph({
          children: runs,
          style: style || 'Standard',
          spacing: { before: 40, after: 40 }
        }));
      }
      
      // === Format-Erkennung ===
      function getFormat(el) {
        if (!el || !el.classList) return null;
        if (el.classList.contains('format-dialog')) return 'Dialog';
        if (el.classList.contains('format-regieanweisung')) return 'Regieanweisung';
        if (el.classList.contains('format-szene-titel')) return 'SzenenTitel';
        if (el.classList.contains('format-akt-titel')) return 'AktTitel';
        if (el.classList.contains('format-lied')) return 'Lied';
        if (el.classList.contains('format-vers')) return 'Vers';
        if (el.classList.contains('format-pause')) return 'Pause';
        return null;
      }
      
      // === Dialog-Block verarbeiten ===
      function processDialog(el) {
        const nameEl = el.querySelector('.figur-name');
        const name = nameEl ? nameEl.textContent.trim() : '';
        
        let firstParagraph = true;
        
        Array.from(el.childNodes).forEach(function(child) {
          // figur-name ueberspringen
          if (child.nodeType === Node.ELEMENT_NODE && child.classList && child.classList.contains('figur-name')) return;
          
          // Leere Knoten ueberspringen
          if (child.nodeType === Node.TEXT_NODE && !child.textContent.trim()) return;
          if (child.nodeType === Node.ELEMENT_NODE && child.tagName === 'BR') return;
          
          // Element mit eigenem (nicht-Dialog) Format?
          if (child.nodeType === Node.ELEMENT_NODE) {
            const childFormat = getFormat(child);
            if (childFormat && childFormat !== 'Dialog') {
              addParagraph(child.textContent, childFormat);
              return;
            }
            
            // Pruefen ob Kinder mit eigenem Format existieren
            if (child.querySelector && child.querySelector('[class*="format-"]')) {
              Array.from(child.childNodes).forEach(function(grandchild) {
                if (grandchild.nodeType === Node.ELEMENT_NODE) {
                  const gcFormat = getFormat(grandchild);
                  if (gcFormat && gcFormat !== 'Dialog') {
                    addParagraph(grandchild.textContent, gcFormat);
                  } else {
                    var gcText = grandchild.textContent.trim();
                    if (gcText) {
                      if (firstParagraph && name) {
                        addParagraph(gcText, 'Dialog', name);
                        firstParagraph = false;
                      } else {
                        addParagraph(gcText, 'Dialog');
                      }
                    }
                  }
                } else if (grandchild.nodeType === Node.TEXT_NODE) {
                  var gcText = grandchild.textContent.trim();
                  if (gcText) {
                    if (firstParagraph && name) {
                      addParagraph(gcText, 'Dialog', name);
                      firstParagraph = false;
                    } else {
                      addParagraph(gcText, 'Dialog');
                    }
                  }
                }
              });
              return;
            }
          }
          
          // Text extrahieren
          var text = (child.textContent || '').trim();
          if (!text) return;
          
          if (firstParagraph && name) {
            addParagraph(text, 'Dialog', name);
            firstParagraph = false;
          } else {
            addParagraph(text, 'Dialog');
          }
        });
      }
      
      // === Top-Level Knoten verarbeiten ===
      function processTopLevel(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          var text = node.textContent.trim();
          if (text) addParagraph(text, 'Standard');
          return;
        }
        
        if (node.nodeType !== Node.ELEMENT_NODE) return;
        if (node.tagName === 'BR') return;
        if (!node.textContent.trim()) return;
        
        var format = getFormat(node);
        
        if (format === 'Dialog') {
          processDialog(node);
          return;
        }
        
        // Szenen-Titel ueberspringen (wird separat hinzugefuegt)
        if (format === 'SzenenTitel') return;
        
        if (format) {
          addParagraph(node.textContent, format);
          return;
        }
        
        // Kein Format: Pruefen ob Kinder mit Format existieren
        if (node.querySelector && node.querySelector('[class*="format-"]')) {
          Array.from(node.childNodes).forEach(function(child) { processTopLevel(child); });
          return;
        }
        
        // Reines Text-Element ohne Format -> Standard
        addParagraph(node.textContent, 'Standard');
      }
      
      // === Alle Top-Level Knoten durchgehen ===
      Array.from(temp.childNodes).forEach(function(node) { processTopLevel(node); });
    }
    
    function exportTextfassungPDF() {
      const html = generateTextfassungHTML();
      
      // Neues Fenster f√ºr Druckvorschau
      const printWindow = window.open('', '_blank');
      printWindow.document.write(html);
      printWindow.document.close();
      
      // Kurz warten dann drucken
      setTimeout(() => {
        printWindow.print();
      }, 500);
      
      closeModal('showExportModal');
    }
    
    // NEU: Export f√ºr Propla
    // ============================================
    // ============================================
    // NINA-EXCHANGE EXPORT v2.0
    // Vollst√§ndiges Format f√ºr Werkbank, Rebu, Propla
    // ============================================
    function buildNinaExchangeData() {
      // NINA-Exchange Format v2.0 erstellen
      const ninaExport = {
        format: 'nina-exchange',
        version: '2.0',
        exportedFrom: 'rebu',
        exportedAt: new Date().toISOString(),
        
        // === PROJEKT (alle Felder) ===
        project: {
          name: state.projektMeta.titel || 'Unbenannt',
          subtitle: state.projektMeta.untertitel || '',
          author: state.projektMeta.autor || '',
          director: state.projektMeta.regie || '',
          description: state.projektMeta.logline || '',
          tagline: state.projektMeta.tagline || '',
          logline: state.projektMeta.logline || '',
          copyright: state.projektMeta.copyright || '',
          cover_image: state.projektMeta.titelbild || '',
          premiere_date: state.projektMeta.premiere || null,
          venue: state.projektMeta.spielort || '',
          version_name: state.projektMeta.fassung || 'Arbeitsfassung',
          version_date: state.projektMeta.fassungsDatum || new Date().toISOString(),
          structure_type: state.projektMeta.strukturTyp || 'akte',
          status: 'active'
        },
        
        // === FIGUREN (alle Felder) ===
        figures: state.figuren.map((f, idx) => ({
          id: f.id,
          name: f.name || '',
          short_name: f.kuerzel || f.name?.substring(0, 3).toUpperCase() || '',
          description: f.beschreibung || '',
          figure_type: f.typ || 'main',
          color: f.farbe || '#3b82f6',
          sort_order: idx,
          // Dramaturgie-Felder
          want_external: f.want || '',
          want_internal: f.wantInternal || '',
          need: f.need || '',
          ghost: f.ghost || '',
          biography: f.biografie || f.beschreibung || '',
          weakness: f.schwaeche || '',
          strength: f.staerke || '',
          characteristic: f.charakteristik || '',
          archetype: f.archetyp || '',
          profession: f.beruf || '',
          goal: f.ziel || '',
          obstacle: f.hindernis || '',
          conflict: f.konflikt || '',
          development: f.entwicklung || ''
        })),
        
        // === SZENEN (alle Felder) ===
        scenes: state.szenen.map((s, idx) => {
          // Text aus Textbuch holen
          const rawContent = state.textbuch[s.id] || '';
          
          // Figuren-IDs (nicht Namen, f√ºr bessere Referenz)
          const figurenIds = s.figuren || [];
          
          return {
            id: s.id,
            number: s.nummer || String(idx + 1),
            name: s.titel || `Szene ${idx + 1}`,
            act: s.gruppe || '',
            group: s.gruppe || '',
            description: s.zusammenfassung || '',
            summary: s.zusammenfassung || '',
            location: s.ort || '',
            time: s.zeit || '',
            figures: figurenIds,
            content: rawContent,
            estimated_duration: s.dauer || null,
            status: 'written',
            sort_order: idx
          };
        }),
        
        // === CUES (Licht, Ton, Video) ===
        cues: state.cues.map(c => ({
          id: c.id,
          scene_id: c.szeneId,
          cue_type: c.typ,
          cue_number: c.nummer,
          description: c.beschreibung || '',
          anchor_text: c.ankerText || '',
          duration: c.dauer || '',
          sort_order: c.sortOrder || 0
        })),
        
        // === MEDIEN (Audio, Video, Bilder) ===
        media: (state.medien || []).map(m => ({
          id: m.id,
          name: m.name || '',
          type: m.typ || 'audio',
          url: m.url || '',
          scene_id: m.szeneId || null
        }))
      };
      
      return ninaExport;
    }
    
    function exportForDramera() {
      const ninaExport = buildNinaExchangeData();
      
      // Als JSON-Datei herunterladen
      const fileName = makeExportFilename('NINA-Exchange', 'json');
      const content = JSON.stringify(ninaExport, null, 2);
      
      // UTF-8 BOM f√ºr bessere Kompatibilit√§t
      const BOM = '\uFEFF';
      const blob = new Blob([BOM + content], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      
      state.dirty = false; // Export erstellt
      closeModal('showExportModal');
      const szenenMitText = state.szenen.filter(s => (state.textbuch[s.id] || '').trim().length > 0).length;
      
      let msg = '‚úÖ NINA-Exchange v2.0 Export erstellt!\n\n';
      msg += `üìÅ Datei: ${fileName}\n\n`;
      msg += `üìã Projekt: ${state.projektMeta.titel || 'Unbenannt'}\n`;
      msg += `‚úçÔ∏è Autor: ${state.projektMeta.autor || '(nicht angegeben)'}\n\n`;
      msg += `üë§ ${ninaExport.figures.length} Figuren\n`;
      msg += `üé¨ ${ninaExport.scenes.length} Szenen (${szenenMitText} mit Text)\n`;
      msg += `üéõÔ∏è ${ninaExport.cues.length} Cues\n`;
      msg += `\nDiese Datei kann in Werkbank, Rebu und Propla importiert werden.`;
      
      alert(msg);
    }

    function renderFassungModal() {
      const defaultName = `Fassung vom ${formatDateTime(new Date())}`;
      return `
        <div class="modal-overlay" onclick="closeModal('showFassungModal')">
          <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">üíæ Neue Fassung speichern</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showFassungModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <!-- Warnhinweis -->
              <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                <div style="display: flex; align-items: flex-start; gap: 8px;">
                  <span style="font-size: 18px;">‚ö†Ô∏è¬è</span>
                  <div>
                    <p style="font-size: 13px; font-weight: 500; color: #92400e; margin: 0 0 4px 0;">Nur lokal im Browser!</p>
                    <p style="font-size: 11px; color: #a16207; margin: 0;">
                      Diese Fassung wird nur im Browser-Cache gespeichert. Bei Cache-L√∂schung sind alle Daten weg!
                    </p>
                  </div>
                </div>
              </div>
              
              <p class="text-sm text-gray-500 mb-4">
                Speichere den aktuellen Stand als benannte Fassung (Snapshot).
              </p>
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Name der Fassung</label>
                <input type="text" id="fassung-name" value="${defaultName}" class="w-full">
              </div>
              <div class="flex gap-2 mt-4">
                <button class="btn btn-outline flex-1" onclick="closeModal('showFassungModal')">Abbrechen</button>
                <button class="btn btn-success flex-1" onclick="saveFassung()">üíæ Speichern</button>
              </div>
              
              <!-- Zus√§tzlich: Sicher speichern -->
              <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
                <button class="btn w-full" style="background: #059669; color: white;" onclick="saveFassungAndExport()">
                  üíæ Speichern + üì• Backup exportieren (sicher!)
                </button>
                <p style="font-size: 10px; color: #6b7280; text-align: center; margin-top: 6px;">
                  Speichert die Fassung UND l√§dt ein Backup auf deinen Computer herunter
                </p>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderFigurModal() {
      const f = state.editingFigur || {};
      const isEdit = !!f.id;
      return `
        <div class="modal-overlay" onclick="closeModal('showFigurModal')">
          <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Figur bearbeiten' : 'üë§ Neue Figur'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showFigurModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                  <input type="text" id="figur-name" value="${f.name || ''}" placeholder="MARTHE">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">K√ºrzel</label>
                  <input type="text" id="figur-kuerzel" value="${f.kuerzel || ''}" placeholder="MA" maxlength="4">
                </div>
              </div>
              <div class="mt-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea id="figur-beschreibung" rows="2" placeholder="Die Marketenderin">${f.beschreibung || ''}</textarea>
              </div>
              <div class="grid grid-cols-2 gap-4 mt-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Will (extern)</label>
                  <input type="text" id="figur-want" value="${f.want || ''}" placeholder="√úberleben">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Braucht (intern)</label>
                  <input type="text" id="figur-need" value="${f.need || ''}" placeholder="Liebe">
                </div>
              </div>
              <div class="grid grid-cols-2 gap-4 mt-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Wunde</label>
                  <input type="text" id="figur-wunde" value="${f.wunde || ''}" placeholder="Verlust der Mutter">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Geheimnis</label>
                  <input type="text" id="figur-geheimnis" value="${f.geheimnis || ''}" placeholder="Kennt die Wahrheit">
                </div>
              </div>
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteFigur('${f.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showFigurModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveFigur()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderCueModal() {
      const c = state.editingCue || {};
      const isEdit = !!c.id && state.cues.find(x => x.id === c.id);
      const selectedTyp = c.typ || 'lx';
      
      // Parse umbauAktionen f√ºr Checkboxen
      const umbauAktionen = c.umbauAktionen || [];
      
      return `
        <div class="modal-overlay" onclick="closeModal('showCueModal')">
          <div class="modal-content" style="max-width: 600px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Cue bearbeiten' : 'üí° Neuer Cue'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showCueModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Typ</label>
                  <select id="cue-typ" onchange="updateCueModalForTyp()">
                    ${Object.entries(CUE_TYPEN).map(([k, v]) => `
                      <option value="${k}" ${selectedTyp === k ? 'selected' : ''}>${v.icon} ${v.name} (${v.prefix})</option>
                    `).join('')}
                  </select>
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Nummer</label>
                  <input type="number" id="cue-nummer" value="${c.nummer || ''}" min="1">
                </div>
              </div>
              
              <!-- Verkn√ºpfung f√ºr Requisite -->
              <div id="cue-requisite-section" class="mt-4 ${selectedTyp === 'r' ? '' : 'hidden'}">
                <label class="block text-sm font-medium text-gray-700 mb-1">üé≠ Requisite verkn√ºpfen</label>
                <select id="cue-requisite" onchange="toggleCueRequisitenNeu()">
                  <option value="">‚Äì Neue Requisite erstellen ‚Äì</option>
                  ${state.requisiten.map(r => `
                    <option value="${r.id}" ${c.requisitenId === r.id ? 'selected' : ''}>${r.name}</option>
                  `).join('')}
                </select>
                <input type="text" id="cue-requisite-neu" class="mt-2 ${c.requisitenId ? 'hidden' : ''}" 
                       placeholder="Name der neuen Requisite" value="${c.requisitenName || ''}">
              </div>
              
              <!-- Verkn√ºpfung f√ºr Ton/Video -->
              <div id="cue-medium-section" class="mt-4 ${(selectedTyp === 'q' || selectedTyp === 'v') ? '' : 'hidden'}">
                <label class="block text-sm font-medium text-gray-700 mb-1" id="cue-medium-label">
                  ${selectedTyp === 'q' ? 'üîä Audio' : 'üì∫ Video'} verkn√ºpfen
                </label>
                <select id="cue-medium" onchange="toggleCueMediumNeu()">
                  <option value="">‚Äì Noch nicht vorhanden ‚Äì</option>
                  ${state.medien.filter(m => 
                    (selectedTyp === 'q' && m.type === 'audio') || 
                    (selectedTyp === 'v' && m.type === 'video')
                  ).map(m => `
                    <option value="${m.id}" ${c.mediumId === m.id ? 'selected' : ''}>${m.name}</option>
                  `).join('')}
                </select>
                <input type="text" id="cue-medium-geplant" class="mt-2 ${c.mediumId ? 'hidden' : ''}" 
                       placeholder="Geplanter Ton/Video (z.B. Waldger√§usche)" value="${c.mediumGeplant || ''}">
                <p class="text-xs text-gray-400 mt-1">Kann sp√§ter im Medien-Modul verkn√ºpft werden</p>
              </div>
              
              <!-- Umbau-Sektion -->
              <div id="cue-umbau-section" class="mt-4 ${selectedTyp === 'u' ? '' : 'hidden'}">
                <div class="grid grid-cols-2 gap-4 mb-3">
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">üé™ Von B√ºhnenbild</label>
                    <select id="cue-umbau-von">
                      <option value="">‚Äì w√§hlen ‚Äì</option>
                      ${state.buehne.map(b => `
                        <option value="${b.id}" ${c.umbauVon === b.id ? 'selected' : ''}>${b.name}</option>
                      `).join('')}
                    </select>
                  </div>
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">‚û°Ô∏è¬è Nach B√ºhnenbild</label>
                    <select id="cue-umbau-nach">
                      <option value="">‚Äì w√§hlen ‚Äì</option>
                      ${state.buehne.map(b => `
                        <option value="${b.id}" ${c.umbauNach === b.id ? 'selected' : ''}>${b.name}</option>
                      `).join('')}
                    </select>
                  </div>
                </div>
                
                <label class="block text-sm font-medium text-gray-700 mb-1">üìã Umbau-Aktionen</label>
                <div class="border rounded p-2 max-h-32 overflow-y-auto mb-2" id="umbau-aktionen-liste">
                  ${umbauAktionen.map((a, i) => `
                    <div class="flex items-center gap-2 mb-1">
                      <input type="text" class="umbau-aktion flex-1" value="${a}" placeholder="z.B. Zug 1 HOCH">
                      <button class="text-red-500 text-sm" onclick="removeUmbauAktion(${i})">‚úï</button>
                    </div>
                  `).join('')}
                </div>
                <button class="btn btn-xs btn-outline" onclick="addUmbauAktion()">+ Aktion hinzuf√ºgen</button>
                
                <!-- Requisiten AB/AUF -->
                <div class="grid grid-cols-2 gap-4 mt-3">
                  <div>
                    <label class="block text-sm font-medium text-red-600 mb-1">üî¥ Requisiten AB</label>
                    <div class="max-h-20 overflow-y-auto border rounded p-1">
                      ${state.requisiten.map(r => `
                        <label class="checkbox-item text-xs">
                          <input type="checkbox" class="umbau-req-ab" value="${r.id}" 
                                 ${c.requisitenAb?.includes(r.id) ? 'checked' : ''}>
                          ${r.name}
                        </label>
                      `).join('') || '<span class="text-xs text-gray-400">Keine Requisiten</span>'}
                    </div>
                  </div>
                  <div>
                    <label class="block text-sm font-medium text-green-600 mb-1">üü¢ Requisiten AUF</label>
                    <div class="max-h-20 overflow-y-auto border rounded p-1">
                      ${state.requisiten.map(r => `
                        <label class="checkbox-item text-xs">
                          <input type="checkbox" class="umbau-req-auf" value="${r.id}"
                                 ${c.requisitenAuf?.includes(r.id) ? 'checked' : ''}>
                          ${r.name}
                        </label>
                      `).join('') || '<span class="text-xs text-gray-400">Keine Requisiten</span>'}
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="mt-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Szene (vor dieser Szene)</label>
                <select id="cue-szene">
                  <option value="">‚Äì Szene w√§hlen ‚Äì</option>
                  ${state.szenen.map(s => `
                    <option value="${s.id}" ${c.szeneId === s.id ? 'selected' : ''}>${s.nummer} ${s.titel}</option>
                  `).join('')}
                </select>
              </div>
              
              <div class="mt-4 ${selectedTyp === 'u' ? 'hidden' : ''}" id="cue-beschreibung-section">
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea id="cue-beschreibung" rows="2" placeholder="Morgend√§mmerung - langsamer Fade up">${c.beschreibung || ''}</textarea>
              </div>
              
              <!-- NEU: Ankertext (Textposition) -->
              <div class="mt-4 ${selectedTyp === 'u' ? 'hidden' : ''}" id="cue-anker-section">
                <label class="block text-sm font-medium text-gray-700 mb-1">üîç Position im Text (Anker)</label>
                <div class="relative">
                  <input type="text" id="cue-ankertext" value="${escapeHtml(c.ankerText || '')}" 
                         placeholder="z.B. (Das Fenster wird ge√∂ffnet.) oder: Ich liebe dich."
                         class="pr-10">
                  <span class="absolute right-3 top-1/2 -translate-y-1/2 text-xs text-gray-400" title="Text im Textbuch markieren, dann Cue erstellen">‚ÑπÔ∏è¬è</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Der Cue wird an dieser Textstelle angezeigt. Tipp: Im Textbuch Text markieren, dann "Cue hier einf√ºgen" klicken.</p>
              </div>
              
              <div class="grid grid-cols-2 gap-4 mt-4 ${selectedTyp === 'u' ? 'hidden' : ''}" id="cue-trigger-section">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Ausl√∂ser</label>
                  <input type="text" id="cue-ausloeser" value="${c.ausloeser || ''}" placeholder="MARTHE tritt auf">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Dauer</label>
                  <input type="text" id="cue-dauer" value="${c.dauer || ''}" placeholder="5s">
                </div>
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteCue('${c.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showCueModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveCue()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Umbau-Aktionen dynamisch hinzuf√ºgen/entfernen
    function addUmbauAktion() {
      const liste = document.getElementById('umbau-aktionen-liste');
      const div = document.createElement('div');
      div.className = 'flex items-center gap-2 mb-1';
      div.innerHTML = `
        <input type="text" class="umbau-aktion flex-1" placeholder="z.B. Zug 1 HOCH">
        <button class="text-red-500 text-sm" onclick="this.parentElement.remove()">‚úï</button>
      `;
      liste.appendChild(div);
    }
    
    function removeUmbauAktion(index) {
      // Wird beim Laden des Modals verwendet
      if (state.editingCue?.umbauAktionen) {
        state.editingCue.umbauAktionen.splice(index, 1);
        render();
      }
    }
    
    function toggleCueRequisitenNeu() {
      const select = document.getElementById('cue-requisite');
      const neu = document.getElementById('cue-requisite-neu');
      if (select && neu) {
        neu.classList.toggle('hidden', select.value !== '');
      }
    }
    
    function toggleCueMediumNeu() {
      const select = document.getElementById('cue-medium');
      const neu = document.getElementById('cue-medium-geplant');
      if (select && neu) {
        neu.classList.toggle('hidden', select.value !== '');
      }
    }
    
    // UI-Update wenn Cue-Typ ge√§ndert wird
    function updateCueModalForTyp() {
      const typ = document.getElementById('cue-typ').value;
      const reqSection = document.getElementById('cue-requisite-section');
      const medSection = document.getElementById('cue-medium-section');
      const umbauSection = document.getElementById('cue-umbau-section');
      const beschreibungSection = document.getElementById('cue-beschreibung-section');
      const triggerSection = document.getElementById('cue-trigger-section');
      
      // Requisite-Sektion
      if (reqSection) {
        reqSection.classList.toggle('hidden', typ !== 'r');
      }
      
      // Medium-Sektion (Ton oder Video)
      if (medSection) {
        medSection.classList.toggle('hidden', typ !== 'q' && typ !== 'v');
        
        // Label aktualisieren
        const label = document.getElementById('cue-medium-label');
        if (label) {
          label.innerHTML = typ === 'q' ? 'üîä Audio verkn√ºpfen' : 'üì∫ Video verkn√ºpfen';
        }
        
        // Dropdown aktualisieren
        const select = document.getElementById('cue-medium');
        if (select) {
          const currentVal = select.value;
          select.innerHTML = `<option value="">‚Äì Noch nicht vorhanden ‚Äì</option>` +
            state.medien.filter(m => 
              (typ === 'q' && m.type === 'audio') || 
              (typ === 'v' && m.type === 'video')
            ).map(m => `<option value="${m.id}" ${currentVal === m.id ? 'selected' : ''}>${m.name}</option>`).join('');
        }
      }
      
      // Umbau-Sektion
      if (umbauSection) {
        umbauSection.classList.toggle('hidden', typ !== 'u');
      }
      
      // Beschreibung und Trigger f√ºr Umbau ausblenden
      if (beschreibungSection) {
        beschreibungSection.classList.toggle('hidden', typ === 'u');
      }
      if (triggerSection) {
        triggerSection.classList.toggle('hidden', typ === 'u');
      }
    }

    function renderSzeneModal() {
      const s = state.editingSzene || {};
      const isEdit = !!s.id;
      const aktuelleGruppen = getAktuelleGruppen();
      
      return `
        <div class="modal-overlay" onclick="closeModal('showSzeneModal')">
          <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Szene bearbeiten' : 'üé¨ Neue Szene'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showSzeneModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-4 gap-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Nummer</label>
                  <input type="text" id="szene-nummer" value="${s.nummer || ''}" placeholder="1.1">
                </div>
                <div class="col-span-2">
                  <label class="block text-sm font-medium text-gray-700 mb-1">Titel *</label>
                  <input type="text" id="szene-titel" value="${s.titel || ''}" placeholder="Prolog">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Akt/Teil</label>
                  <input type="text" list="szene-gruppe-list" id="szene-gruppe" value="${s.gruppe || aktuelleGruppen[0] || ''}" placeholder="Erster Akt">
                  <datalist id="szene-gruppe-list">
                    ${aktuelleGruppen.map(g => `<option value="${g}">`).join('')}
                  </datalist>
                </div>
              </div>
              <div class="grid grid-cols-2 gap-4 mt-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Ort</label>
                  <input type="text" id="szene-ort" value="${s.ort || ''}" placeholder="Marktplatz">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Zeit</label>
                  <input type="text" id="szene-zeit" value="${s.zeit || ''}" placeholder="Morgen">
                </div>
              </div>
              <div class="mt-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Zusammenfassung</label>
                <textarea id="szene-zusammenfassung" rows="3" placeholder="Was passiert in dieser Szene?">${s.zusammenfassung || ''}</textarea>
              </div>
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteSzene('${s.id}'); closeModal('showSzeneModal');">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showSzeneModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveSzene()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // v1.3: Kost√ºm-Modal mit Maske und Bildern
    function renderKostuemModal() {
      const k = state.editingKostuem || {};
      const isEdit = !!k.id;
      
      // Bilder-Arrays (mit Fallback f√ºr alte Daten)
      const kostuemBilder = k.kostuemBilder || (k.kostuemBildId ? [k.kostuemBildId] : []);
      const maskeBilder = k.maskeBilder || (k.maskeBildId ? [k.maskeBildId] : []);
      
      return `
        <div class="modal-overlay" onclick="closeModal('showKostuemModal')">
          <div class="modal-content" style="max-width: 750px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Kost√ºm bearbeiten' : 'üëó Neues Kost√ºm'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showKostuemModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <!-- Name und Figur -->
              <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                  <input type="text" id="kostuem-name" value="${k.name || ''}" placeholder="Marthe - Grundkost√ºm">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Figur</label>
                  <select id="kostuem-figur">
                    <option value="">‚Äì Figur w√§hlen ‚Äì</option>
                    ${state.figuren.map(f => `
                      <option value="${f.id}" ${k.figur === f.id ? 'selected' : ''}>${f.name}</option>
                    `).join('')}
                  </select>
                </div>
              </div>
              
              <!-- Bilder: Kost√ºm (mehrere) -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">üëó Kost√ºm-Bilder</label>
                <div class="image-grid" id="kostuem-bilder-grid">
                  ${kostuemBilder.map((imgId, i) => `
                    <div class="relative">
                      <img src="${imageUrlCache[imgId] || ''}" class="image-thumb" id="kostuem-edit-img-${i}">
                      <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                              onclick="removeKostuemBildMulti('kostuem', ${i})">‚úï</button>
                    </div>
                  `).join('')}
                  <div class="add-image-btn" onclick="document.getElementById('kostuem-bilder-input').click()">+</div>
                </div>
                <input type="file" id="kostuem-bilder-input" accept="image/*" multiple class="hidden" onchange="addKostuemBilder(this, 'kostuem')">
              </div>
              
              <!-- Bilder: Maske (mehrere) -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">üé≠ Maske-Bilder</label>
                <div class="image-grid" id="maske-bilder-grid">
                  ${maskeBilder.map((imgId, i) => `
                    <div class="relative">
                      <img src="${imageUrlCache[imgId] || ''}" class="image-thumb" id="maske-edit-img-${i}">
                      <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                              onclick="removeKostuemBildMulti('maske', ${i})">‚úï</button>
                    </div>
                  `).join('')}
                  <div class="add-image-btn" onclick="document.getElementById('maske-bilder-input').click()">+</div>
                </div>
                <input type="file" id="maske-bilder-input" accept="image/*" multiple class="hidden" onchange="addKostuemBilder(this, 'maske')">
              </div>
              
              <!-- Beschreibung Kost√ºm -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">üëó Kost√ºm-Beschreibung</label>
                <textarea id="kostuem-beschreibung" rows="2" placeholder="Einfaches Leinenkleid, Sch√ºrze, Kopftuch">${k.beschreibung || ''}</textarea>
              </div>
              
              <!-- Beschreibung Maske -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">üé≠ Maske-Beschreibung</label>
                <textarea id="kostuem-maske" rows="2" placeholder="Graue Per√ºcke, blasse Schminke, Altersflecken">${k.maske || ''}</textarea>
              </div>
              
              <!-- Szenen -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Szenen</label>
                <div class="max-h-24 overflow-y-auto border rounded p-2">
                  ${state.szenen.length === 0 ? '<span class="text-xs text-gray-400">Keine Szenen vorhanden</span>' : 
                    state.szenen.map(s => `
                    <label class="checkbox-item">
                      <input type="checkbox" class="kostuem-szene-check" value="${s.id}" 
                             ${k.szenen?.includes(s.id) ? 'checked' : ''}>
                      <span class="text-sm">${s.nummer} ${s.titel}</span>
                    </label>
                  `).join('')}
                </div>
              </div>
              
              <!-- Notizen -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Notizen</label>
                <input type="text" id="kostuem-notizen" value="${k.notizen || ''}" placeholder="Muss verstaubt aussehen">
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteKostuem('${k.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showKostuemModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveKostuem()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Tempor√§re Speicher f√ºr neue Bilder im Kost√ºm-Modal
    let pendingKostuemBilder = [];
    let pendingMaskeBilder = [];
    
    function addKostuemBilder(input, type) {
      const files = Array.from(input.files);
      const pending = type === 'kostuem' ? pendingKostuemBilder : pendingMaskeBilder;
      const gridId = type === 'kostuem' ? 'kostuem-bilder-grid' : 'maske-bilder-grid';
      
      files.forEach(file => {
        pending.push(file);
        const reader = new FileReader();
        reader.onload = (e) => {
          const grid = document.getElementById(gridId);
          const addBtn = grid.querySelector('.add-image-btn');
          const div = document.createElement('div');
          div.className = 'relative';
          const idx = pending.length - 1;
          div.innerHTML = `
            <img src="${e.target.result}" class="image-thumb">
            <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                    onclick="this.parentElement.remove();">‚úï</button>
          `;
          grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
      });
      input.value = '';
    }
    
    function removeKostuemBildMulti(type, index) {
      const bilder = type === 'kostuem' 
        ? (state.editingKostuem.kostuemBilder || [])
        : (state.editingKostuem.maskeBilder || []);
      
      if (bilder[index]) {
        const imgId = bilder[index];
        bilder.splice(index, 1);
        deleteImageFromDB(imgId);
        
        if (type === 'kostuem') {
          state.editingKostuem.kostuemBilder = bilder;
        } else {
          state.editingKostuem.maskeBilder = bilder;
        }
        render();
      }
    }

    // ============================================
    // B√úHNE MODAL (v1.3)
    // ============================================
    let pendingBuehneImages = [];
    
    function renderBuehneModal() {
      const b = state.editingBuehne || {};
      const isEdit = !!b.id;
      
      return `
        <div class="modal-overlay" onclick="closeModal('showBuehneModal')">
          <div class="modal-content" style="max-width: 700px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è B√ºhnenelement bearbeiten' : 'üé™ Neues B√ºhnenelement'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showBuehneModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                  <input type="text" id="buehne-name" value="${b.name || ''}" placeholder="Grundriss Akt 1">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Kategorie</label>
                  <select id="buehne-kategorie">
                    <option value="Grundriss" ${b.kategorie === 'Grundriss' ? 'selected' : ''}>Grundriss</option>
                    <option value="Skizze" ${b.kategorie === 'Skizze' ? 'selected' : ''}>Skizze</option>
                    <option value="Foto" ${b.kategorie === 'Foto' ? 'selected' : ''}>Foto</option>
                    <option value="Technischer Plan" ${b.kategorie === 'Technischer Plan' ? 'selected' : ''}>Technischer Plan</option>
                    <option value="Referenz" ${b.kategorie === 'Referenz' ? 'selected' : ''}>Referenz</option>
                    <option value="Sonstiges" ${b.kategorie === 'Sonstiges' || !b.kategorie ? 'selected' : ''}>Sonstiges</option>
                  </select>
                </div>
              </div>
              
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea id="buehne-beschreibung" rows="2" placeholder="Beschreibung des Elements">${b.beschreibung || ''}</textarea>
              </div>
              
              <!-- Bilder -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Bilder</label>
                <div class="image-grid" id="buehne-bilder-grid">
                  ${(b.bilder || []).map((imgId, i) => `
                    <div class="relative">
                      <img src="${imageUrlCache[imgId] || ''}" class="image-thumb" id="buehne-edit-img-${i}">
                      <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                              onclick="removeBuehneImage(${i})">‚úï</button>
                    </div>
                  `).join('')}
                  <div class="add-image-btn" onclick="document.getElementById('buehne-image-input').click()">+</div>
                </div>
                <input type="file" id="buehne-image-input" accept="image/*" multiple class="hidden" onchange="addBuehneImages(this)">
              </div>
              
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Notizen</label>
                <input type="text" id="buehne-notizen" value="${b.notizen || ''}" placeholder="Zus√§tzliche Hinweise">
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteBuehne('${b.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showBuehneModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveBuehne()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    function addBuehneImages(input) {
      const files = Array.from(input.files);
      files.forEach(file => {
        pendingBuehneImages.push(file);
        const reader = new FileReader();
        reader.onload = (e) => {
          const grid = document.getElementById('buehne-bilder-grid');
          const addBtn = grid.querySelector('.add-image-btn');
          const div = document.createElement('div');
          div.className = 'relative';
          div.innerHTML = `
            <img src="${e.target.result}" class="image-thumb">
            <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                    onclick="this.parentElement.remove(); pendingBuehneImages.pop();">‚úï</button>
          `;
          grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
      });
      input.value = '';
    }
    
    function removeBuehneImage(index) {
      if (state.editingBuehne?.bilder) {
        const imgId = state.editingBuehne.bilder[index];
        state.editingBuehne.bilder.splice(index, 1);
        if (imgId) deleteImageFromDB(imgId);
        render();
      }
    }

    // ============================================
    // REQUISITEN MODAL (v1.3)
    // ============================================
    let pendingRequisitenImages = [];
    
    function renderRequisitenModal() {
      const r = state.editingRequisit || {};
      const isEdit = !!r.id;
      
      return `
        <div class="modal-overlay" onclick="closeModal('showRequisitenModal')">
          <div class="modal-content" style="max-width: 700px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">${isEdit ? '‚úèÔ∏è Requisite bearbeiten' : 'üé≠ Neue Requisite'}</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeModal('showRequisitenModal')">‚úï</button>
            </div>
            <div class="modal-body">
              <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                  <input type="text" id="requisit-name" value="${r.name || ''}" placeholder="Weinglas">
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1">Zust√§ndig</label>
                  <input type="text" id="requisit-zustaendig" value="${r.zustaendig || ''}" placeholder="Name der zust√§ndigen Person">
                </div>
              </div>
              
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Beschreibung</label>
                <textarea id="requisit-beschreibung" rows="2" placeholder="Kristallglas, muss zerbrechlich aussehen">${r.beschreibung || ''}</textarea>
              </div>
              
              <!-- Szenen -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Szenen</label>
                <div class="max-h-24 overflow-y-auto border rounded p-2">
                  ${state.szenen.length === 0 ? '<span class="text-xs text-gray-400">Keine Szenen vorhanden</span>' : 
                    state.szenen.map(s => `
                    <label class="checkbox-item">
                      <input type="checkbox" class="requisit-szene-check" value="${s.id}" 
                             ${r.szenen?.includes(s.id) ? 'checked' : ''}>
                      <span class="text-sm">${s.nummer} ${s.titel}</span>
                    </label>
                  `).join('')}
                </div>
              </div>
              
              <!-- Bilder -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Bilder</label>
                <div class="image-grid" id="requisit-bilder-grid">
                  ${(r.bilder || []).map((imgId, i) => `
                    <div class="relative">
                      <img src="${imageUrlCache[imgId] || ''}" class="image-thumb" id="requisit-edit-img-${i}">
                      <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                              onclick="removeRequisitenImage(${i})">‚úï</button>
                    </div>
                  `).join('')}
                  <div class="add-image-btn" onclick="document.getElementById('requisit-image-input').click()">+</div>
                </div>
                <input type="file" id="requisit-image-input" accept="image/*" multiple class="hidden" onchange="addRequisitenImages(this)">
              </div>
              
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Notizen</label>
                <input type="text" id="requisit-notizen" value="${r.notizen || ''}" placeholder="Zus√§tzliche Hinweise">
              </div>
              
              <div class="flex gap-2 mt-6">
                ${isEdit ? `<button class="btn btn-danger" onclick="deleteRequisit('${r.id}')">üóëÔ∏è¬è L√∂schen</button>` : ''}
                <button class="btn btn-outline flex-1" onclick="closeModal('showRequisitenModal')">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="saveRequisit()">üíæ Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    function addRequisitenImages(input) {
      const files = Array.from(input.files);
      files.forEach(file => {
        pendingRequisitenImages.push(file);
        const reader = new FileReader();
        reader.onload = (e) => {
          const grid = document.getElementById('requisit-bilder-grid');
          const addBtn = grid.querySelector('.add-image-btn');
          const div = document.createElement('div');
          div.className = 'relative';
          div.innerHTML = `
            <img src="${e.target.result}" class="image-thumb">
            <button class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs" 
                    onclick="this.parentElement.remove(); pendingRequisitenImages.pop();">‚úï</button>
          `;
          grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
      });
      input.value = '';
    }
    
    function removeRequisitenImage(index) {
      if (state.editingRequisit?.bilder) {
        const imgId = state.editingRequisit.bilder[index];
        state.editingRequisit.bilder.splice(index, 1);
        if (imgId) deleteImageFromDB(imgId);
        render();
      }
    }

    // ============================================
    // ACTION HANDLERS
    // ============================================
    function navigateTo(view) {
      // Vor dem View-Wechsel aktuellen Text speichern
      saveCurrentText();
      state.currentView = view;
      render();
    }

    function selectSzene(szeneId) {
      // Suchen-Bar schliessen bei Szenenwechsel
      const searchBar = document.getElementById('search-replace-bar');
      if (searchBar) { searchBar.remove(); searchReplaceVisible = false; }
      
      state.aktiveSzene = szeneId;
      state.undoStack = [];
      state.redoStack = [];
      lastUndoContent = '';
      render();
    }

    // v2.0: Szene frei verschieben (√ºber alle Akte/Gruppen hinweg)
    function moveSzene(szeneId, direction) {
      const idx = state.szenen.findIndex(s => s.id === szeneId);
      if (idx === -1) return;
      
      const newIdx = idx + direction;
      if (newIdx < 0 || newIdx >= state.szenen.length) return;
      
      // Einfach Array-Position tauschen (keine Nummern-√Ñnderung)
      const temp = state.szenen[idx];
      state.szenen[idx] = state.szenen[newIdx];
      state.szenen[newIdx] = temp;
      
      saveProjektDaten();
      render();
    }

    function updateSzene(szeneId, field, value) {
      const szene = state.szenen.find(s => s.id === szeneId);
      if (szene) {
        szene[field] = value;
        saveProjektDaten();
        render();
      }
    }

    function toggleFigurInSzene(szeneId, figurId, checked) {
      const szene = state.szenen.find(s => s.id === szeneId);
      if (!szene) return;
      
      if (!szene.figuren) szene.figuren = [];
      
      if (checked && !szene.figuren.includes(figurId)) {
        szene.figuren.push(figurId);
      } else if (!checked) {
        szene.figuren = szene.figuren.filter(id => id !== figurId);
      }
      
      saveProjektDaten();
      render();
    }

    function toggleGestrichenes(show) {
      state.showGestrichenes = show;
      render();
    }

    function applySelectedFormat() {
      const select = document.getElementById('format-select');
      if (select) {
        state.selectedFormat = select.value;
        applyFormat(state.selectedFormat);
      }
    }

    // Modal Handlers
    function openModal(modalName) {
      state[modalName] = true;
      render();
    }

    function closeModal(modalName) {
      state[modalName] = false;
      state.editingFigur = null;
      state.editingCue = null;
      state.editingSzene = null;
      state.editingKostuem = null;
      state.editingMedium = null;
      if (modalName === 'showProjektModal') {
        editingProjekt = null;
        pendingTitelbild = null;
      }
      render();
    }

    function openFigurModal(figurId = null) {
      if (figurId) {
        state.editingFigur = { ...state.figuren.find(f => f.id === figurId) };
      } else {
        state.editingFigur = { name: '', kuerzel: '', beschreibung: '', want: '', need: '', wunde: '', geheimnis: '' };
      }
      state.showFigurModal = true;
      render();
    }

    function editFigur(figurId) {
      openFigurModal(figurId);
    }

    function saveFigur() {
      const name = document.getElementById('figur-name').value.trim().toUpperCase();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      
      const data = {
        name: name,
        kuerzel: document.getElementById('figur-kuerzel').value.trim().toUpperCase() || name.substring(0, 2),
        beschreibung: document.getElementById('figur-beschreibung').value.trim(),
        want: document.getElementById('figur-want').value.trim(),
        need: document.getElementById('figur-need').value.trim(),
        wunde: document.getElementById('figur-wunde').value.trim(),
        geheimnis: document.getElementById('figur-geheimnis').value.trim(),
      };
      
      if (state.editingFigur?.id) {
        // Update
        const idx = state.figuren.findIndex(f => f.id === state.editingFigur.id);
        if (idx !== -1) {
          state.figuren[idx] = { ...state.figuren[idx], ...data };
        }
      } else {
        // Create
        state.figuren.push({ id: genId(), ...data });
      }
      
      saveProjektDaten();
      closeModal('showFigurModal');
    }

    function deleteFigur(figurId) {
      if (!confirm('Figur wirklich l√∂schen?')) return;
      state.figuren = state.figuren.filter(f => f.id !== figurId);
      // Auch aus Szenen entfernen
      state.szenen.forEach(s => {
        if (s.figuren) {
          s.figuren = s.figuren.filter(id => id !== figurId);
        }
      });
      saveProjektDaten();
      closeModal('showFigurModal');
    }

    function openCueModal(typ = 'lx') {
      state.editingCue = { typ: typ, nummer: '', beschreibung: '', szeneId: state.aktiveSzene, ausloeser: '', dauer: '', ankerText: '' };
      state.showCueModal = true;
      render();
      // Nach Render das Typ-Handling aktivieren
      setTimeout(updateCueModalForTyp, 50);
    }

    function editCue(cueId) {
      const cue = state.cues.find(c => c.id === cueId);
      if (cue) {
        state.editingCue = { ...cue };
        state.showCueModal = true;
        render();
        setTimeout(updateCueModalForTyp, 50);
      }
    }

    // NEU: Cue erstellen mit markiertem Text als Anker
    function createCueFromSelection(typ = 'lx') {
      const selection = window.getSelection();
      let ankerText = '';
      
      if (selection && selection.toString().trim()) {
        ankerText = selection.toString().trim();
        // Auf max 200 Zeichen begrenzen
        if (ankerText.length > 200) {
          ankerText = ankerText.substring(0, 200) + '...';
        }
      }
      
      if (!ankerText) {
        alert('Bitte zuerst einen Text im Textbuch markieren.\n\nDieser Text wird als Positions-Anker f√ºr den Cue verwendet.');
        return;
      }
      
      state.editingCue = { 
        typ: typ, 
        nummer: '', 
        beschreibung: '', 
        szeneId: state.aktiveSzene, 
        ausloeser: '', 
        dauer: '', 
        ankerText: ankerText 
      };
      state.showCueModal = true;
      render();
      setTimeout(updateCueModalForTyp, 50);
    }

    function saveCue() {
      const typ = document.getElementById('cue-typ').value;
      const nummer = parseInt(document.getElementById('cue-nummer').value) || 1;
      const szeneId = document.getElementById('cue-szene').value;
      
      let requisitenId = null;
      let mediumId = null;
      let mediumGeplant = null;
      
      // Bei Requisiten-Cue: Verkn√ºpfung oder neue Requisite
      if (typ === 'r') {
        const reqSelect = document.getElementById('cue-requisite');
        const reqNeu = document.getElementById('cue-requisite-neu');
        
        if (reqSelect?.value) {
          // Bestehende Requisite verkn√ºpfen
          requisitenId = reqSelect.value;
          // Szene zur Requisite hinzuf√ºgen falls nicht vorhanden
          if (szeneId) {
            const req = state.requisiten.find(r => r.id === requisitenId);
            if (req && !req.szenen?.includes(szeneId)) {
              if (!req.szenen) req.szenen = [];
              req.szenen.push(szeneId);
            }
          }
        } else if (reqNeu?.value.trim()) {
          // Neue Requisite erstellen
          const neueRequisite = {
            id: genId(),
            name: reqNeu.value.trim(),
            beschreibung: '',
            zustaendig: '',
            szenen: szeneId ? [szeneId] : [],
            bilder: [],
            notizen: '',
            erstelltVonCue: true
          };
          state.requisiten.push(neueRequisite);
          requisitenId = neueRequisite.id;
        }
      }
      
      // Bei Ton/Video-Cue: Medium verkn√ºpfen oder geplanten Namen speichern
      if (typ === 'q' || typ === 'v') {
        const medSelect = document.getElementById('cue-medium');
        const medGeplant = document.getElementById('cue-medium-geplant');
        
        if (medSelect?.value) {
          mediumId = medSelect.value;
          // Szene zum Medium hinzuf√ºgen
          if (szeneId) {
            const med = state.medien.find(m => m.id === mediumId);
            if (med && !med.szenen?.includes(szeneId)) {
              if (!med.szenen) med.szenen = [];
              med.szenen.push(szeneId);
            }
          }
        } else if (medGeplant?.value.trim()) {
          // Geplanter Ton/Video noch nicht importiert
          mediumGeplant = medGeplant.value.trim();
        }
      }
      
      // Basis-Daten
      const data = {
        typ,
        nummer,
        szeneId,
        beschreibung: document.getElementById('cue-beschreibung')?.value.trim() || '',
        ausloeser: document.getElementById('cue-ausloeser')?.value.trim() || '',
        dauer: document.getElementById('cue-dauer')?.value.trim() || '',
        ankerText: document.getElementById('cue-ankertext')?.value.trim() || '', // NEU
        requisitenId,
        mediumId,
        mediumGeplant,
      };
      
      // Umbau-spezifische Daten
      if (typ === 'u') {
        data.umbauVon = document.getElementById('cue-umbau-von')?.value || null;
        data.umbauNach = document.getElementById('cue-umbau-nach')?.value || null;
        
        // Umbau-Aktionen sammeln
        const aktionInputs = document.querySelectorAll('.umbau-aktion');
        data.umbauAktionen = Array.from(aktionInputs)
          .map(input => input.value.trim())
          .filter(v => v);
        
        // Requisiten AB/AUF
        const reqAbChecks = document.querySelectorAll('.umbau-req-ab:checked');
        const reqAufChecks = document.querySelectorAll('.umbau-req-auf:checked');
        data.requisitenAb = Array.from(reqAbChecks).map(cb => cb.value);
        data.requisitenAuf = Array.from(reqAufChecks).map(cb => cb.value);
        
        // Beschreibung automatisch generieren
        const vonName = state.buehne.find(b => b.id === data.umbauVon)?.name || '';
        const nachName = state.buehne.find(b => b.id === data.umbauNach)?.name || '';
        data.beschreibung = vonName && nachName ? `${vonName} ‚Üí ${nachName}` : 'Umbau';
      }
      
      if (state.editingCue?.id && state.cues.find(c => c.id === state.editingCue.id)) {
        // Update
        const idx = state.cues.findIndex(c => c.id === state.editingCue.id);
        if (idx !== -1) {
          state.cues[idx] = { ...state.cues[idx], ...data };
        }
      } else {
        // Create
        state.cues.push({ id: genId(), ...data });
      }
      
      saveProjektDaten();
      closeModal('showCueModal');
    }

    function deleteCue(cueId) {
      if (!confirm('Cue wirklich l√∂schen?')) return;
      
      const cue = state.cues.find(c => c.id === cueId);
      
      // Bei Requisiten-Cue: Szene von Requisite entfernen
      if (cue?.requisitenId && cue.szeneId) {
        const req = state.requisiten.find(r => r.id === cue.requisitenId);
        if (req?.szenen) {
          req.szenen = req.szenen.filter(s => s !== cue.szeneId);
        }
      }
      
      // Bei Medien-Cue: Szene von Medium entfernen  
      if (cue?.mediumId && cue.szeneId) {
        const med = state.medien.find(m => m.id === cue.mediumId);
        if (med?.szenen) {
          med.szenen = med.szenen.filter(s => s !== cue.szeneId);
        }
      }
      
      state.cues = state.cues.filter(c => c.id !== cueId);
      saveProjektDaten();
      closeModal('showCueModal');
    }

    function openSzeneModal(szeneId = null) {
      if (szeneId) {
        state.editingSzene = { ...state.szenen.find(s => s.id === szeneId) };
      } else {
        const lastNr = state.szenen.length > 0 
          ? state.szenen[state.szenen.length - 1].nummer 
          : '0.0';
        const [akt, szene] = lastNr.split('.').map(Number);
        const newNr = szene >= 5 ? `${akt + 1}.1` : `${akt}.${szene + 1}`;
        // Letzte Gruppe √ºbernehmen
        const lastGruppe = state.szenen.length > 0 
          ? state.szenen[state.szenen.length - 1].gruppe || '1'
          : '1';
        state.editingSzene = { nummer: newNr, titel: '', ort: '', zeit: '', figuren: [], zusammenfassung: '', gruppe: lastGruppe };
      }
      state.showSzeneModal = true;
      render();
    }
    
    // Alias f√ºr Konsistenz mit anderen edit-Funktionen
    function editSzene(szeneId) {
      openSzeneModal(szeneId);
    }

    function saveSzene() {
      const titel = document.getElementById('szene-titel').value.trim();
      if (!titel) {
        alert('Bitte einen Titel eingeben.');
        return;
      }
      
      const data = {
        nummer: document.getElementById('szene-nummer').value.trim() || '1.1',
        titel: titel,
        ort: document.getElementById('szene-ort').value.trim(),
        zeit: document.getElementById('szene-zeit').value.trim(),
        zusammenfassung: document.getElementById('szene-zusammenfassung')?.value.trim() || '',
        gruppe: document.getElementById('szene-gruppe')?.value || '1',
      };
      
      if (state.editingSzene?.id) {
        // Update
        const idx = state.szenen.findIndex(s => s.id === state.editingSzene.id);
        if (idx !== -1) {
          state.szenen[idx] = { ...state.szenen[idx], ...data };
        }
      } else {
        // Create
        const newSzene = { id: genId(), ...data, figuren: [] };
        state.szenen.push(newSzene);
        state.aktiveSzene = newSzene.id;
      }
      
      saveProjektDaten();
      closeModal('showSzeneModal');
    }

    function deleteSzene(szeneId) {
      if (!confirm('Szene wirklich l√∂schen? Der Text wird auch gel√∂scht!')) return;
      state.szenen = state.szenen.filter(s => s.id !== szeneId);
      delete state.textbuch[szeneId];
      state.cues = state.cues.filter(c => c.szeneId !== szeneId);
      if (state.aktiveSzene === szeneId) {
        state.aktiveSzene = state.szenen[0]?.id || null;
      }
      saveProjektDaten();
      render();
    }
    
    // NEU v1.4: Formatierung bereinigen (Word-Styles entfernen)
    function cleanupFormatting() {
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) {
        alert('Bitte zuerst eine Szene ausw√§hlen.');
        return;
      }
      
      if (!confirm('Formatierung bereinigen?\n\nDies entfernt alle Word-Styles (Schriftgr√∂√üen, Farben, etc.) und beh√§lt nur die Regiebuch-Formatvorlagen.')) {
        return;
      }
      
      // Undo speichern
      pushUndo();
      
      // HTML des Editors holen
      let html = editor.innerHTML;
      
      // 1. Alle style-Attribute entfernen
      html = html.replace(/\s*style="[^"]*"/gi, '');
      
      // 2. Alle class-Attribute entfernen die NICHT unsere Format-Klassen sind
      // Aber format-* Klassen behalten
      html = html.replace(/\s*class="(?!format-|figur-name|dialog-text|cue-marker|cue-badge)[^"]*"/gi, '');
      
      // 3. Leere spans entfernen: <span>text</span> ‚Üí text
      html = html.replace(/<span>([^<]*)<\/span>/gi, '$1');
      
      // 4. Word-spezifische Tags entfernen
      html = html.replace(/<\/?o:[^>]*>/gi, ''); // Office namespace
      html = html.replace(/<\/?w:[^>]*>/gi, '');
      html = html.replace(/<\/?m:[^>]*>/gi, '');
      
      // 5. Verschachtelte b/strong und i/em vereinfachen
      html = html.replace(/<(b|strong)>\s*<(b|strong)>/gi, '<strong>');
      html = html.replace(/<\/(b|strong)>\s*<\/(b|strong)>/gi, '</strong>');
      html = html.replace(/<(i|em)>\s*<(i|em)>/gi, '<em>');
      html = html.replace(/<\/(i|em)>\s*<\/(i|em)>/gi, '</em>');
      
      // 6. font-Tags entfernen
      html = html.replace(/<font[^>]*>([^<]*)<\/font>/gi, '$1');
      
      // 7. Normale Abs√§tze ohne Klasse bekommen format-standard
      html = html.replace(/<p>(?!<)/gi, '<p class="format-standard">');
      
      // Zur√ºck in Editor
      editor.innerHTML = html;
      saveCurrentText();
      
      alert('‚úÖ Formatierung bereinigt!\n\nAlle Word-Styles wurden entfernt.');
    }
    
    // v1.4: Akt-Titel formatieren (erstellt nur neue Szene wenn Text davor)
    function createActFromTitle(titelText, sourceNode) {
      if (!state.aktiveSzene) return;
      
      const aktuelleSzene = state.szenen.find(s => s.id === state.aktiveSzene);
      if (!aktuelleSzene) return;
      
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Finde das Akt-Titel Element im Editor
      const aktTitelElemente = editor.querySelectorAll('.format-akt-titel');
      let aktTitelElement = null;
      for (const el of aktTitelElemente) {
        if (el.textContent.includes(titelText) || el.textContent === titelText) {
          aktTitelElement = el;
          break;
        }
      }
      
      if (!aktTitelElement) return;
      
      // Pr√ºfen ob "echter" Text VOR dem Akt-Titel existiert
      let hatEchtenTextDavor = false;
      let prevEl = aktTitelElement.previousElementSibling;
      while (prevEl) {
        const text = prevEl.textContent.trim();
        const isEmpty = !text || text === '' || prevEl.innerHTML === '<br>';
        
        if (!isEmpty) {
          hatEchtenTextDavor = true;
          break;
        }
        prevEl = prevEl.previousElementSibling;
      }
      
      // Akt-Nummer aus Text extrahieren
      let neueGruppe = '1';
      const aktMatch = titelText.match(/^(\d+)\.\s*AKT/i);
      if (aktMatch) {
        neueGruppe = aktMatch[1];
      } else {
        const existingGroups = [...new Set(state.szenen.map(s => s.gruppe || '1'))];
        const maxGroup = Math.max(...existingGroups.map(g => parseInt(g) || 1));
        neueGruppe = String(maxGroup + 1);
      }
      
      // FALL 1: Kein Text davor ‚Üí Nur Gruppe der aktuellen Szene √§ndern
      if (!hatEchtenTextDavor) {
        aktuelleSzene.gruppe = neueGruppe;
        aktuelleSzene.nummer = neueGruppe + '.' + (aktuelleSzene.nummer.split('.')[1] || '1');
        sortSzenen();
        saveProjektDaten();
        render();
        // Keine Meldung - einfach weiterarbeiten
        return;
      }
      
      // FALL 2: Text davor ‚Üí Neue Szene erstellen
      // Alle Elemente AB dem Akt-Titel sammeln (inklusive Akt-Titel)
      const elementsToMove = [aktTitelElement.outerHTML];
      let currentEl = aktTitelElement.nextElementSibling;
      while (currentEl) {
        elementsToMove.push(currentEl.outerHTML);
        currentEl = currentEl.nextElementSibling;
      }
      
      // Elemente AB dem Akt-Titel entfernen
      currentEl = aktTitelElement;
      while (currentEl) {
        const next = currentEl.nextElementSibling;
        currentEl.remove();
        currentEl = next;
      }
      
      // Aktuelle Szene speichern
      const alteSzeneContent = editor.innerHTML;
      state.textbuch[state.aktiveSzene] = alteSzeneContent;
      saveProjektDaten();
      
      // Neue Szene im neuen Akt erstellen
      const neueSzeneId = genId();
      const neueSzene = {
        id: neueSzeneId,
        nummer: neueGruppe + '.1',
        titel: 'Neue Szene',
        gruppe: neueGruppe,
        ort: '',
        zeit: '',
        zusammenfassung: '',
        figuren: []
      };
      
      state.szenen.push(neueSzene);
      state.textbuch[neueSzeneId] = elementsToMove.join('\n') || '<p class="format-standard"><br></p>';
      
      sortSzenen();
      saveProjektDaten();
      
      const szeneInfo = neueSzene.nummer;
      
      // Warten bis alles fertig ist, dann Szene wechseln
      setTimeout(() => {
        selectSzene(neueSzeneId);
        setTimeout(() => {
          alert(`‚úÖ Neuer Akt erstellt!\n\nSzene ${szeneInfo} wurde angelegt.\nMarkiere jetzt den Szenen-Titel um die Szene zu benennen.`);
        }, 100);
      }, 200);
    }
    
    // v1.4: Neue Szene aus Szenen-Titel erstellen
    function createSceneFromTitle(titelText, sourceNode) {
      if (!state.aktiveSzene) return;
      
      const aktuelleSzene = state.szenen.find(s => s.id === state.aktiveSzene);
      if (!aktuelleSzene) return;
      
      const editor = document.getElementById('text-editor');
      if (!editor) return;
      
      // Nummer aus Text extrahieren (z.B. "1.2 Prolog" ‚Üí "1.2")
      const nummerMatch = titelText.match(/^(\d+\.?\d*)\s*[-‚Äì]?\s*/);
      let nummer = '';
      let titel = titelText;
      
      if (nummerMatch) {
        let extractedNum = nummerMatch[1];
        if (!extractedNum.includes('.')) {
          extractedNum = aktuelleSzene.gruppe + '.' + extractedNum;
        }
        nummer = extractedNum;
        titel = titelText.substring(nummerMatch[0].length).trim();
        titel = titel.replace(/^[-‚Äì]\s*/, '');
      } else {
        titel = titelText;
      }
      
      // Finde das Szenen-Titel Element im Editor
      const szeneTitelElemente = editor.querySelectorAll('.format-szene-titel');
      let szeneTitelElement = null;
      for (const el of szeneTitelElemente) {
        if (el.textContent.includes(titel) || el.textContent.includes(titelText) || el.textContent === titelText) {
          szeneTitelElement = el;
          break;
        }
      }
      
      if (!szeneTitelElement) return;
      
      // Pr√ºfen ob NUR Akt-Titel oder leere Elemente VOR dem Szenen-Titel sind
      // In diesem Fall: Nur die aktuelle Szene umbenennen, KEINE neue Szene
      let hatEchtenTextDavor = false;
      let prevEl = szeneTitelElement.previousElementSibling;
      while (prevEl) {
        const text = prevEl.textContent.trim();
        const isAktTitel = prevEl.classList.contains('format-akt-titel');
        const isSzeneTitel = prevEl.classList.contains('format-szene-titel');
        const isEmpty = !text || text === '' || prevEl.innerHTML.replace(/<br\s*\/?>/gi, '').trim() === '';
        
        // Wenn ein anderer Szenen-Titel davor ist, ist das "echter Text"
        if (isSzeneTitel) {
          hatEchtenTextDavor = true;
          break;
        }
        
        // Akt-Titel und leere Elemente √ºberspringen
        if (!isAktTitel && !isEmpty) {
          hatEchtenTextDavor = true;
          break;
        }
        prevEl = prevEl.previousElementSibling;
      }
      
      // FALL 1: Kein echter Text davor (direkt nach Akt-Titel oder am Anfang)
      // ‚Üí Nur den Titel der aktuellen Szene √§ndern, KEINE neue Szene
      if (!hatEchtenTextDavor) {
        if (!titel) titel = titelText.replace(/^\d+\.?\d*\s*[-‚Äì]?\s*/, '').trim();
        
        // Aktuelle Szene umbenennen
        aktuelleSzene.titel = titel;
        
        // Nummer anpassen wenn extrahiert
        if (nummer && nummer !== aktuelleSzene.nummer) {
          aktuelleSzene.nummer = nummer;
        }
        
        sortSzenen();
        saveProjektDaten();
        render();
        
        // Keine Meldung, da keine neue Szene erstellt wurde
        return;
      }
      
      // FALL 2: Echter Text davor ‚Üí Neue Szene erstellen
      if (!nummer) {
        const gruppe = aktuelleSzene.gruppe || '1';
        const szenenInGruppe = state.szenen
          .filter(s => s.gruppe === gruppe)
          .sort((a, b) => parseFloat(a.nummer) - parseFloat(b.nummer));
        
        // H√∂chste Szenen-Nummer in dieser Gruppe finden
        let maxSubNummer = 0;
        szenenInGruppe.forEach(s => {
          const parts = s.nummer.split('.');
          if (parts.length > 1) {
            const sub = parseInt(parts[1]) || 0;
            if (sub > maxSubNummer) maxSubNummer = sub;
          }
        });
        
        nummer = gruppe + '.' + (maxSubNummer + 1);
      }
      
      if (!titel) titel = titelText;
      
      // Fragen ob neue Szene erstellt werden soll
      const confirmMsg = `üìÑ Neue Szene aus Titel erstellen?\n\n` +
        `Aktuelle Szene: ${aktuelleSzene.nummer} ${aktuelleSzene.titel}\n` +
        `Neue Szene: ${nummer} "${titel}"\n\n` +
        `Was passiert:\n` +
        `‚Ä¢ Text VOR diesem Titel ‚Üí bleibt in Szene ${aktuelleSzene.nummer}\n` +
        `‚Ä¢ Text AB diesem Titel ‚Üí wird zu Szene ${nummer}\n\n` +
        `Fortfahren?`;
      
      if (!confirm(confirmMsg)) {
        return;
      }
      
      // Alle Elemente AB dem Szenen-Titel sammeln (inklusive Titel)
      const elementsToMove = [szeneTitelElement.outerHTML];
      let currentEl = szeneTitelElement.nextElementSibling;
      while (currentEl) {
        elementsToMove.push(currentEl.outerHTML);
        currentEl = currentEl.nextElementSibling;
      }
      
      // Elemente AB dem Szenen-Titel entfernen
      currentEl = szeneTitelElement;
      while (currentEl) {
        const next = currentEl.nextElementSibling;
        currentEl.remove();
        currentEl = next;
      }
      
      // Aktuelle Szene speichern
      const alteSzeneContent = editor.innerHTML;
      state.textbuch[state.aktiveSzene] = alteSzeneContent;
      saveProjektDaten();
      
      // Neue Szene erstellen
      const neueSzeneId = genId();
      const neueSzene = {
        id: neueSzeneId,
        nummer: nummer,
        titel: titel,
        gruppe: aktuelleSzene.gruppe || '1',
        ort: '',
        zeit: '',
        zusammenfassung: '',
        figuren: aktuelleSzene.figuren || []
      };
      
      state.szenen.push(neueSzene);
      state.textbuch[neueSzeneId] = elementsToMove.join('\n') || '<p class="format-standard"><br></p>';
      
      sortSzenen();
      saveProjektDaten();
      
      const neueNummer = nummer;
      const neuerTitel = titel;
      
      // Warten bis confirm-Dialog komplett weg ist, dann Szene wechseln
      setTimeout(() => {
        selectSzene(neueSzeneId);
        setTimeout(() => {
          alert(`‚úÖ Neue Szene ${neueNummer} "${neuerTitel}" erstellt!`);
        }, 100);
      }, 200);
    }
    
    // NEU v1.4: Szene an Cursor-Position teilen
    function splitSzeneAtCursor() {
      const editor = document.getElementById('text-editor');
      if (!editor || !state.aktiveSzene) {
        alert('Bitte zuerst eine Szene ausw√§hlen.');
        return;
      }
      
      const selection = window.getSelection();
      if (!selection.rangeCount) {
        alert('Bitte den Cursor an die Stelle setzen, wo die neue Szene beginnen soll.');
        return;
      }
      
      const range = selection.getRangeAt(0);
      
      // Pr√ºfen ob Cursor im Editor ist
      if (!editor.contains(range.startContainer)) {
        alert('Bitte den Cursor im Text platzieren, wo geteilt werden soll.');
        return;
      }
      
      // Aktuelle Szene finden
      const aktuelleSzene = state.szenen.find(s => s.id === state.aktiveSzene);
      if (!aktuelleSzene) return;
      
      // Text vor dem Cursor (bleibt in aktueller Szene)
      const rangeVor = document.createRange();
      rangeVor.setStart(editor, 0);
      rangeVor.setEnd(range.startContainer, range.startOffset);
      
      const tempDivVor = document.createElement('div');
      tempDivVor.appendChild(rangeVor.cloneContents());
      const textVor = stripCueMarkers(tempDivVor.innerHTML);
      
      // Text nach dem Cursor (wird neue Szene)
      const rangeNach = document.createRange();
      rangeNach.setStart(range.startContainer, range.startOffset);
      rangeNach.setEndAfter(editor.lastChild || editor);
      
      const tempDivNach = document.createElement('div');
      tempDivNach.appendChild(rangeNach.cloneContents());
      const textNach = stripCueMarkers(tempDivNach.innerHTML);
      
      // Pr√ºfen ob beide Teile Inhalt haben
      const textVorClean = textVor.replace(/<[^>]+>/g, '').trim();
      const textNachClean = textNach.replace(/<[^>]+>/g, '').trim();
      
      if (!textVorClean || !textNachClean) {
        alert('Beide Teile m√ºssen Text enthalten. Bitte den Cursor anders platzieren.');
        return;
      }
      
      // Neue Szenennummer berechnen
      const altNr = aktuelleSzene.nummer;
      const [akt, szene] = altNr.split('.').map(Number);
      const neueNr = `${akt}.${szene + 1}`;
      
      // Best√§tigung
      if (!confirm(`Szene "${altNr}" hier teilen?\n\nText vor dem Cursor bleibt in Szene ${altNr}.\nText nach dem Cursor wird neue Szene ${neueNr}.`)) {
        return;
      }
      
      // Text in aktueller Szene aktualisieren
      state.textbuch[state.aktiveSzene] = textVor;
      
      // Neue Szene erstellen
      const neueSzene = {
        id: genId(),
        nummer: neueNr,
        titel: `Teil ${szene + 1}`,
        ort: aktuelleSzene.ort,
        zeit: aktuelleSzene.zeit,
        gruppe: aktuelleSzene.gruppe,
        zusammenfassung: '',
        figuren: [...(aktuelleSzene.figuren || [])]
      };
      
      // Szene an richtiger Stelle einf√ºgen (nach aktueller Szene)
      const idx = state.szenen.findIndex(s => s.id === state.aktiveSzene);
      state.szenen.splice(idx + 1, 0, neueSzene);
      
      // Text f√ºr neue Szene speichern
      state.textbuch[neueSzene.id] = textNach;
      
      // Nachfolgende Szenen umnummerieren (wenn gew√ºnscht)
      // TODO: Optional
      
      saveProjektDaten();
      
      // Zur neuen Szene wechseln
      state.aktiveSzene = neueSzene.id;
      render();
      
      // Hinweis anzeigen
      alert(`‚úÖ Szene geteilt!\n\nNeue Szene "${neueNr}" wurde erstellt.\nBitte Titel und Zusammenfassung anpassen.`);
      
      // Modal zum Bearbeiten √∂ffnen
      setTimeout(() => editSzene(neueSzene.id), 100);
    }

    // v1.2: Kost√ºm-Handler
    async function openKostuemModal(kostuemId = null) {
      // Reset pending images
      pendingKostuemBilder = [];
      pendingMaskeBilder = [];
      
      if (kostuemId) {
        const kostuem = state.kostueme.find(k => k.id === kostuemId);
        state.editingKostuem = { ...kostuem };
        
        // Migration: alte Einzelbilder zu Arrays konvertieren
        if (!state.editingKostuem.kostuemBilder && kostuem.kostuemBildId) {
          state.editingKostuem.kostuemBilder = [kostuem.kostuemBildId];
        }
        if (!state.editingKostuem.maskeBilder && kostuem.maskeBildId) {
          state.editingKostuem.maskeBilder = [kostuem.maskeBildId];
        }
        
        // Bilder vorladen
        const allImages = [...(state.editingKostuem.kostuemBilder || []), ...(state.editingKostuem.maskeBilder || [])];
        for (const imgId of allImages) {
          await getImageUrl(imgId);
        }
      } else {
        state.editingKostuem = { 
          name: '', figur: '', beschreibung: '', maske: '', szenen: [], notizen: '',
          kostuemBilder: [], maskeBilder: []
        };
      }
      state.showKostuemModal = true;
      render();
    }

    function editKostuem(kostuemId) {
      openKostuemModal(kostuemId);
    }

    async function saveKostuem() {
      const name = document.getElementById('kostuem-name').value.trim();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      
      const szenenChecks = document.querySelectorAll('.kostuem-szene-check:checked');
      const szenen = Array.from(szenenChecks).map(cb => cb.value);
      
      const kostuemId = state.editingKostuem?.id || genId();
      
      // Bestehende Bilder √ºbernehmen
      let kostuemBilder = state.editingKostuem?.kostuemBilder || [];
      let maskeBilder = state.editingKostuem?.maskeBilder || [];
      
      // Neue Kost√ºm-Bilder speichern
      for (let i = 0; i < pendingKostuemBilder.length; i++) {
        const imgId = `img_kostuem_${kostuemId}_${Date.now()}_${i}`;
        await saveImageToDB(imgId, pendingKostuemBilder[i]);
        kostuemBilder.push(imgId);
      }
      
      // Neue Maske-Bilder speichern
      for (let i = 0; i < pendingMaskeBilder.length; i++) {
        const imgId = `img_maske_${kostuemId}_${Date.now()}_${i}`;
        await saveImageToDB(imgId, pendingMaskeBilder[i]);
        maskeBilder.push(imgId);
      }
      
      const data = {
        id: kostuemId,
        name: name,
        figur: document.getElementById('kostuem-figur').value,
        beschreibung: document.getElementById('kostuem-beschreibung').value.trim(),
        maske: document.getElementById('kostuem-maske').value.trim(),
        szenen: szenen,
        notizen: document.getElementById('kostuem-notizen').value.trim(),
        kostuemBilder: kostuemBilder,
        maskeBilder: maskeBilder,
      };
      
      if (state.editingKostuem?.id) {
        // Update
        const idx = state.kostueme.findIndex(k => k.id === state.editingKostuem.id);
        if (idx !== -1) {
          state.kostueme[idx] = data;
        }
      } else {
        // Create
        state.kostueme.push(data);
      }
      
      // Reset pending
      pendingKostuemBilder = [];
      pendingMaskeBilder = [];
      
      saveProjektDaten();
      closeModal('showKostuemModal');
    }

    async function deleteKostuem(kostuemId) {
      if (!confirm('Kost√ºm wirklich l√∂schen?')) return;
      
      const kostuem = state.kostueme.find(k => k.id === kostuemId);
      
      // Alle Bilder l√∂schen
      if (kostuem?.kostuemBilder) {
        for (const imgId of kostuem.kostuemBilder) {
          await deleteImageFromDB(imgId);
        }
      }
      if (kostuem?.maskeBilder) {
        for (const imgId of kostuem.maskeBilder) {
          await deleteImageFromDB(imgId);
        }
      }
      // Fallback f√ºr alte Daten
      if (kostuem?.kostuemBildId) await deleteImageFromDB(kostuem.kostuemBildId);
      if (kostuem?.maskeBildId) await deleteImageFromDB(kostuem.maskeBildId);
      
      state.kostueme = state.kostueme.filter(k => k.id !== kostuemId);
      saveProjektDaten();
      closeModal('showKostuemModal');
    }

    // ============================================
    // B√úHNE HANDLER (v1.3)
    // ============================================
    async function openBuehneModal(buehneId = null) {
      pendingBuehneImages = [];
      
      if (buehneId) {
        const b = state.buehne.find(x => x.id === buehneId);
        state.editingBuehne = { ...b };
        // Bilder vorladen
        if (b.bilder) {
          for (const imgId of b.bilder) {
            await getImageUrl(imgId);
          }
        }
      } else {
        state.editingBuehne = { name: '', kategorie: 'Sonstiges', beschreibung: '', bilder: [], notizen: '' };
      }
      state.showBuehneModal = true;
      render();
    }
    
    function editBuehne(buehneId) {
      openBuehneModal(buehneId);
    }
    
    async function saveBuehne() {
      const name = document.getElementById('buehne-name').value.trim();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      
      const buehneId = state.editingBuehne?.id || genId();
      let bilder = state.editingBuehne?.bilder || [];
      
      // Neue Bilder speichern
      for (let i = 0; i < pendingBuehneImages.length; i++) {
        const imgId = `img_buehne_${buehneId}_${Date.now()}_${i}`;
        await saveImageToDB(imgId, pendingBuehneImages[i]);
        bilder.push(imgId);
      }
      
      const data = {
        id: buehneId,
        name: name,
        kategorie: document.getElementById('buehne-kategorie').value,
        beschreibung: document.getElementById('buehne-beschreibung').value.trim(),
        bilder: bilder,
        notizen: document.getElementById('buehne-notizen').value.trim(),
      };
      
      if (state.editingBuehne?.id) {
        const idx = state.buehne.findIndex(b => b.id === state.editingBuehne.id);
        if (idx !== -1) state.buehne[idx] = data;
      } else {
        state.buehne.push(data);
      }
      
      pendingBuehneImages = [];
      saveProjektDaten();
      closeModal('showBuehneModal');
    }
    
    async function deleteBuehne(buehneId) {
      if (!confirm('B√ºhnenelement wirklich l√∂schen?')) return;
      
      const b = state.buehne.find(x => x.id === buehneId);
      if (b?.bilder) {
        for (const imgId of b.bilder) {
          await deleteImageFromDB(imgId);
        }
      }
      
      state.buehne = state.buehne.filter(x => x.id !== buehneId);
      saveProjektDaten();
      closeModal('showBuehneModal');
    }

    // ============================================
    // REQUISITEN HANDLER (v1.3)
    // ============================================
    async function openRequisitenModal(reqId = null) {
      pendingRequisitenImages = [];
      
      if (reqId) {
        const r = state.requisiten.find(x => x.id === reqId);
        state.editingRequisit = { ...r };
        // Bilder vorladen
        if (r.bilder) {
          for (const imgId of r.bilder) {
            await getImageUrl(imgId);
          }
        }
      } else {
        state.editingRequisit = { name: '', zustaendig: '', beschreibung: '', szenen: [], bilder: [], notizen: '' };
      }
      state.showRequisitenModal = true;
      render();
    }
    
    function editRequisit(reqId) {
      openRequisitenModal(reqId);
    }
    
    async function saveRequisit() {
      const name = document.getElementById('requisit-name').value.trim();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      
      const szenenChecks = document.querySelectorAll('.requisit-szene-check:checked');
      const neueSzenen = Array.from(szenenChecks).map(cb => cb.value);
      
      const reqId = state.editingRequisit?.id || genId();
      let bilder = state.editingRequisit?.bilder || [];
      
      // Alte Szenen (f√ºr Vergleich)
      const alteSzenen = state.editingRequisit?.szenen || [];
      
      // Neue Bilder speichern
      for (let i = 0; i < pendingRequisitenImages.length; i++) {
        const imgId = `img_requisit_${reqId}_${Date.now()}_${i}`;
        await saveImageToDB(imgId, pendingRequisitenImages[i]);
        bilder.push(imgId);
      }
      
      const data = {
        id: reqId,
        name: name,
        zustaendig: document.getElementById('requisit-zustaendig').value.trim(),
        beschreibung: document.getElementById('requisit-beschreibung').value.trim(),
        szenen: neueSzenen,
        bilder: bilder,
        notizen: document.getElementById('requisit-notizen').value.trim(),
      };
      
      if (state.editingRequisit?.id) {
        const idx = state.requisiten.findIndex(r => r.id === state.editingRequisit.id);
        if (idx !== -1) state.requisiten[idx] = data;
      } else {
        state.requisiten.push(data);
      }
      
      // ========== CUE-SYNCHRONISATION ==========
      // Neue Szenen ‚Üí Cues erstellen
      const hinzugefuegteSzenen = neueSzenen.filter(s => !alteSzenen.includes(s));
      for (const szeneId of hinzugefuegteSzenen) {
        // Pr√ºfen ob Cue bereits existiert
        const existiertBereits = state.cues.some(c => 
          c.typ === 'r' && c.requisitenId === reqId && c.szeneId === szeneId
        );
        if (!existiertBereits) {
          // N√§chste freie Nummer f√ºr Requisiten-Cues in dieser Szene
          const reqCuesInSzene = state.cues.filter(c => c.typ === 'r' && c.szeneId === szeneId);
          const nextNummer = reqCuesInSzene.length > 0 
            ? Math.max(...reqCuesInSzene.map(c => c.nummer)) + 1 
            : 1;
          
          state.cues.push({
            id: genId(),
            typ: 'r',
            nummer: nextNummer,
            szeneId: szeneId,
            beschreibung: name,
            requisitenId: reqId,
            ausloeser: '',
            dauer: '',
          });
        }
      }
      
      // Entfernte Szenen ‚Üí Cues l√∂schen
      const entfernteSzenen = alteSzenen.filter(s => !neueSzenen.includes(s));
      for (const szeneId of entfernteSzenen) {
        state.cues = state.cues.filter(c => 
          !(c.typ === 'r' && c.requisitenId === reqId && c.szeneId === szeneId)
        );
      }
      // ==========================================
      
      pendingRequisitenImages = [];
      saveProjektDaten();
      closeModal('showRequisitenModal');
    }
    
    async function deleteRequisit(reqId) {
      if (!confirm('Requisite wirklich l√∂schen?')) return;
      
      const r = state.requisiten.find(x => x.id === reqId);
      if (r?.bilder) {
        for (const imgId of r.bilder) {
          await deleteImageFromDB(imgId);
        }
      }
      
      // Zugeh√∂rige Cues l√∂schen
      state.cues = state.cues.filter(c => !(c.typ === 'r' && c.requisitenId === reqId));
      
      state.requisiten = state.requisiten.filter(x => x.id !== reqId);
      saveProjektDaten();
      closeModal('showRequisitenModal');
    }

    // ============================================
    // EXPORT FUNKTIONEN (v1.3)
    // ============================================
    
    // Cue-Export Dialog
    let showCueExportDialog = false;
    
    function openCueExportDialog() {
      showCueExportDialog = true;
      render();
    }
    
    function closeCueExportDialog() {
      showCueExportDialog = false;
      render();
    }
    
    function renderCueExportDialog() {
      if (!showCueExportDialog) return '';
      
      return `
        <div class="modal-overlay" onclick="closeCueExportDialog()">
          <div class="modal-content" style="max-width: 450px;" onclick="event.stopPropagation()">
            <div class="modal-header">
              <h2 class="text-lg font-semibold">üìÑ Cue-Listen exportieren</h2>
              <button class="text-gray-400 hover:text-gray-600" onclick="closeCueExportDialog()">‚úï</button>
            </div>
            <div class="modal-body">
              <p class="text-sm text-gray-600 mb-4">W√§hle die Cue-Typen f√ºr den Export:</p>
              
              <!-- Schnellauswahl -->
              <div class="flex flex-wrap gap-2 mb-4">
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('all')">Alle (Inspizient)</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('lx')">Nur Licht</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('q')">Nur Ton</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('lx-q')">Licht + Ton</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('u')">Nur Umbau</button>
                <button class="btn btn-xs btn-outline" onclick="selectCueExportPreset('u-r')">Umbau + Requisiten</button>
              </div>
              
              <!-- Checkboxen -->
              <div class="border rounded p-3 mb-4">
                ${Object.entries(CUE_TYPEN).map(([key, typ]) => {
                  const count = state.cues.filter(c => c.typ === key).length;
                  return `
                    <label class="checkbox-item">
                      <input type="checkbox" id="cue-export-${key}" checked>
                      <span>${typ.icon} ${typ.name} (${typ.prefix})</span>
                      <span class="ml-auto text-xs text-gray-400">${count} Cues</span>
                    </label>
                  `;
                }).join('')}
              </div>
              
              <!-- Sortierung -->
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Sortierung:</label>
                <select id="cue-export-sort">
                  <option value="szene">Nach Szene (chronologisch)</option>
                  <option value="typ">Nach Typ (gruppiert)</option>
                </select>
              </div>
              
              <div class="flex gap-2">
                <button class="btn btn-outline flex-1" onclick="closeCueExportDialog()">Abbrechen</button>
                <button class="btn btn-primary flex-1" onclick="exportCueListen()">üìÑ Exportieren</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    function selectCueExportPreset(preset) {
      // Alle Checkboxen zur√ºcksetzen
      Object.keys(CUE_TYPEN).forEach(key => {
        const cb = document.getElementById('cue-export-' + key);
        if (cb) cb.checked = false;
      });
      
      // Preset ausw√§hlen
      let keys = [];
      switch(preset) {
        case 'all': keys = Object.keys(CUE_TYPEN); break;
        case 'lx': keys = ['lx']; break;
        case 'q': keys = ['q']; break;
        case 'lx-q': keys = ['lx', 'q']; break;
        case 'u': keys = ['u']; break;
        case 'u-r': keys = ['u', 'r']; break;
      }
      
      keys.forEach(key => {
        const cb = document.getElementById('cue-export-' + key);
        if (cb) cb.checked = true;
      });
    }
    
    // Export einzelner Cue-Typ direkt (ohne Checkbox-Dialog)
    function exportCueByType(typKey) {
      const selectedTypes = typKey === 'alle' ? Object.keys(CUE_TYPEN) : [typKey];
      const cues = state.cues.filter(c => selectedTypes.includes(c.typ));
      if (cues.length === 0) { alert('Keine Cues dieses Typs vorhanden.'); return; }
      
      // Sortieren nach Szene
      const sortedCues = cues.sort((a, b) => {
        const szeneA = state.szenen.find(s => s.id === a.szeneId);
        const szeneB = state.szenen.find(s => s.id === b.szeneId);
        const numA = szeneA?.nummer || '99.99';
        const numB = szeneB?.nummer || '99.99';
        if (numA !== numB) return numA.localeCompare(numB, undefined, { numeric: true });
        const typOrder = ['u', 'lx', 'q', 'v', 'r'];
        return typOrder.indexOf(a.typ) - typOrder.indexOf(b.typ);
      });
      
      const typNamen = selectedTypes.map(t => CUE_TYPEN[t]?.name || t).join(' + ');
      
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8">
        <title>Cue-Liste ${typNamen} - ${state.projektMeta.titel}</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 20px; font-size: 11pt; }
          h1 { font-size: 18pt; margin-bottom: 5px; }
          .meta { color: #666; margin-bottom: 20px; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: left; vertical-align: top; }
          th { background: #f0f0f0; font-weight: bold; }
          .cue-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 9pt; font-weight: bold; }
          .cue-lx { background: #fef3c7; color: #92400e; }
          .cue-q { background: #d1fae5; color: #065f46; }
          .cue-v { background: #e0e7ff; color: #3730a3; }
          .cue-r { background: #fce7f3; color: #9d174d; }
          .cue-u { background: #fed7aa; color: #9a3412; }
          .szene-header { background: #e5e7eb; }
          .stichwort { font-style: italic; color: #6b21a8; }
          @media print { .no-print { display: none; } tr { page-break-inside: avoid; } }
        </style>
      </head><body>`;
      
      html += `<div class="no-print" style="margin-bottom:20px;">
        <button onclick="window.print()" style="padding:10px 20px;font-size:14px;">Als PDF drucken</button>
      </div>`;
      
      html += `<h1>Cue-Liste: ${typNamen}</h1>`;
      html += `<p class="meta">${state.projektMeta.titel}<br>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      
      html += `<table><tr>
        <th style="width:80px;">Cue</th>
        <th>Beschreibung</th>
        <th style="width:200px;">Stichwort</th>
        <th style="width:60px;">Dauer</th>
      </tr>`;
      
      let currentSzene = null;
      sortedCues.forEach(c => {
        const szene = state.szenen.find(s => s.id === c.szeneId);
        const szeneKey = szene?.id || 'none';
        
        if (szeneKey !== currentSzene) {
          currentSzene = szeneKey;
          html += `<tr class="szene-header">
            <td colspan="4"><strong>${szene ? szene.nummer + ' ' + szene.titel : 'Ohne Szene'}</strong></td>
          </tr>`;
        }
        
        const typ = CUE_TYPEN[c.typ];
        let beschreibung = c.beschreibung || '‚Äì';
        let stichwort = c.ankerText ? `<em class="stichwort">${c.ankerText}</em>` : '‚Äì';
        
        if (c.typ === 'r' && c.requisitenId) {
          const req = state.requisiten.find(r => r.id === c.requisitenId);
          if (req) beschreibung = req.name + (c.beschreibung ? ': ' + c.beschreibung : '');
        } else if ((c.typ === 'q' || c.typ === 'v') && c.mediumId) {
          const med = state.medien.find(m => m.id === c.mediumId);
          if (med) beschreibung = med.name + (c.beschreibung ? ': ' + c.beschreibung : '');
        } else if (c.typ === 'u') {
          const vonName = c.umbauVon ? state.buehne.find(b => b.id === c.umbauVon)?.name : null;
          const nachName = c.umbauNach ? state.buehne.find(b => b.id === c.umbauNach)?.name : null;
          beschreibung = (vonName || '?') + ' ‚Üí ' + (nachName || '?');
        }
        
        html += `<tr>
          <td><span class="cue-badge ${typ.class}">${typ.prefix}${c.nummer}</span></td>
          <td>${beschreibung}</td>
          <td>${stichwort}</td>
          <td>${c.dauer || '‚Äì'}</td>
        </tr>`;
      });
      
      html += `</table></body></html>`;
      
      const exportTyp = typKey === 'alle' ? 'Alle-Cues' : CUE_TYPEN[typKey]?.name || typKey;
      openExportWindow(html, exportTyp + '-Liste');
    }
    
    function exportCueListen() {
      // Ausgew√§hlte Typen sammeln
      const selectedTypes = Object.keys(CUE_TYPEN).filter(key => {
        const cb = document.getElementById('cue-export-' + key);
        return cb?.checked;
      });
      
      if (selectedTypes.length === 0) {
        alert('Bitte mindestens einen Cue-Typ ausw√§hlen.');
        return;
      }
      
      const sortBy = document.getElementById('cue-export-sort')?.value || 'szene';
      
      // Cues filtern
      let cues = state.cues.filter(c => selectedTypes.includes(c.typ));
      
      // Sortieren
      if (sortBy === 'szene') {
        // Nach Szene sortieren (chronologisch)
        cues = cues.sort((a, b) => {
          const szeneA = state.szenen.find(s => s.id === a.szeneId);
          const szeneB = state.szenen.find(s => s.id === b.szeneId);
          const numA = szeneA?.nummer || '99.99';
          const numB = szeneB?.nummer || '99.99';
          if (numA !== numB) return numA.localeCompare(numB, undefined, { numeric: true });
          // Innerhalb einer Szene nach Typ-Reihenfolge
          const typOrder = ['u', 'lx', 'q', 'v', 'r'];
          return typOrder.indexOf(a.typ) - typOrder.indexOf(b.typ);
        });
      } else {
        // Nach Typ gruppiert
        cues = cues.sort((a, b) => {
          if (a.typ !== b.typ) return a.typ.localeCompare(b.typ);
          return a.nummer - b.nummer;
        });
      }
      
      // Titel f√ºr Export
      const typNamen = selectedTypes.map(t => CUE_TYPEN[t].name).join(' + ');
      
      // HTML generieren
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8">
        <title>Cue-Liste ${typNamen} - ${state.projektMeta.titel}</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 20px; font-size: 11pt; }
          h1 { font-size: 18pt; margin-bottom: 5px; }
          h2 { font-size: 14pt; margin: 20px 0 10px; padding-bottom: 5px; border-bottom: 2px solid #333; }
          .meta { color: #666; margin-bottom: 20px; }
          table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
          th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: left; vertical-align: top; }
          th { background: #f0f0f0; font-weight: bold; }
          .cue-badge { 
            display: inline-block; padding: 2px 8px; border-radius: 10px; 
            font-size: 9pt; font-weight: bold; margin-right: 5px;
          }
          .cue-lx { background: #fef3c7; color: #92400e; }
          .cue-q { background: #d1fae5; color: #065f46; }
          .cue-v { background: #e0e7ff; color: #3730a3; }
          .cue-r { background: #fce7f3; color: #9d174d; }
          .cue-u { background: #fed7aa; color: #9a3412; }
          .umbau-details { font-size: 9pt; color: #666; margin-top: 5px; }
          .umbau-ab { color: #dc2626; }
          .umbau-auf { color: #16a34a; }
          .geplant { color: #f97316; font-style: italic; }
          .stichwort { font-style: italic; color: #6b21a8; }
          .szene-header { background: #e5e7eb; }
          @media print { 
            .no-print { display: none; } 
            h2 { page-break-before: auto; }
            tr { page-break-inside: avoid; }
          }
        </style>
      </head><body>`;
      
      html += `<div class="no-print" style="margin-bottom:20px;">
        <button onclick="window.print()" style="padding:10px 20px;font-size:14px;">üñ®Ô∏è¬è Als PDF drucken</button>
      </div>`;
      
      html += `<h1>Cue-Liste: ${typNamen}</h1>`;
      html += `<p class="meta">${state.projektMeta.titel}<br>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      
      if (sortBy === 'szene') {
        // Nach Szene gruppiert
        let currentSzene = null;
        
        html += `<table><tr>
          <th style="width:80px;">Cue</th>
          <th>Beschreibung</th>
          <th style="width:200px;">Stichwort</th>
          <th style="width:60px;">Dauer</th>
        </tr>`;
        
        cues.forEach(c => {
          const szene = state.szenen.find(s => s.id === c.szeneId);
          const szeneKey = szene?.id || 'none';
          
          if (szeneKey !== currentSzene) {
            currentSzene = szeneKey;
            html += `<tr class="szene-header">
              <td colspan="4"><strong>üé¨ ${szene ? szene.nummer + ' ' + szene.titel : 'Ohne Szene'}</strong></td>
            </tr>`;
          }
          
          const typ = CUE_TYPEN[c.typ];
          let beschreibung = c.beschreibung || '‚Äì';
          
          // Stichwort: Ankertext hat Priorit√§t, dann Ausl√∂ser-Feld
          let stichwort = '';
          if (c.ankerText) {
            stichwort = `<em>‚Äû${c.ankerText}"</em>`;
          }
          if (c.ausloeser) {
            stichwort = stichwort ? stichwort + `<br><small style="color:#666">${c.ausloeser}</small>` : c.ausloeser;
          }
          if (!stichwort) stichwort = '‚Äì';
          
          // Zusatzinfos je nach Typ
          if (c.typ === 'r' && c.requisitenId) {
            const req = state.requisiten.find(r => r.id === c.requisitenId);
            if (req) beschreibung = `üé≠ ${req.name}` + (c.beschreibung ? `: ${c.beschreibung}` : '');
          } else if ((c.typ === 'q' || c.typ === 'v') && c.mediumId) {
            const med = state.medien.find(m => m.id === c.mediumId);
            if (med) beschreibung = `üîó ${med.name}` + (c.beschreibung ? `: ${c.beschreibung}` : '');
          } else if ((c.typ === 'q' || c.typ === 'v') && c.mediumGeplant) {
            beschreibung = `<span class="geplant">‚è≥ ${c.mediumGeplant} (geplant)</span>`;
          } else if (c.typ === 'u') {
            // Umbau-Details
            const vonName = c.umbauVon ? state.buehne.find(b => b.id === c.umbauVon)?.name : null;
            const nachName = c.umbauNach ? state.buehne.find(b => b.id === c.umbauNach)?.name : null;
            
            beschreibung = `<strong>${vonName || '?'} ‚Üí ${nachName || '?'}</strong>`;
            
            if (c.umbauAktionen?.length > 0) {
              beschreibung += `<div class="umbau-details"><strong>Aktionen:</strong><br>`;
              beschreibung += c.umbauAktionen.map(a => `‚òê¬ê ${a}`).join('<br>');
              beschreibung += `</div>`;
            }
            
            if (c.requisitenAb?.length > 0) {
              const namen = c.requisitenAb.map(id => state.requisiten.find(r => r.id === id)?.name).filter(Boolean);
              if (namen.length > 0) {
                beschreibung += `<div class="umbau-details umbau-ab">üî¥ AB: ${namen.join(', ')}</div>`;
              }
            }
            
            if (c.requisitenAuf?.length > 0) {
              const namen = c.requisitenAuf.map(id => state.requisiten.find(r => r.id === id)?.name).filter(Boolean);
              if (namen.length > 0) {
                beschreibung += `<div class="umbau-details umbau-auf">üü¢ AUF: ${namen.join(', ')}</div>`;
              }
            }
          }
          
          html += `<tr>
            <td><span class="cue-badge ${typ.class}">${typ.prefix}${c.nummer}</span></td>
            <td>${beschreibung}</td>
            <td>${stichwort}</td>
            <td>${c.dauer || '‚Äì'}</td>
          </tr>`;
        });
        
        html += `</table>`;
        
      } else {
        // Nach Typ gruppiert
        selectedTypes.forEach(typKey => {
          const typ = CUE_TYPEN[typKey];
          const typCues = cues.filter(c => c.typ === typKey);
          
          if (typCues.length === 0) return;
          
          html += `<h2>${typ.icon} ${typ.name}-Cues (${typCues.length})</h2>`;
          html += `<table><tr>
            <th style="width:60px;">Nr.</th>
            <th style="width:80px;">Szene</th>
            <th>Beschreibung</th>
            <th style="width:200px;">Stichwort</th>
            <th style="width:60px;">Dauer</th>
          </tr>`;
          
          typCues.forEach(c => {
            const szene = state.szenen.find(s => s.id === c.szeneId);
            let beschreibung = c.beschreibung || '‚Äì';
            
            // Stichwort: Ankertext hat Priorit√§t
            let stichwort = '';
            if (c.ankerText) {
              stichwort = `<em>‚Äû${c.ankerText}"</em>`;
            }
            if (c.ausloeser) {
              stichwort = stichwort ? stichwort + `<br><small style="color:#666">${c.ausloeser}</small>` : c.ausloeser;
            }
            if (!stichwort) stichwort = '‚Äì';
            
            // Gleiche Zusatzinfos wie oben...
            if (c.typ === 'u') {
              const vonName = c.umbauVon ? state.buehne.find(b => b.id === c.umbauVon)?.name : null;
              const nachName = c.umbauNach ? state.buehne.find(b => b.id === c.umbauNach)?.name : null;
              beschreibung = `${vonName || '?'} ‚Üí ${nachName || '?'}`;
              if (c.umbauAktionen?.length > 0) {
                beschreibung += ` (${c.umbauAktionen.length} Aktionen)`;
              }
            }
            
            html += `<tr>
              <td><strong>${typ.prefix}${c.nummer}</strong></td>
              <td>${szene?.nummer || '‚Äì'}</td>
              <td>${beschreibung}</td>
              <td>${stichwort}</td>
              <td>${c.dauer || '‚Äì'}</td>
            </tr>`;
          });
          
          html += `</table>`;
        });
      }
      
      html += `</body></html>`;
      
      closeCueExportDialog();
      openExportWindow(html, 'cue-liste-' + selectedTypes.join('-'));
    }
    
    // Bild als Base64 Data-URL aus IndexedDB laden
    async function getImageAsBase64(imageId) {
      if (!imageId) return null;
      if (!mediaBD) await initAudioDB();
      
      return new Promise((resolve) => {
        const transaction = mediaBD.transaction([IMAGE_STORE_NAME], 'readonly');
        const store = transaction.objectStore(IMAGE_STORE_NAME);
        const request = store.get(imageId);
        
        request.onsuccess = () => {
          if (request.result) {
            const blob = new Blob([request.result.data], { type: request.result.type });
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result); // data:image/...;base64,...
            reader.readAsDataURL(blob);
          } else {
            resolve(null);
          }
        };
        request.onerror = () => resolve(null);
      });
    }
    
    async function exportRequisitenList() {
      // Bilder als Base64 laden
      const bilderBase64 = {};
      for (const r of state.requisiten) {
        if (r.bilder) {
          for (const imgId of r.bilder) {
            if (!bilderBase64[imgId]) {
              bilderBase64[imgId] = await getImageAsBase64(imgId);
            }
          }
        }
      }
      
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Requisiten-Liste - ${state.projektMeta.titel}</title>
        <style>
          body{font-family:Arial,sans-serif;padding:20px;} 
          table{border-collapse:collapse;width:100%;} 
          th,td{border:1px solid #ddd;padding:8px;text-align:left;vertical-align:top;} 
          th{background:#f5f5f5;} 
          img{max-width:80px;max-height:80px;margin:2px;}
          @media print { .no-print{display:none;} }
        </style></head><body>`;
      html += `<div class="no-print" style="margin-bottom:20px;"><button onclick="window.print()" style="padding:10px 20px;font-size:16px;">üñ®Ô∏è¬è Als PDF drucken</button></div>`;
      html += `<h1>Requisiten-Liste: ${state.projektMeta.titel}</h1>`;
      html += `<p>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      html += `<table><tr><th>Name</th><th>Beschreibung</th><th>Zust√§ndig</th><th>Szenen</th><th>Bilder</th><th>Notizen</th></tr>`;
      
      state.requisiten.forEach(r => {
        const szenenNamen = r.szenen?.map(sId => state.szenen.find(s => s.id === sId)?.nummer).filter(Boolean).join(', ') || '‚Äì';
        let bilderHtml = '‚Äì';
        if (r.bilder?.length > 0) {
          bilderHtml = r.bilder.map(id => bilderBase64[id] ? `<img src="${bilderBase64[id]}">` : '').join('');
        }
        html += `<tr><td>${r.name}</td><td>${r.beschreibung || '‚Äì'}</td><td>${r.zustaendig || '‚Äì'}</td><td>${szenenNamen}</td><td>${bilderHtml}</td><td>${r.notizen || '‚Äì'}</td></tr>`;
      });
      
      html += `</table></body></html>`;
      openExportWindow(html, 'requisiten-liste');
    }
    
    async function exportBuehneList() {
      // Bilder als Base64 laden
      const bilderBase64 = {};
      for (const b of state.buehne) {
        if (b.bilder) {
          for (const imgId of b.bilder) {
            if (!bilderBase64[imgId]) {
              bilderBase64[imgId] = await getImageAsBase64(imgId);
            }
          }
        }
      }
      
      let html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>B√ºhne - ${state.projektMeta.titel}</title>
        <style>
          body{font-family:Arial,sans-serif;padding:20px;} 
          .item{margin-bottom:30px;border:1px solid #ddd;padding:15px;page-break-inside:avoid;} 
          img{max-width:250px;max-height:250px;margin:5px;}
          .images{display:flex;flex-wrap:wrap;gap:10px;}
          @media print { .no-print{display:none;} }
        </style></head><body>`;
      html += `<div class="no-print" style="margin-bottom:20px;"><button onclick="window.print()" style="padding:10px 20px;font-size:16px;">üñ®Ô∏è¬è Als PDF drucken</button></div>`;
      html += `<h1>B√ºhne: ${state.projektMeta.titel}</h1>`;
      html += `<p>Erstellt: ${new Date().toLocaleDateString('de-CH')}</p>`;
      
      state.buehne.forEach(b => {
        html += `<div class="item"><h2>${b.name}</h2>`;
        html += `<p><strong>Kategorie:</strong> ${b.kategorie || 'Sonstiges'}</p>`;
        if (b.beschreibung) html += `<p>${b.beschreibung}</p>`;
        if (b.bilder?.length > 0) {
          html += `<div class="images">`;
          b.bilder.forEach(id => {
            if (bilderBase64[id]) html += `<img src="${bilderBase64[id]}">`;
          });
          html += `</div>`;
        }
        if (b.notizen) html += `<p><em>Notizen: ${b.notizen}</em></p>`;
        html += `</div>`;
      });
      
      html += `</body></html>`;
      openExportWindow(html, 'buehne');
    }
    
    // Export in neuem Fenster √∂ffnen (f√ºr Drucken als PDF)
    function openExportWindow(html, title) {
      // Direkt als HTML-Datei downloaden (Safari-kompatibel)
      downloadHTML(html, makeExportFilename(title, 'html'));
      
      // Hinweis f√ºr User
      setTimeout(() => {
        alert('Die Datei wurde heruntergeladen.\n\n' +
              'üìÑ So erstellst du ein PDF:\n' +
              '1. √ñffne die heruntergeladene HTML-Datei\n' +
              '2. Dr√ºcke ‚åò+P (Drucken)\n' +
              '3. W√§hle "Als PDF sichern"');
      }, 500);
    }
    
    // Einheitliche Dateinamen: Projektname_Typ_JJJJ-MM-TT.ext
    function makeExportFilename(typ, ext) {
      const name = (state.projektMeta.titel || 'Projekt')
        .replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü√©√®√™√†√°√¢\s-]/g, '')
        .replace(/\s+/g, '_')
        .substring(0, 60);
      const datum = new Date().toISOString().slice(0, 10); // JJJJ-MM-TT
      return `${name}_${typ}_${datum}.${ext}`;
    }
    
    function downloadHTML(content, filename) {
      const blob = new Blob([content], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    // Import/Export
    // Datei-Import Handler
    let pendingImportData = null;
    
    function handleImportFile(input) {
      const file = input.files[0];
      if (!file) return;
      
      document.getElementById('import-file-name').textContent = file.name;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          pendingImportData = e.target.result;
          document.getElementById('import-btn').disabled = false;
        } catch (err) {
          alert('Fehler beim Lesen der Datei.');
          pendingImportData = null;
        }
      };
      reader.readAsText(file);
    }
    
    function doImportFile() {
      if (!pendingImportData) {
        alert('Bitte zuerst eine Datei ausw√§hlen.');
        return;
      }
      
      try {
        importFromDramera(pendingImportData);
        pendingImportData = null;
        closeModal('showImportModal');
      } catch (err) {
        alert('Fehler beim Import: ' + err.message);
      }
    }
    
    function downloadDrameraExport() {
      const exportData = exportToDramera();
      const json = JSON.stringify(exportData, null, 2);
      const filename = makeExportFilename('Backup', 'json');
      
      const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      
      state.dirty = false; // Backup erstellt
      closeModal('showExportModal');
    }

    function saveFassung() {
      const name = document.getElementById('fassung-name').value.trim();
      neueFassungSpeichern(name);
      closeModal('showFassungModal');
      alert('‚úÖ Fassung gespeichert!');
    }
    
    function saveFassungAndExport() {
      const name = document.getElementById('fassung-name').value.trim();
      neueFassungSpeichern(name);
      closeModal('showFassungModal');
      
      // Kurz warten, dann Export starten
      setTimeout(() => {
        downloadDrameraExport();
        alert('‚úÖ Fassung gespeichert UND Backup heruntergeladen!');
      }, 100);
    }

    // ============================================
    // LOGO BASE64
    // ============================================
const NINA_LOGO_BASE64 = '';
    // ============================================
    // INIT
    // ============================================
    document.addEventListener('DOMContentLoaded', async () => {
      // IndexedDB initialisieren
      try {
        await initAudioDB();
      } catch (e) {
        console.warn('IndexedDB nicht verf√ºgbar:', e);
      }
      
      // Projekt laden
      initProjekt();
      
      // Audio-URLs wiederherstellen
      try {
        await restoreAudioUrls();
      } catch (e) {
        console.warn('Audio-Wiederherstellung fehlgeschlagen:', e);
      }
      
      render();
      updateStorageInfo();
      
      // Cloud-Auth pr√ºfen
      checkCloudAuth();
      
      // Format-Indikator bei Cursor-Bewegung aktualisieren
      document.addEventListener('selectionchange', updateFormatIndicator);
    });
    
    // Format der aktuellen Zeile erkennen und anzeigen
    function updateFormatIndicator() {
      const indicator = document.getElementById('format-indicator');
      if (!indicator) return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      // Finde das aktuelle Element
      let node = selection.anchorNode;
      if (!node) return;
      
      // Zum Element-Node navigieren
      while (node && node.nodeType !== 1) {
        node = node.parentNode;
      }
      if (!node) return;
      
      // Format-Klasse finden
      let currentFormat = 'standard';
      let checkNode = node;
      
      while (checkNode && checkNode.id !== 'text-editor') {
        const classList = checkNode.classList;
        if (classList) {
          if (classList.contains('format-dialog')) currentFormat = 'dialog';
          else if (classList.contains('format-regieanweisung')) currentFormat = 'regieanweisung';
          else if (classList.contains('format-szene-titel')) currentFormat = 'szeneTitel';
          else if (classList.contains('format-akt-titel')) currentFormat = 'aktTitel';
          else if (classList.contains('format-lied')) currentFormat = 'lied';
          else if (classList.contains('format-vers')) currentFormat = 'vers';
          else if (classList.contains('format-pause')) currentFormat = 'pause';
          else if (classList.contains('format-standard')) currentFormat = 'standard';
          
          if (currentFormat !== 'standard' || classList.contains('format-standard')) break;
        }
        checkNode = checkNode.parentNode;
      }
      
      // Alle Format-Items aktualisieren
      const items = indicator.querySelectorAll('.format-item');
      items.forEach(item => {
        if (item.dataset.format === currentFormat) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
    }
  </script>
</body>
</html>
