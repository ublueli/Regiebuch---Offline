<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dramera Propla v3.0 - Probeplaner Stand-alone (NINA-Exchange v3.0)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <!-- Supabase entfernt f√ºr Stand-alone Version -->
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    
    :root {
      --nina-primary: #14b8a6;
      --nina-primary-dark: #134e4a;
      --nina-success: #10b981;
      --nina-warning: #f97316;
      --nina-danger: #ef4444;
      --nina-purple: #8b5cf6;
      --nina-blue: #4169b2;
    }
    
    .sidebar { background: linear-gradient(180deg, #134e4a 0%, #0f172a 100%); }
    .nav-section { color: #5eead4; font-size: 0.65rem; font-weight: 700; letter-spacing: 0.1em; text-transform: uppercase; }
    .nav-item { transition: all 0.15s; border-left: 3px solid transparent; }
    .nav-item:hover { background: rgba(255,255,255,0.1); }
    .nav-item.active { background: rgba(20, 184, 166, 0.3); border-left-color: #14b8a6; }
    
    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.15s; border: none; }
    .btn-primary { background: #14b8a6; color: white; }
    .btn-primary:hover { background: #0d9488; }
    .btn-success { background: #10b981; color: white; }
    .btn-success:hover { background: #059669; }
    .btn-danger { background: #ef4444; color: white; }
    .btn-danger:hover { background: #dc2626; }
    .btn-orange { background: #f97316; color: white; }
    .btn-orange:hover { background: #ea580c; }
    .btn-purple { background: #8b5cf6; color: white; }
    .btn-purple:hover { background: #7c3aed; }
    .btn-outline { background: white; border: 1px solid #d1d5db; color: #374151; }
    .btn-outline:hover { background: #f3f4f6; border-color: #14b8a6; color: #14b8a6; }
    .btn-outline-light { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #5eead4; }
    .btn-outline-light:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.5); color: white; }
    .btn-sm { padding: 0.375rem 0.75rem; font-size: 0.75rem; }
    .btn-xs { padding: 0.25rem 0.5rem; font-size: 0.65rem; }
    
    input, select, textarea { padding: 0.5rem 0.75rem; border: 1px solid #d1d5db; border-radius: 0.5rem; font-size: 0.875rem; transition: all 0.15s; width: 100%; background: white; }
    input:focus, select:focus, textarea:focus { outline: none; border-color: #14b8a6; box-shadow: 0 0 0 3px rgba(20,184,166,0.15); }
    .input-label { display: block; font-size: 0.7rem; font-weight: 600; color: #6b7280; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.025em; }
    
    .card { background: white; border-radius: 0.75rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border: 1px solid #e5e7eb; }
    .table-wrap { overflow: auto; max-height: 55vh; }
    table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
    th { background: #f9fafb; color: #6b7280; font-weight: 600; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.025em; position: sticky; top: 0; z-index: 10; }
    th, td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid #e5e7eb; }
    tbody tr:hover { background: #f9fafb; }
    
    .fade-in { animation: fadeIn 0.2s ease; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    .tag { display: inline-block; padding: 0.125rem 0.5rem; border-radius: 9999px; font-size: 0.7rem; font-weight: 600; }
    .tag-blue { background: #dbeafe; color: #1e40af; }
    .tag-green { background: #d1fae5; color: #065f46; }
    .tag-orange { background: #fed7aa; color: #9a3412; }
    .tag-purple { background: #e9d5ff; color: #6b21a8; }
    .tag-red { background: #fee2e2; color: #991b1b; }
    .tag-gray { background: #e5e7eb; color: #374151; }
    
    .delete-btn { color: #ef4444; cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }
    .delete-btn:hover { background: #fee2e2; }
    .edit-btn { color: #14b8a6; cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }
    .edit-btn:hover { background: #ccfbf1; }
    
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .modal-content { background: white; border-radius: 1rem; max-width: 900px; width: 95%; max-height: 90vh; overflow: auto; }
    
    .szene-gruen { background: #d1fae5 !important; border-left: 4px solid #10b981; }
    .szene-orange { background: #fef3c7 !important; border-left: 4px solid #f97316; }
    .szene-rot { background: #fee2e2 !important; border-left: 4px solid #ef4444; }
    .szene-item { padding: 0.75rem; margin-bottom: 0.5rem; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s; }
    .szene-item:hover { transform: translateX(4px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .szene-item.selected-for-probe { box-shadow: 0 0 0 2px #14b8a6; }
    
    .stat-card { background: linear-gradient(135deg, var(--stat-color-1) 0%, var(--stat-color-2) 100%); border-radius: 1rem; padding: 1.5rem; color: white; }
    .stat-card-blue { --stat-color-1: #3b82f6; --stat-color-2: #1d4ed8; }
    .stat-card-teal { --stat-color-1: #14b8a6; --stat-color-2: #0d9488; }
    .stat-card-green { --stat-color-1: #10b981; --stat-color-2: #059669; }
    .stat-card-orange { --stat-color-1: #f97316; --stat-color-2: #ea580c; }
    .stat-card-purple { --stat-color-1: #8b5cf6; --stat-color-2: #7c3aed; }
    
    .import-zone { border: 2px dashed #d1d5db; border-radius: 0.75rem; padding: 2rem; text-align: center; transition: all 0.2s; }
    .import-zone:hover { border-color: #14b8a6; background: #f0fdfa; }
    .import-zone.dragover { border-color: #14b8a6; background: #ccfbf1; }
    
    .sidebar-logo { width: 100%; max-width: 140px; height: auto; margin: 0 auto; display: block; }
  </style>
  <!-- ============================================ -->
  <!-- GOOGLE DRIVE MODULE (wiederverwendbar)       -->
  <!-- ============================================ -->
  <script>
    const GDRIVE_CLIENT_ID = '442649097645-159rgo1mpu0ptdkiq8up8tdc8dl5mvo2.apps.googleusercontent.com';
    const GDRIVE_SCOPE = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email';
    const GDRIVE_API = 'https://www.googleapis.com/drive/v3';
    const GDRIVE_UPLOAD_API = 'https://www.googleapis.com/upload/drive/v3';
    
    let gdriveToken = null;
    let gdriveUser = null;
    let gdriveFolderId = localStorage.getItem('nina_gdrive_folder_id') || null;
    let gdriveFolderName = localStorage.getItem('nina_gdrive_folder_name') || null;
    let gdriveTokenClient = null;
    let gdriveSaving = false;
    
    function gdriveInitAuth() {
      if (!window.google?.accounts?.oauth2) { console.warn('GIS not loaded'); return false; }
      gdriveTokenClient = google.accounts.oauth2.initTokenClient({
        client_id: GDRIVE_CLIENT_ID, scope: GDRIVE_SCOPE,
        callback: (response) => {
          if (response.error) { alert('‚ùå Google-Anmeldung fehlgeschlagen: ' + (response.error_description || response.error)); return; }
          gdriveToken = response.access_token;
          fetch('https://www.googleapis.com/oauth2/v3/userinfo', { headers: { 'Authorization': 'Bearer ' + gdriveToken } })
            .then(r => r.ok ? r.json() : Promise.reject()).then(info => {
              gdriveUser = { name: info.name || '', email: info.email || '', picture: info.picture || '' };
              localStorage.setItem('nina_gdrive_user', JSON.stringify(gdriveUser));
              if (typeof render === 'function') render();
            }).catch(() => { gdriveUser = { name: '', email: 'Verbunden', picture: '' }; });
          if (typeof render === 'function') render();
          if (typeof gdriveOnConnected === 'function') gdriveOnConnected();
        }
      });
      try { const cached = localStorage.getItem('nina_gdrive_user'); if (cached) gdriveUser = JSON.parse(cached); } catch(e) {}
      return true;
    }
    function gdriveSignIn() { if (!gdriveTokenClient && !gdriveInitAuth()) { alert('‚è≥ Google-Dienst wird noch geladen.'); return; } gdriveTokenClient.requestAccessToken(); }
    function gdriveSignOut() { if (gdriveToken) google.accounts.oauth2.revoke(gdriveToken); gdriveToken = null; gdriveUser = null; localStorage.removeItem('nina_gdrive_user'); if (typeof render === 'function') render(); }
    function gdriveIsConnected() { return !!gdriveToken; }
    
    async function gdriveFetch(url, options = {}) {
      if (!gdriveToken) throw new Error('Nicht angemeldet');
      const resp = await fetch(url, { ...options, headers: { 'Authorization': 'Bearer ' + gdriveToken, ...(options.headers || {}) } });
      if (resp.status === 401) { gdriveToken = null; gdriveUser = null; localStorage.removeItem('nina_gdrive_user'); throw new Error('Sitzung abgelaufen'); }
      if (!resp.ok) { const err = await resp.text(); throw new Error('Drive-Fehler: ' + resp.status); }
      return resp;
    }
    async function gdriveCreateFolder(name, parentId) {
      const metadata = { name, mimeType: 'application/vnd.google-apps.folder', ...(parentId ? { parents: [parentId] } : {}) };
      const resp = await gdriveFetch(GDRIVE_API + '/files', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(metadata) });
      return await resp.json();
    }
    async function gdriveListFolders() {
      try { const q = "mimeType='application/vnd.google-apps.folder' and trashed=false"; const resp = await gdriveFetch(GDRIVE_API + `/files?q=${encodeURIComponent(q)}&fields=files(id,name,modifiedTime)&orderBy=modifiedTime desc&pageSize=20`); return (await resp.json()).files || []; }
      catch(e) { return []; }
    }
    async function gdriveSetFolder(id, name) { gdriveFolderId = id; gdriveFolderName = name; localStorage.setItem('nina_gdrive_folder_id', id); localStorage.setItem('nina_gdrive_folder_name', name); if (typeof render === 'function') render(); }
    async function gdriveSaveFile(fileName, jsonData, folderId) {
      const targetFolder = folderId || gdriveFolderId;
      if (!targetFolder) throw new Error('Kein Ordner ausgew√§hlt');
      const q = `name='${fileName}' and '${targetFolder}' in parents and trashed=false`;
      const searchResp = await gdriveFetch(GDRIVE_API + `/files?q=${encodeURIComponent(q)}&fields=files(id)`);
      const existing = (await searchResp.json()).files || [];
      const content = JSON.stringify(jsonData, null, 2);
      const blob = new Blob([content], { type: 'application/json' });
      if (existing.length > 0) {
        const resp = await gdriveFetch(GDRIVE_UPLOAD_API + `/files/${existing[0].id}?uploadType=media`, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: blob });
        return await resp.json();
      } else {
        const metadata = { name: fileName, parents: [targetFolder] };
        const form = new FormData(); form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' })); form.append('file', blob);
        const resp = await fetch(GDRIVE_UPLOAD_API + '/files?uploadType=multipart', { method: 'POST', headers: { 'Authorization': 'Bearer ' + gdriveToken }, body: form });
        if (!resp.ok) throw new Error('Upload fehlgeschlagen: ' + resp.status);
        return await resp.json();
      }
    }
    async function gdriveListFiles(folderId) {
      const targetFolder = folderId || gdriveFolderId; if (!targetFolder) return [];
      const q = `'${targetFolder}' in parents and trashed=false and mimeType='application/json'`;
      const resp = await gdriveFetch(GDRIVE_API + `/files?q=${encodeURIComponent(q)}&fields=files(id,name,modifiedTime,size)&orderBy=modifiedTime desc`);
      return (await resp.json()).files || [];
    }
    async function gdriveLoadFile(fileId) { const resp = await gdriveFetch(GDRIVE_API + `/files/${fileId}?alt=media`); return await resp.json(); }
    
    // Folder Picker Modal
    function gdriveShowFolderPicker() {
      if (!gdriveIsConnected()) {
        gdriveOnConnected = () => { gdriveOnConnected = null; gdriveShowFolderPicker(); };
        gdriveSignIn(); return;
      }
      const modal = document.createElement('div');
      modal.id = 'gdriveFolderPickerModal';
      modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:10000;display:flex;align-items:center;justify-content:center;';
      modal.innerHTML = '<div style="background:white;border-radius:12px;padding:24px;max-width:450px;width:90%;max-height:80vh;overflow-y:auto;"><h3 style="font-size:16px;font-weight:600;margin-bottom:16px;">üìÅ Google Drive ‚Äì Ordner w√§hlen</h3><div id="gdriveFolderList" style="margin-bottom:16px;"><p style="color:#666;font-size:14px;">‚è≥ Ordner werden geladen...</p></div><div style="border-top:1px solid #e5e7eb;padding-top:12px;margin-top:12px;"><p style="font-size:12px;color:#666;margin-bottom:8px;">Neuen Ordner erstellen:</p><div style="display:flex;gap:8px;"><input type="text" id="gdriveNewFolderName" placeholder="z.B. Der Sturm" style="flex:1;padding:6px 10px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;"><button onclick="gdriveCreateNewFolder()" style="padding:6px 14px;background:#14b8a6;color:white;border:none;border-radius:6px;font-size:13px;cursor:pointer;">Erstellen</button></div></div><div style="text-align:right;margin-top:16px;"><button onclick="document.getElementById(\'gdriveFolderPickerModal\').remove()" style="padding:6px 16px;background:#f3f4f6;border:1px solid #d1d5db;border-radius:6px;font-size:13px;cursor:pointer;">Schliessen</button></div></div>';
      document.body.appendChild(modal);
      modal.querySelector('div').onclick = (e) => e.stopPropagation();
      modal.onclick = () => modal.remove();
      gdriveLoadFolderList();
    }
    async function gdriveLoadFolderList() {
      const container = document.getElementById('gdriveFolderList'); if (!container) return;
      try {
        const folders = await gdriveListFolders();
        if (folders.length === 0) { container.innerHTML = '<p style="color:#666;font-size:14px;">Keine Ordner gefunden. Erstelle einen neuen Ordner.</p>'; return; }
        container.innerHTML = folders.map(f => `<div onclick="gdrivePickFolder('${f.id}', '${(f.name||'').replace(/'/g,'\\\'')}')" style="padding:10px 12px;border:1px solid #e5e7eb;border-radius:8px;margin-bottom:6px;cursor:pointer;display:flex;align-items:center;gap:10px;transition:background 0.1s;" onmouseover="this.style.background='#f0fdfa'" onmouseout="this.style.background='white'"><span>üìÅ</span><span style="flex:1;font-size:14px;">${f.name}</span>${f.id === gdriveFolderId ? '<span style="color:#14b8a6;font-size:12px;">‚úì aktuell</span>' : ''}</div>`).join('');
      } catch(e) { container.innerHTML = '<p style="color:#ef4444;">Fehler: ' + e.message + '</p>'; }
    }
    function gdrivePickFolder(id, name) { gdriveSetFolder(id, name); const modal = document.getElementById('gdriveFolderPickerModal'); if (modal) modal.remove(); }
    async function gdriveCreateNewFolder() {
      const input = document.getElementById('gdriveNewFolderName'); const name = input?.value?.trim(); if (!name) { alert('Bitte einen Namen eingeben.'); return; }
      try { const folder = await gdriveCreateFolder(name); gdriveSetFolder(folder.id, name); const modal = document.getElementById('gdriveFolderPickerModal'); if (modal) modal.remove(); alert('‚úÖ Ordner "' + name + '" erstellt und ausgew√§hlt!'); }
      catch(e) { alert('‚ùå Fehler: ' + e.message); }
    }
    let gdriveOnConnected = null;
    window.addEventListener('load', () => { setTimeout(() => gdriveInitAuth(), 500); });
  </script>
</head>
<body class="bg-gray-100">
  <div id="app"></div>
  <div id="modal"></div>

  <script>
    // ============================================
    // SUPABASE CLOUD KONFIGURATION - DEAKTIVIERT (Stand-alone Version)
    // ============================================
    const SUPABASE_URL = '';
    const SUPABASE_KEY = '';
    // Dummy-DB f√ºr Stand-alone Version
    const db = { 
      from: () => ({ 
        select: () => ({ eq: () => ({ single: () => Promise.resolve({ data: null, error: null }), order: () => Promise.resolve({ data: [], error: null }) }), order: () => Promise.resolve({ data: [], error: null }) }),
        insert: () => Promise.resolve({ data: null, error: null }), 
        upsert: () => Promise.resolve({ data: null, error: null }), 
        update: () => ({ eq: () => Promise.resolve({ error: null }) }), 
        delete: () => ({ eq: () => Promise.resolve({ error: null }) })
      }), 
      auth: { 
        getSession: () => Promise.resolve({ data: { session: null } }),
        getUser: () => Promise.resolve({ data: { user: null }, error: null }), 
        signInWithPassword: () => Promise.resolve({ data: null, error: { message: 'Cloud deaktiviert in Stand-alone Version' } }), 
        signUp: () => Promise.resolve({ data: null, error: { message: 'Cloud deaktiviert' } }), 
        signOut: () => Promise.resolve({}) 
      } 
    };
    
    // Cloud-Modus State
    let cloudUser = null;
    let cloudProjects = [];
    let currentCloudProjectId = null;
    let isCloudMode = false;
    let cloudSyncInProgress = false;

    // ============================================
    // N!NA Logo als Base64
    const NINA_LOGO = 'data:image/png;base64,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';

    // ============================================
    // N!NA STORAGE KEYS
    // ============================================
    const STORAGE_PREFIX = 'nina_';
    const KEYS = {
      projekte: STORAGE_PREFIX + 'projekte',
      aktuellesProjekt: STORAGE_PREFIX + 'aktuelles_projekt',
      settings: (id) => `${STORAGE_PREFIX}settings_${id}`,
      probedaten: (id) => `${STORAGE_PREFIX}probedaten_${id}`,
      kuenstlerischesTeam: (id) => `${STORAGE_PREFIX}team_${id}`,
      teamVerfuegbarkeit: (id) => `${STORAGE_PREFIX}team_verfuegbarkeit_${id}`,
      ensemble: (id) => `${STORAGE_PREFIX}ensemble_${id}`,
      figuren: (id) => `${STORAGE_PREFIX}figuren_${id}`,
      zuordnungen: (id) => `${STORAGE_PREFIX}zuordnungen_${id}`,
      szenen: (id) => `${STORAGE_PREFIX}szenen_${id}`,
      absenzen: (id) => `${STORAGE_PREFIX}absenzen_${id}`,
      probenplanung: (id) => `${STORAGE_PREFIX}probenplanung_${id}`,
    };

    const MONATE = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
    const MONATE_KURZ = ['Jan.', 'Feb.', 'M√§rz', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.', 'Sep.', 'Okt.', 'Nov.', 'Dez.'];
    const WOCHENTAGE = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
    const WOCHENTAGE_KURZ = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
    
    const PROBENARTEN = [
      'Leseprobe', 'Szenische Probe', 'Durchlauf', 'Hauptprobe', 
      'Generalprobe', 'Technische Probe', 'Stellprobe', 'Kost√ºmprobe',
      'Figurenentwicklung', 'Interviews und K√∂rperarbeit',
      'Abendprobe Teil 1', 'Abendprobe Teil 2', 'Endprobe Teil 1', 'Endprobe Teil 2',
      'Endprobe Teil 3', 'Endprobe Teil 4', 'Endprobe Teil 5', 'Ganzes St√ºck',
      'Premiere', 'Vorstellung', 'Ersatzvorstellung', 'Pause', 'Mittagspause'
    ];
    
    const TEAM_FUNKTIONEN = [
      'Regie', 'Regieassistenz', 'Dramaturgie', 'B√ºhnenbild', 'B√ºhne', 'Kost√ºm', 
      'Licht', 'Ton', 'Video', 'Choreografie', 'Choreographie', 'Musik', 
      'Inspizienz', 'Soufflage', 'Maske', 'Requisite', 
      'Produktionsleitung', 'Projektleiterin', 'Vizepr√§sidentin / Projektleiterin'
    ];

    // ============================================
    // UTILITIES
    // ============================================
    const save = (key, data) => localStorage.setItem(key, JSON.stringify(data));
    const load = (key, def = null) => { try { return JSON.parse(localStorage.getItem(key)) || def; } catch { return def; } };
    const genId = () => 'id_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

    function formatDatum(str) { if (!str) return ''; const d = parseDatum(str); if (!d || isNaN(d.getTime())) return str; return `${d.getDate()}. ${MONATE_KURZ[d.getMonth()]} ${d.getFullYear()}`; }
    function formatDatumKurz(str) { if (!str) return ''; const d = parseDatum(str); if (!d || isNaN(d.getTime())) return str; return `${d.getDate()}.${d.getMonth() + 1}.`; }
    function formatDatumLang(str) { if (!str) return ''; const d = parseDatum(str); if (!d || isNaN(d.getTime())) return str; return `${WOCHENTAGE[d.getDay()]}, ${d.getDate()}. ${MONATE[d.getMonth()]}`; }
    function parseDatum(str) { if (!str) return null; if (str instanceof Date) return str; let d; if (str.includes('/')) { const p = str.split('/'); const year = p[2]?.length === 2 ? '20' + p[2] : p[2]; const first = parseInt(p[0]); const second = parseInt(p[1]); if (first > 12) { d = new Date(year, second - 1, first); } else if (second > 12) { d = new Date(year, first - 1, second); } else { d = new Date(year, second - 1, first); } } else if (str.includes('.') && !str.includes('T')) { const p = str.split('.'); if (p.length >= 3) d = new Date(p[2], parseInt(p[1]) - 1, parseInt(p[0])); } else { d = new Date(str); } return d; }
    function toISODate(str) { const d = parseDatum(str); if (!d || isNaN(d.getTime())) return str || ''; const y = d.getFullYear(); const m = String(d.getMonth()+1).padStart(2,'0'); const day = String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; }
    function getWochentag(str) { const d = parseDatum(str); if (!d || isNaN(d.getTime())) return ''; return WOCHENTAGE[d.getDay()]; }
    function getWochentagKurz(str) { const d = parseDatum(str); if (!d || isNaN(d.getTime())) return ''; return WOCHENTAGE_KURZ[d.getDay()]; }
    function sortByDatum(arr, field = 'datum') { return [...arr].sort((a, b) => toISODate(a[field]).localeCompare(toISODate(b[field]))); }
    function escapeHtml(str) { return String(str || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
    function daysUntil(dateStr) { const d = parseDatum(dateStr); if (!d) return null; const today = new Date(); today.setHours(0, 0, 0, 0); d.setHours(0, 0, 0, 0); return Math.ceil((d - today) / (1000 * 60 * 60 * 24)); }
    function timeToMinutes(timeStr) { if (!timeStr) return 0; const [h, m] = timeStr.split(':').map(Number); return h * 60 + (m || 0); }
    function timeOverlaps(start1, end1, start2, end2) { const s1 = timeToMinutes(start1), e1 = timeToMinutes(end1); const s2 = timeToMinutes(start2), e2 = timeToMinutes(end2); return s1 < e2 && s2 < e1; }

    // ============================================
    // CLOUD AUTH SYSTEM
    // ============================================
    // URL-Parameter auslesen (f√ºr Dashboard-Integration)
    function getUrlProjectId() {
      const params = new URLSearchParams(window.location.search);
      return params.get('project');
    }
    
    async function checkCloudAuth() {
      const { data: { session } } = await db.auth.getSession();
      if (session?.user) {
        cloudUser = session.user;
        isCloudMode = true;
        await loadCloudProjects();
        
        // Automatisch Projekt √∂ffnen wenn in URL angegeben
        const urlProjectId = getUrlProjectId();
        if (urlProjectId) {
          const cloudProject = cloudProjects.find(p => p.id === urlProjectId);
          if (cloudProject) {
            console.log('Auto-opening project from URL:', urlProjectId);
            await selectCloudProject(urlProjectId);
          }
        }
      }
      renderApp();
    }

    async function cloudLogin() {
      const email = document.getElementById('cloud_email')?.value;
      const password = document.getElementById('cloud_password')?.value;
      if (!email || !password) return alert('Bitte E-Mail und Passwort eingeben!');
      
      document.getElementById('cloud_status').innerHTML = '<div class="text-blue-600">Logge ein...</div>';
      
      const { data, error } = await db.auth.signInWithPassword({ email, password });
      if (error) {
        document.getElementById('cloud_status').innerHTML = `<div class="text-red-600">Fehler: ${error.message}</div>`;
        return;
      }
      
      cloudUser = data.user;
      isCloudMode = true;
      await loadCloudProjects();
      renderApp();
    }

    async function cloudRegister() {
      const email = document.getElementById('cloud_email')?.value;
      const password = document.getElementById('cloud_password')?.value;
      const name = document.getElementById('cloud_name')?.value || email;
      if (!email || !password) return alert('Bitte E-Mail und Passwort eingeben!');
      
      document.getElementById('cloud_status').innerHTML = '<div class="text-blue-600">Registriere...</div>';
      
      const { data, error } = await db.auth.signUp({
        email, password,
        options: { data: { name } }
      });
      if (error) {
        document.getElementById('cloud_status').innerHTML = `<div class="text-red-600">Fehler: ${error.message}</div>`;
        return;
      }
      
      cloudUser = data.user;
      isCloudMode = true;
      await loadCloudProjects();
      renderApp();
    }

    async function cloudLogout() {
      await db.auth.signOut();
      cloudUser = null;
      isCloudMode = false;
      cloudProjects = [];
      currentCloudProjectId = null;
      renderApp();
    }

    function useLocalMode() {
      isCloudMode = false;
      cloudUser = null;
      renderApp();
    }

    function toggleRegisterFields() {
      document.getElementById('register_name_row')?.classList.toggle('hidden');
      document.getElementById('register_btn_row')?.classList.toggle('hidden');
    }

    async function loadCloudProjects() {
      const { data, error } = await db.from('projects').select('*').order('updated_at', { ascending: false });
      if (!error && data) {
        cloudProjects = data.map(p => ({
          id: p.id,
          name: p.name,
          premiere: p.premiere_date,
          regie: p.director,
          spielstaette: p.venue,
          status: p.status
        }));
      }
    }

    async function selectCloudProject(cloudId) {
      currentCloudProjectId = cloudId;
      const cloudProject = cloudProjects.find(p => p.id === cloudId);
      if (!cloudProject) return;
      
      // Lokales Projekt erstellen/aktualisieren
      const localId = 'cloud_' + cloudId;
      let projekte = load(KEYS.projekte, []);
      let existingIdx = projekte.findIndex(p => p.id === localId);
      
      const projektData = {
        id: localId,
        cloudId: cloudId,
        name: cloudProject.name,
        premiere: cloudProject.premiere,
        regie: cloudProject.regie,
        spielstaette: cloudProject.spielstaette
      };
      
      if (existingIdx >= 0) {
        projekte[existingIdx] = projektData;
      } else {
        projekte.push(projektData);
      }
      save(KEYS.projekte, projekte);
      
      state.projekte = projekte;
      state.projekt = projektData;
      save(KEYS.aktuellesProjekt, projektData);
      
      // Daten von Cloud laden
      await syncFromCloud(cloudId, localId);
      
      state.showProjektAuswahl = false;
      render();
    }

    async function createCloudProject() {
      const name = document.getElementById('neuesProjektName')?.value?.trim();
      if (!name) return alert('Projektname erforderlich!');
      
      if (!cloudUser) return alert('Bitte zuerst einloggen!');
      
      const premiere = document.getElementById('neuesProjektPremiere')?.value || null;
      const regie = document.getElementById('neuesProjektRegie')?.value || null;
      const spielstaette = document.getElementById('neuesProjektSpielstaette')?.value || null;
      
      // Direkt in Tabelle einf√ºgen (ohne RPC)
      const { data: projectData, error } = await db.from('projects').insert({
        name: name,
        premiere_date: premiere,
        director: regie,
        venue: spielstaette,
        created_by: cloudUser.id,
        status: 'active'
      }).select().single();
      
      if (error) {
        alert('Fehler: ' + error.message);
        return;
      }
      
      const projectId = projectData.id;
      
      // Owner als Projektmitglied hinzuf√ºgen
      await db.from('project_members').insert({
        project_id: projectId,
        user_id: cloudUser.id,
        role: 'owner'
      });
      
      await loadCloudProjects();
      await selectCloudProject(projectId);
    }

    async function syncFromCloud(cloudId, localId) {
      // Figuren laden
      const { data: figuren } = await db.from('figures').select('*').eq('project_id', cloudId).order('sort_order');
      save(KEYS.figuren(localId), (figuren || []).map(f => ({
        id: f.id, figur: f.name, kurzbeschreibung: f.description || ''
      })));
      
      // Szenen laden
      const { data: szenen } = await db.from('scenes').select('*').eq('project_id', cloudId).order('sort_order');
      save(KEYS.szenen(localId), (szenen || []).map(s => ({
        id: s.id, nummer: s.number || '', name: s.name, szene: s.name,
        beschreibung: s.description || '', hauptfiguren: '', nebenfiguren: ''
      })));
      
      // Personen laden
      const { data: persons } = await db.from('persons').select('*').eq('project_id', cloudId);
      save(KEYS.ensemble(localId), (persons || []).filter(p => p.category === 'ensemble').map(p => ({
        id: p.id, name: p.name, funktion: p.function_title || 'Schauspiel',
        email: p.email || '', telefon: p.phone || '',
        strasse: p.address_street || '', hausnummer: p.address_number || '',
        plz: p.address_zip || '', ort: p.address_city || '', land: p.address_country || 'Schweiz',
        bemerkungen: p.notes || ''
      })));
      save(KEYS.kuenstlerischesTeam(localId), (persons || []).filter(p => p.category === 'artistic_team').map(p => ({
        id: p.id, name: p.name, funktion: p.function_title || '',
        email: p.email || '', telefon: p.phone || '',
        strasse: p.address_street || '', hausnummer: p.address_number || '',
        plz: p.address_zip || '', ort: p.address_city || '', land: p.address_country || 'Schweiz',
        bemerkungen: p.notes || ''
      })));
      
      // Proben laden
      const { data: rehearsals } = await db.from('rehearsals').select('*').eq('project_id', cloudId).order('date');
      save(KEYS.probedaten(localId), (rehearsals || []).map(r => ({
        id: r.id, datum: r.date, wochentag: getWochentag(r.date),
        anfangszeit: r.start_time || '', endzeit: r.end_time || '',
        artDerProbe: r.notes || '', ort: r.location || '', anmerkungen: ''
      })));
      
      // Besetzung/Zuordnungen laden
      const { data: castings } = await db.from('castings')
        .select('id, figure_id, person_id')
        .eq('project_id', cloudId);
      
      if (castings && castings.length > 0) {
        // Figuren und Personen direkt aus Cloud laden f√ºr das Mapping
        const { data: cloudFigures } = await db.from('figures').select('id, name').eq('project_id', cloudId);
        const { data: cloudPersons } = await db.from('persons').select('id, name').eq('project_id', cloudId).eq('category', 'ensemble');
        
        const zuordnungen = castings.map(c => {
          const figur = cloudFigures?.find(f => f.id === c.figure_id);
          const person = cloudPersons?.find(p => p.id === c.person_id);
          return {
            id: c.id,
            figur: figur?.name || '',
            schauspieler: person?.name || ''
          };
        }).filter(z => z.figur && z.schauspieler);
        
        save(KEYS.zuordnungen(localId), zuordnungen);
      } else {
        save(KEYS.zuordnungen(localId), []);
      }
      
      // Absenzen laden - direkt aus Cloud mit Personen-Namen
      const { data: absences } = await db.from('person_absences')
        .select('id, person_id, date, start_time, end_time, reason')
        .in('person_id', (persons || []).filter(p => p.category === 'ensemble').map(p => p.id));
      
      save(KEYS.absenzen(localId), (absences || []).map(a => {
        const person = (persons || []).find(p => p.id === a.person_id);
        return {
          id: a.id,
          schauspieler: person?.name || '',
          datum: a.date,
          anfangszeit: a.start_time || '',
          endzeit: a.end_time || '',
          bemerkungen: a.reason || ''
        };
      }).filter(a => a.schauspieler));
      
      // Team-Verf√ºgbarkeit laden - direkt aus Cloud mit Personen-Namen
      const { data: availability } = await db.from('team_availability')
        .select('id, person_id, date, start_time, end_time, notes')
        .eq('project_id', cloudId);
      
      save(KEYS.teamVerfuegbarkeit(localId), (availability || []).map(a => {
        const person = (persons || []).find(p => p.id === a.person_id);
        return {
          id: a.id,
          teammitglied: person?.name || '',
          datum: a.date,
          anfangszeit: a.start_time || '',
          endzeit: a.end_time || '',
          bemerkungen: a.notes || ''
        };
      }).filter(a => a.teammitglied));
      
      // Probenplanung laden
      const { data: rehearsalScenes } = await db.from('rehearsal_scenes')
        .select('id, rehearsal_id, scene_id')
        .eq('project_id', cloudId);
      
      if (rehearsalScenes && rehearsalScenes.length > 0) {
        // Gruppiere nach Probe
        const grouped = {};
        rehearsalScenes.forEach(rs => {
          if (!grouped[rs.rehearsal_id]) grouped[rs.rehearsal_id] = [];
          grouped[rs.rehearsal_id].push(rs.scene_id);
        });
        
        const probenplanung = Object.entries(grouped).map(([probeId, szenenIds]) => ({
          probeId: probeId,
          szenen: szenenIds
        }));
        
        save(KEYS.probenplanung(localId), probenplanung);
      } else {
        save(KEYS.probenplanung(localId), []);
      }
    }

    async function syncToCloud() {
      if (!isCloudMode || !currentCloudProjectId || !state.projekt) return;
      if (cloudSyncInProgress) return;
      
      cloudSyncInProgress = true;
      const cloudId = currentCloudProjectId;
      const localId = state.projekt.id;
      
      try {
        // Figuren sync
        const figuren = load(KEYS.figuren(localId), []);
        for (const f of figuren) {
          if (f.id && !f.id.startsWith('id_')) continue; // Skip cloud items
          const { data } = await db.from('figures').insert({
            project_id: cloudId, name: f.figur || f.name, description: f.kurzbeschreibung || '',
            sort_order: figuren.indexOf(f)
          }).select().single();
          if (data) f.id = data.id;
        }
        save(KEYS.figuren(localId), figuren);
        
        // Weitere Sync... (bei Bedarf erweitern)
        
        showToast('‚òÅÔ∏è In Cloud gespeichert', 'success');
      } catch (err) {
        console.error('Sync error:', err);
      }
      
      cloudSyncInProgress = false;
    }

    async function deleteCloudProject(cloudId) {
      if (!confirm('Cloud-Projekt wirklich l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) return;
      
      try {
        // L√∂sche alle verkn√ºpften Daten (wegen Foreign Keys in richtiger Reihenfolge)
        
        // 1. Absenzen l√∂schen (√ºber persons)
        const { data: persons } = await db.from('persons').select('id').eq('project_id', cloudId);
        if (persons && persons.length > 0) {
          const personIds = persons.map(p => p.id);
          await db.from('person_absences').delete().in('person_id', personIds);
        }
        
        // 2. Castings l√∂schen
        await db.from('castings').delete().eq('project_id', cloudId);
        
        // 3. Rehearsal_scenes l√∂schen (falls vorhanden)
        await db.from('rehearsal_scenes').delete().eq('project_id', cloudId);
        
        // 4. Rehearsals l√∂schen
        await db.from('rehearsals').delete().eq('project_id', cloudId);
        
        // 5. Scene_figures l√∂schen (falls vorhanden)
        await db.from('scene_figures').delete().eq('project_id', cloudId);
        
        // 6. Scenes l√∂schen
        await db.from('scenes').delete().eq('project_id', cloudId);
        
        // 7. Figures l√∂schen
        await db.from('figures').delete().eq('project_id', cloudId);
        
        // 8. Persons l√∂schen
        await db.from('persons').delete().eq('project_id', cloudId);
        
        // 9. Project_members l√∂schen
        await db.from('project_members').delete().eq('project_id', cloudId);
        
        // 10. Project l√∂schen
        const { error } = await db.from('projects').delete().eq('id', cloudId);
        
        if (error) throw error;
        
        // Lokales Projekt mit dieser cloudId auch entfernen
        state.projekte = state.projekte.filter(p => p.cloudId !== cloudId);
        save(KEYS.projekte, state.projekte);
        
        // Wenn das aktive Projekt gel√∂scht wurde
        if (currentCloudProjectId === cloudId) {
          currentCloudProjectId = null;
          state.projekt = null;
          save(KEYS.aktuellesProjekt, null);
        }
        
        await loadCloudProjects();
        showToast('üóëÔ∏è Cloud-Projekt gel√∂scht', 'success');
        render();
        
      } catch (err) {
        console.error('Delete error:', err);
        alert('Fehler beim L√∂schen: ' + err.message);
      }
    }

    // Lokales Projekt komplett in die Cloud hochladen
    async function uploadProjectToCloud(localId) {
      if (!isCloudMode || !cloudUser) {
        alert('Bitte zuerst einloggen!');
        return;
      }
      
      const projekt = state.projekte.find(p => p.id === localId);
      if (!projekt) return;
      
      if (!confirm(`Projekt "${projekt.name}" in die Cloud hochladen?`)) return;
      
      showToast('‚òÅÔ∏è Lade hoch...', 'info');
      
      try {
        // 1. Projekt direkt in Cloud erstellen (ohne RPC)
        const { data: projectData, error: projectError } = await db.from('projects').insert({
          name: projekt.name,
          premiere_date: projekt.premiere || null,
          director: projekt.regie || null,
          venue: projekt.spielstaette || null,
          created_by: cloudUser.id,
          status: 'active'
        }).select().single();
        
        if (projectError) throw projectError;
        const cloudId = projectData.id;
        
        // 1b. Owner als Projektmitglied hinzuf√ºgen
        await db.from('project_members').insert({
          project_id: cloudId,
          user_id: cloudUser.id,
          role: 'owner'
        });
        
        // 2. Figuren hochladen
        const figuren = load(KEYS.figuren(localId), []);
        console.log('Uploading', figuren.length, 'figures');
        for (let i = 0; i < figuren.length; i++) {
          const f = figuren[i];
          const { error } = await db.from('figures').insert({
            project_id: cloudId,
            name: f.figur || f.name || '',
            description: f.kurzbeschreibung || '',
            sort_order: i,
            color: '#3b82f6'
          });
          if (error) console.error('Figure upload error:', error);
        }
        
        // 3. Szenen hochladen
        const szenen = load(KEYS.szenen(localId), []);
        console.log('Uploading', szenen.length, 'scenes');
        for (let i = 0; i < szenen.length; i++) {
          const s = szenen[i];
          const { error } = await db.from('scenes').insert({
            project_id: cloudId,
            name: s.name || s.szene || '',
            number: s.nummer || '',
            description: s.beschreibung || '',
            sort_order: i
          });
          if (error) console.error('Scene upload error:', error);
        }
        
        // 4. Ensemble hochladen
        const ensemble = load(KEYS.ensemble(localId), []);
        console.log('Uploading', ensemble.length, 'ensemble members');
        for (const p of ensemble) {
          const { error } = await db.from('persons').insert({
            project_id: cloudId,
            name: p.name,
            category: 'ensemble',
            function_title: p.funktion || 'Schauspiel',
            email: p.email || '',
            phone: p.telefon || '',
            address_street: p.strasse || '',
            address_number: p.hausnummer || '',
            address_zip: p.plz || '',
            address_city: p.ort || '',
            address_country: p.land || 'Schweiz',
            notes: p.bemerkungen || ''
          });
          if (error) console.error('Ensemble upload error:', error);
        }
        
        // 5. Team hochladen
        const team = load(KEYS.kuenstlerischesTeam(localId), []);
        console.log('Uploading', team.length, 'team members');
        for (const p of team) {
          const { error } = await db.from('persons').insert({
            project_id: cloudId,
            name: p.name,
            category: 'artistic_team',
            function_title: p.funktion || '',
            email: p.email || '',
            phone: p.telefon || '',
            address_street: p.strasse || '',
            address_number: p.hausnummer || '',
            address_zip: p.plz || '',
            address_city: p.ort || '',
            address_country: p.land || 'Schweiz',
            notes: p.bemerkungen || ''
          });
          if (error) console.error('Team upload error:', error);
        }
        
        // 6. Proben hochladen
        const proben = load(KEYS.probedaten(localId), []);
        console.log('Uploading', proben.length, 'rehearsals');
        for (const r of proben) {
          const { error } = await db.from('rehearsals').insert({
            project_id: cloudId,
            date: toISODate(r.datum),
            start_time: r.anfangszeit || '10:00',
            end_time: r.endzeit || '13:00',
            location: r.ort || '',
            notes: r.artDerProbe || r.anmerkungen || '',
            rehearsal_type: 'regular'
          });
          if (error) console.error('Rehearsal upload error:', error);
        }
        
        // 7. Zuordnungen hochladen (braucht Figure-IDs und Person-IDs aus Cloud)
        const zuordnungen = load(KEYS.zuordnungen(localId), []);
        console.log('Uploading', zuordnungen.length, 'castings');
        if (zuordnungen.length > 0) {
          // Hole die gerade erstellten Figuren und Personen
          const { data: cloudFigures } = await db.from('figures')
            .select('id, name')
            .eq('project_id', cloudId);
          const { data: cloudPersons } = await db.from('persons')
            .select('id, name')
            .eq('project_id', cloudId)
            .eq('category', 'ensemble');
          
          console.log('Cloud figures:', cloudFigures?.length, 'Cloud persons:', cloudPersons?.length);
          
          for (const z of zuordnungen) {
            const figure = cloudFigures?.find(f => f.name?.toLowerCase() === (z.figur || '').toLowerCase());
            const person = cloudPersons?.find(p => p.name?.toLowerCase() === (z.schauspieler || '').toLowerCase());
            if (figure && person) {
              const { error } = await db.from('castings').insert({
                project_id: cloudId,
                figure_id: figure.id,
                person_id: person.id,
                casting_type: 'primary'
              });
              if (error) console.error('Casting upload error:', error);
            } else {
              console.warn('Casting not found:', z.figur, '‚Üí', z.schauspieler, 'figure:', !!figure, 'person:', !!person);
            }
          }
        }
        
        // 8. Absenzen hochladen (braucht Person-IDs aus Cloud)
        const absenzen = load(KEYS.absenzen(localId), []);
        console.log('Uploading', absenzen.length, 'absences');
        if (absenzen.length > 0) {
          // Hole die gerade erstellten Personen
          const { data: cloudPersons } = await db.from('persons')
            .select('id, name')
            .eq('project_id', cloudId)
            .eq('category', 'ensemble');
          
          for (const a of absenzen) {
            const person = cloudPersons?.find(p => p.name?.toLowerCase() === (a.schauspieler || '').toLowerCase());
            if (person) {
              const { error } = await db.from('person_absences').insert({
                person_id: person.id,
                date: toISODate(a.datum),
                start_time: a.anfangszeit || null,
                end_time: a.endzeit || null,
                reason: a.bemerkungen || ''
              });
              if (error) console.error('Absence upload error:', error);
            } else {
              console.warn('Absence person not found:', a.schauspieler);
            }
          }
        }
        
        // 9. Team-Verf√ºgbarkeit hochladen
        const teamVerfuegbarkeit = load(KEYS.teamVerfuegbarkeit(localId), []);
        if (teamVerfuegbarkeit.length > 0) {
          const { data: cloudTeam } = await db.from('persons')
            .select('id, name')
            .eq('project_id', cloudId)
            .eq('category', 'artistic_team');
          
          for (const tv of teamVerfuegbarkeit) {
            const person = cloudTeam?.find(p => p.name.toLowerCase() === (tv.teammitglied || '').toLowerCase());
            if (person) {
              await db.from('team_availability').insert({
                project_id: cloudId,
                person_id: person.id,
                date: toISODate(tv.datum),
                start_time: tv.anfangszeit || null,
                end_time: tv.endzeit || null,
                notes: tv.bemerkungen || ''
              });
            }
          }
        }
        
        // 10. Probenplanung hochladen
        const probenplanung = load(KEYS.probenplanung(localId), []);
        if (probenplanung.length > 0) {
          const { data: cloudRehearsals } = await db.from('rehearsals')
            .select('id, date')
            .eq('project_id', cloudId);
          const { data: cloudScenes } = await db.from('scenes')
            .select('id, name')
            .eq('project_id', cloudId);
          const localProben = load(KEYS.probedaten(localId), []);
          const localSzenen = load(KEYS.szenen(localId), []);
          
          for (const pp of probenplanung) {
            // Finde die Cloud-Probe anhand des lokalen Probe-Datums
            const localProbe = localProben.find(p => String(p.id) === String(pp.probeId));
            if (!localProbe) continue;
            
            const cloudRehearsal = cloudRehearsals?.find(r => r.date === toISODate(localProbe.datum));
            if (!cloudRehearsal) continue;
            
            for (const szId of (pp.szenen || [])) {
              const localSzene = localSzenen.find(s => s.id === szId);
              if (!localSzene) continue;
              
              const cloudScene = cloudScenes?.find(s => s.name.toLowerCase() === (localSzene.name || localSzene.szene || '').toLowerCase());
              if (cloudScene) {
                await db.from('rehearsal_scenes').insert({
                  project_id: cloudId,
                  rehearsal_id: cloudRehearsal.id,
                  scene_id: cloudScene.id
                });
              }
            }
          }
        }
        
        // 11. Lokales Projekt mit Cloud-ID verkn√ºpfen
        projekt.cloudId = cloudId;
        save(KEYS.projekte, state.projekte);
        
        // 12. Cloud-Projekte neu laden
        await loadCloudProjects();
        
        showToast('‚úÖ Projekt in Cloud hochgeladen!', 'success');
        render();
        
      } catch (err) {
        console.error('Upload error:', err);
        alert('Fehler beim Hochladen: ' + err.message);
      }
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `fixed bottom-4 right-4 px-4 py-2 rounded-lg text-white z-50 ${
        type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500'
      }`;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function renderLoginPage() {
      return `
        <div class="min-h-screen flex items-center justify-center p-4" style="background: linear-gradient(135deg, #134e4a 0%, #0f172a 100%);">
          <div class="bg-white rounded-xl shadow-2xl p-8 w-full max-w-md">
            <div class="text-center mb-8">
              <h1 class="text-3xl font-bold text-gray-800 mb-2">DRAMERA</h1>
              <p class="text-lg text-teal-600 font-medium">Propla v2.0</p>
              <p class="text-gray-500 text-sm">Probeplaner Stand-alone</p>
            </div>
            
            <div id="cloud_status" class="mb-4"></div>
            
            <div class="space-y-4 mb-6">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">E-Mail</label>
                <input type="email" id="cloud_email" class="w-full px-3 py-2 border rounded-lg" placeholder="deine@email.ch">
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Passwort</label>
                <input type="password" id="cloud_password" class="w-full px-3 py-2 border rounded-lg" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" onkeypress="if(event.key==='Enter')cloudLogin()">
              </div>
              <div id="register_name_row" class="hidden">
                <label class="block text-sm font-medium text-gray-700 mb-1">Name</label>
                <input type="text" id="cloud_name" class="w-full px-3 py-2 border rounded-lg" placeholder="Dein Name">
              </div>
            </div>
            
            <div class="flex gap-3 mb-6">
              <button onclick="cloudLogin()" class="btn btn-primary flex-1">‚òÅÔ∏è Einloggen</button>
              <button onclick="toggleRegisterFields()" class="btn btn-outline flex-1">Registrieren</button>
            </div>
            
            <div id="register_btn_row" class="hidden mb-6">
              <button onclick="cloudRegister()" class="btn btn-success w-full">‚úì Jetzt registrieren</button>
            </div>
            
            <div class="border-t pt-4">
              <button onclick="useLocalMode()" class="btn btn-outline w-full">üíæ Offline-Modus (ohne Cloud)</button>
            </div>
            
            <div class="mt-4 text-center text-xs text-gray-400">
              Verbunden mit: xxjaxakayickwjzeinru.supabase.co
            </div>
          </div>
        </div>
      `;
    }

    function renderApp() {
      // Stand-alone Modus: Direkt zur App (kein Cloud-Login n√∂tig)
      
      // Normale App rendern
      render();
    }

    // ============================================
    // STATE
    // ============================================
    let state = {
      page: 'dashboard',
      projekte: load(KEYS.projekte, []),
      projekt: load(KEYS.aktuellesProjekt, null),
      selectedProbe: null,
      editingItem: null,
      editingType: null,
      showImportModal: null,
      showProjektAuswahl: false,
    };

    const getData = (key) => state.projekt ? load(key(state.projekt.id), []) : [];
    const setData = (key, data) => { if (state.projekt) save(key(state.projekt.id), data); };

    // ============================================
    // NAVIGATION
    // ============================================
    const NAV = {
      planung: { label: 'PLANUNG', items: [
        { id: 'dashboard', label: 'Dashboard', icon: 'üè†' },
        { id: 'probedaten', label: 'Probedaten', icon: 'üìÖ' },
        { id: 'szenenvorschlag', label: 'Probeplan', icon: 'üìã' },
        { id: 'absenzen', label: 'Absenzen', icon: 'üö´' },
      ]},
      ensemble: { label: 'BESETZUNG', items: [
        { id: 'ensemble', label: 'Ensemble', icon: 'üë•' },
        { id: 'team', label: 'K√ºnstl. Team', icon: 'üé¨' },
        { id: 'teamverfuegbarkeit', label: 'Team-Verf√ºgbarkeit', icon: 'üìÜ' },
        { id: 'figuren', label: 'Figuren', icon: 'üé≠' },
        { id: 'zuordnung', label: 'Besetzung', icon: 'üîó' },
        { id: 'szenen', label: 'Szenen', icon: 'üìë' },
      ]},
      system: { label: 'SYSTEM', items: [
        { id: 'listen', label: 'Listen-Export', icon: 'üìã' },
        { id: 'importexport', label: 'Import / Export', icon: 'üîÑ' },
        { id: 'einstellungen', label: 'Einstellungen', icon: '‚öôÔ∏è' },
      ]}
    };

    // ============================================
    // RENDER
    // ============================================
    function render() {
      document.getElementById('app').innerHTML = `
        <div class="flex h-screen overflow-hidden">
          ${renderSidebar()}
          <div class="flex-1 flex flex-col overflow-hidden">
            ${renderHeader()}
            <main class="flex-1 overflow-auto bg-gray-100 p-6">
              ${renderPage()}
            </main>
          </div>
        </div>
      `;
      renderModal();
    }

    function renderSidebar() {
      let sections = '';
      Object.entries(NAV).forEach(([key, section]) => {
        sections += `<div class="nav-section px-4 py-2 mt-4">${section.label}</div>`;
        sections += section.items.map(item => `
          <button onclick="navigate('${item.id}')" 
            class="nav-item w-full text-left px-4 py-2 text-sm flex items-center gap-3 
              ${state.page === item.id ? 'active text-white font-medium' : 'text-teal-200 hover:text-white'}">
            <span class="w-5 text-center opacity-80">${item.icon}</span>
            <span>${item.label}</span>
          </button>
        `).join('');
      });

      return `
        <aside class="sidebar w-56 flex flex-col">
          <!-- Header: Text oben -->
          <div class="p-4 border-b border-teal-800/30 text-center">
            <h1 class="text-xl font-bold text-white">Dramera Propla</h1>
            <p class="text-xs text-teal-300">Probeplaner v2.0</p>
          </div>
          
          <!-- Logo darunter, volle Breite -->
          <div class="px-4 py-3 border-b border-teal-800/30">
            <img src="${NINA_LOGO}" alt="N!NA Konzept" class="sidebar-logo">
          </div>
          
          <!-- Google Drive Status -->
          ${gdriveIsConnected() ? `
            <div class="p-2 mx-3 mt-3 bg-blue-900/40 rounded-lg border border-blue-700/30">
              <div class="flex items-center gap-2 text-xs text-blue-300">
                <span>‚òÅÔ∏è</span>
                <span class="truncate">${gdriveUser?.email || 'Google Drive'}</span>
              </div>
              ${gdriveFolderName ? `<div class="text-xs text-blue-400 mt-1 truncate">üìÅ ${gdriveFolderName}</div>` : ''}
            </div>
          ` : ''}
          
          <!-- Projekt-Anzeige mit Wechsel-Button -->
          ${state.projekt ? `
            <div class="p-3 mx-3 my-3 bg-teal-900/40 rounded-lg border border-teal-700/30">
              <div class="text-xs text-teal-400 uppercase tracking-wider">Projekt</div>
              <div class="text-sm text-white font-medium truncate">${escapeHtml(state.projekt.name)}</div>
              ${state.projekt.premiere ? `<div class="text-xs text-teal-300 mt-1">Premiere: ${formatDatumKurz(state.projekt.premiere)}</div>` : ''}
              <button onclick="showProjektAuswahl()" class="btn btn-outline-light btn-xs w-full mt-2">üîÑ Projekt wechseln</button>
            </div>
          ` : `
            <div class="p-3 mx-3 my-3 bg-orange-900/40 rounded-lg border border-orange-700/30">
              <div class="text-orange-300 text-sm">‚ö†Ô∏è Kein Projekt</div>
              <button onclick="showProjektAuswahl()" class="btn btn-outline-light btn-xs w-full mt-2">üìÅ Projekt w√§hlen</button>
            </div>
          `}
          
          <nav class="flex-1 overflow-y-auto">${sections}</nav>
          
          <!-- Footer -->
          <div class="p-3 border-t border-teal-800/30">
            <div class="text-xs text-teal-400 text-center">Dramera Propla v3.0</div>
          </div>
        </aside>
      `;
    }

    function renderHeader() {
      const titles = {
        dashboard: 'üè† Dashboard', probedaten: 'üìÖ Probedaten', ensemble: 'üë• Ensemble',
        team: 'üé¨ K√ºnstlerisches Team', teamverfuegbarkeit: 'üìÜ Team-Verf√ºgbarkeit',
        figuren: 'üé≠ Figuren', zuordnung: 'üîó Besetzung', 
        szenen: 'üìë Szenen', absenzen: 'üö´ Absenzen', szenenvorschlag: 'üìã Probeplan',
        listen: 'üìã Listen-Export', importexport: 'üîÑ Import / Export',
        einstellungen: '‚öôÔ∏è Einstellungen'
      };
      return `
        <header class="bg-white border-b px-6 py-3 flex items-center justify-between shadow-sm">
          <h1 class="text-lg font-semibold text-gray-800">${titles[state.page] || 'Dramera Propla'}</h1>
          <div class="flex items-center gap-4">
            <span class="text-sm text-gray-500">${new Date().toLocaleDateString('de-DE', { weekday: 'long', day: 'numeric', month: 'long' })}</span>
          </div>
        </header>
      `;
    }

    function renderPage() {
      // Projekt-Auswahl Modal anzeigen
      if (state.showProjektAuswahl) {
        return renderProjektAuswahl();
      }
      
      if (!state.projekt && !['dashboard', 'einstellungen', 'importexport'].includes(state.page)) {
        return `<div class="flex items-center justify-center h-full"><div class="text-center card p-8"><div class="text-5xl mb-4">üìÅ</div><h2 class="text-xl font-semibold mb-2">Kein Projekt ausgew√§hlt</h2><button onclick="showProjektAuswahl()" class="btn btn-primary">Projekt w√§hlen</button></div></div>`;
      }
      switch (state.page) {
        case 'dashboard': return renderDashboard();
        case 'probedaten': return renderProbedaten();
        case 'ensemble': return renderEnsemble();
        case 'team': return renderTeam();
        case 'teamverfuegbarkeit': return renderTeamVerfuegbarkeit();
        case 'figuren': return renderFiguren();
        case 'zuordnung': return renderZuordnung();
        case 'szenen': return renderSzenen();
        case 'absenzen': return renderAbsenzen();
        case 'szenenvorschlag': return renderSzenenvorschlag();
        case 'listen': return renderListen();
        case 'importexport': return renderImportExport();
        case 'einstellungen': return renderEinstellungen();
        default: return '<div>Seite nicht gefunden</div>';
      }
    }

    // ============================================
    // PROJEKT-AUSWAHL (NEU!)
    // ============================================
    function renderProjektAuswahl() {
      // Projekte f√ºr Anzeige vorbereiten
      const allProjects = isCloudMode ? cloudProjects : state.projekte;
      
      return `
        <div class="fade-in max-w-4xl mx-auto">
          <div class="text-center mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-2">Projekt ausw√§hlen</h2>
          </div>
          
          <!-- Projekt importieren -->
          <div class="card p-6 mb-6 bg-green-50 border-green-200">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-4">
                <div class="text-3xl">üì•</div>
                <div>
                  <h3 class="font-semibold text-green-800">Backup laden</h3>
                  <p class="text-sm text-green-600">Fr√ºheres Propla-Backup als neues Projekt √∂ffnen</p>
                </div>
              </div>
              <label class="btn btn-success cursor-pointer">
                üìÇ Datei w√§hlen
                <input type="file" accept=".json" onchange="importBackup(this)" class="hidden">
              </label>
            </div>
          </div>
          
          <!-- NINA-Exchange Import (von Dramera/Rebu) -->
          <div class="card p-6 mb-6" style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(20,184,166,0.15)); border-color: #8b5cf6;">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-4">
                <div class="text-3xl">üîÑ</div>
                <div>
                  <h3 class="font-semibold" style="color: #5b21b6;">Austausch-Datei laden</h3>
                  <p class="text-sm" style="color: #7c3aed;">Daten aus Werkbank oder Rebu √ºbernehmen</p>
                </div>
              </div>
              <label class="btn cursor-pointer" style="background: linear-gradient(135deg, #8b5cf6, #14b8a6); color: white;">
                  üìÇ Datei w√§hlen
                  <input type="file" accept=".json" onchange="importNinaExchange(this)" class="hidden">
              </label>
            </div>
          </div>
          
          <!-- Neues Projekt erstellen -->
          <div class="card p-6 mb-6">
            <h3 class="font-semibold text-lg mb-4">‚ûï Neues Projekt erstellen</h3>
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div><label class="input-label">Projektname *</label><input type="text" id="neuesProjektName" placeholder="z.B. Hamlet"></div>
              <div><label class="input-label">Premiere</label><input type="date" id="neuesProjektPremiere"></div>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div><label class="input-label">Regie</label><input type="text" id="neuesProjektRegie"></div>
              <div><label class="input-label">Spielst√§tte</label><input type="text" id="neuesProjektSpielstaette"></div>
            </div>
            <button onclick="createProjekt()" class="btn btn-primary w-full">
              ‚ûï Projekt erstellen
            </button>
          </div>
          
          <!-- Projekte -->
          ${state.projekte.length > 0 ? `
            <div class="card p-6">
              <h3 class="font-semibold text-lg mb-4">üìÅ Meine Projekte (${state.projekte.length})</h3>
              <div class="space-y-3">
                ${state.projekte.map(p => `
                  <div class="flex items-center justify-between p-4 rounded-lg border ${state.projekt?.id === p.id ? 'bg-teal-50 border-teal-300' : 'bg-gray-50 border-gray-200 hover:bg-teal-50'} transition cursor-pointer" onclick="selectProjekt('${p.id}')">
                    <div class="flex-1">
                      <div class="font-medium flex items-center gap-2">
                        üìÅ ${escapeHtml(p.name)}
                        ${state.projekt?.id === p.id ? '<span class="tag tag-blue">Aktiv</span>' : ''}
                      </div>
                      <div class="text-sm text-gray-500">
                        ${p.regie ? `Regie: ${escapeHtml(p.regie)}` : ''}
                        ${p.premiere ? ` ‚Ä¢ Premiere: ${formatDatum(p.premiere)}` : ''}
                      </div>
                    </div>
                    <div class="flex gap-2">
                      ${isCloudMode && !p.cloudId ? `<button onclick="event.stopPropagation(); uploadProjectToCloud('${p.id}')" class="btn btn-success btn-sm">‚òÅÔ∏è Hochladen</button>` : ''}
                      <button onclick="event.stopPropagation(); selectProjekt('${p.id}')" class="btn btn-primary btn-sm">√ñffnen</button>
                      <button onclick="event.stopPropagation(); deleteProjekt('${p.id}')" class="btn btn-outline btn-sm text-red-500 hover:bg-red-50">üóëÔ∏è</button>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
          ` : !isCloudMode || cloudProjects.length === 0 ? `
            <div class="card p-8 text-center text-gray-400">
              <div class="text-4xl mb-3">üìÅ</div>
              <p>Noch keine Projekte vorhanden</p>
            </div>
          ` : ''}
          
          ${state.projekt ? `
            <div class="mt-6 text-center">
              <button onclick="closeProjektAuswahl()" class="btn btn-outline">‚Üê Zur√ºck zum Projekt</button>
            </div>
          ` : ''}
        </div>
      `;
    }
    
    function showProjektAuswahl() {
      state.showProjektAuswahl = true;
      render();
    }
    
    function closeProjektAuswahl() {
      state.showProjektAuswahl = false;
      render();
    }

    // ============================================
    // MODAL SYSTEM
    // ============================================
    function renderModal() {
      const modalEl = document.getElementById('modal');
      if (state.editingItem && state.editingType) { modalEl.innerHTML = renderEditModal(); return; }
      if (state.showImportModal) { modalEl.innerHTML = renderImportModal(); setTimeout(setupImportDragDrop, 100); return; }
      modalEl.innerHTML = '';
    }
    
    function renderEditModal() {
      const item = state.editingItem;
      const type = state.editingType;
      const fields = {
        probedaten: [{ key: 'datum', label: 'Datum', type: 'date' },{ key: 'anfangszeit', label: 'Von', type: 'time' },{ key: 'endzeit', label: 'Bis', type: 'time' },{ key: 'artDerProbe', label: 'Art der Probe', type: 'select', options: PROBENARTEN },{ key: 'ort', label: 'Ort', type: 'text' },{ key: 'anmerkungen', label: 'Anmerkungen', type: 'text' }],
        ensemble: [{ key: 'name', label: 'Name', type: 'text' },{ key: 'funktion', label: 'Funktion', type: 'text' },{ key: 'email', label: 'E-Mail', type: 'email' },{ key: 'telefon', label: 'Telefon', type: 'tel' },{ key: 'strasse', label: 'Strasse', type: 'text' },{ key: 'hausnummer', label: 'Nr.', type: 'text' },{ key: 'plz', label: 'PLZ', type: 'text' },{ key: 'ort', label: 'Ort', type: 'text' },{ key: 'bemerkungen', label: 'Bemerkungen', type: 'text' }],
        kuenstlerischesTeam: [{ key: 'name', label: 'Name', type: 'text' },{ key: 'funktion', label: 'Funktion', type: 'select', options: TEAM_FUNKTIONEN },{ key: 'email', label: 'E-Mail', type: 'email' },{ key: 'telefon', label: 'Telefon', type: 'tel' },{ key: 'strasse', label: 'Strasse', type: 'text' },{ key: 'hausnummer', label: 'Nr.', type: 'text' },{ key: 'plz', label: 'PLZ', type: 'text' },{ key: 'ort', label: 'Ort', type: 'text' },{ key: 'bemerkungen', label: 'Bemerkungen', type: 'text' }],
        teamVerfuegbarkeit: [{ key: 'teammitglied', label: 'Teammitglied', type: 'text', readonly: true },{ key: 'datum', label: 'Datum', type: 'date' },{ key: 'anfangszeit', label: 'Von', type: 'time' },{ key: 'endzeit', label: 'Bis', type: 'time' },{ key: 'bemerkungen', label: 'Bemerkungen', type: 'text' }],
        figuren: [{ key: 'figur', label: 'Figur', type: 'text' },{ key: 'kurzbeschreibung', label: 'Kurzbeschreibung', type: 'textarea' }],
        szenen: [{ key: 'nummer', label: 'Nr.', type: 'text' },{ key: 'name', label: 'Szene', type: 'text' },{ key: 'beschreibung', label: 'Beschreibung', type: 'textarea' },{ key: 'hauptfiguren', label: 'Hauptfiguren', type: 'text' },{ key: 'nebenfiguren', label: 'Nebenfiguren', type: 'text' }],
        absenzen: [{ key: 'schauspieler', label: 'Person', type: 'text', readonly: true },{ key: 'datum', label: 'Datum', type: 'date' },{ key: 'anfangszeit', label: 'Von', type: 'time' },{ key: 'endzeit', label: 'Bis', type: 'time' },{ key: 'bemerkungen', label: 'Bemerkungen', type: 'text' }],
        zuordnungen: [{ key: 'figur', label: 'Figur', type: 'text' },{ key: 'schauspieler', label: 'Schauspieler:in', type: 'text' }],
      };
      const typeFields = fields[type] || [];
      return `<div class="modal" onclick="if(event.target===this) closeModal()"><div class="modal-content p-6" style="max-width: 600px;"><div class="flex justify-between items-center mb-4"><h3 class="text-lg font-semibold">‚úèÔ∏è Bearbeiten</h3><button onclick="closeModal()" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button></div><div class="space-y-4">${typeFields.map(f => `<div><label class="input-label">${f.label}</label>${f.type === 'select' ? `<select id="edit_${f.key}" ${f.readonly ? 'disabled' : ''}><option value="">--</option>${f.options.map(o => `<option value="${o}" ${item[f.key] === o ? 'selected' : ''}>${o}</option>`).join('')}</select>` : f.type === 'textarea' ? `<textarea id="edit_${f.key}" rows="3" ${f.readonly ? 'readonly' : ''}>${escapeHtml(item[f.key] || '')}</textarea>` : `<input type="${f.type}" id="edit_${f.key}" value="${escapeHtml(item[f.key] || '')}" ${f.readonly ? 'readonly' : ''}>`}</div>`).join('')}</div><div class="flex justify-end gap-2 mt-6"><button onclick="closeModal()" class="btn btn-outline">Abbrechen</button><button onclick="saveEdit()" class="btn btn-primary">üíæ Speichern</button></div></div></div>`;
    }
    
    function renderImportModal() {
      const config = { probedaten: { title: 'Probedaten importieren', fields: ['datum', 'wochentag', 'anfangszeit', 'endzeit', 'artDerProbe', 'ort', 'anmerkungen'] }, ensemble: { title: 'Ensemble importieren', fields: ['name', 'email', 'telefon', 'funktion', 'bemerkungen', 'strasse', 'hausnummer', 'plz', 'ort', 'land'] }, team: { title: 'K√ºnstl. Team importieren', fields: ['name', 'email', 'telefon', 'funktion', 'bemerkungen', 'strasse', 'hausnummer', 'plz', 'ort', 'land'] }, teamVerfuegbarkeit: { title: 'Team-Verf√ºgbarkeit importieren', fields: ['teammitglied', 'datum', 'anfangszeit', 'endzeit', 'bemerkungen'] }, figuren: { title: 'Figuren importieren', fields: ['figur', 'kurzbeschreibung'] }, zuordnungen: { title: 'Zuordnungen importieren', fields: ['figur', 'schauspieler'] }, szenen: { title: 'Szenen importieren', fields: ['szene', 'nummer', 'beschreibung', 'hauptfiguren', 'nebenfiguren'] }, absenzen: { title: 'Absenzen importieren', fields: ['schauspieler', 'datum', 'anfangszeit', 'endzeit', 'bemerkungen'] } };
      const c = config[state.showImportModal];
      return `<div class="modal" onclick="if(event.target===this) closeModal()"><div class="modal-content p-6"><div class="flex justify-between items-center mb-4"><h3 class="text-lg font-semibold">üì• ${c.title}</h3><button onclick="closeModal()" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button></div><div class="import-zone mb-4" id="importDropZone"><div class="text-4xl mb-2">üìÑ</div><p class="text-gray-600 mb-2">CSV oder Excel-Datei hier ablegen</p><label class="btn btn-primary mt-2 cursor-pointer">Datei ausw√§hlen<input type="file" accept=".csv,.xlsx,.xls" onchange="handleImportFile(this, '${state.showImportModal}')" class="hidden"></label></div><div class="bg-gray-50 rounded-lg p-4 text-sm"><div class="font-semibold mb-2">Erwartete Spalten:</div><div class="flex flex-wrap gap-2">${c.fields.map(f => `<span class="tag tag-blue">${f}</span>`).join('')}</div></div><div id="importPreview" class="mt-4 hidden"><div class="font-semibold mb-2">Vorschau:</div><div class="max-h-48 overflow-auto border rounded" id="importPreviewTable"></div><div class="mt-3 flex justify-end gap-2"><button onclick="closeModal()" class="btn btn-outline">Abbrechen</button><button onclick="confirmImport()" class="btn btn-success" id="confirmImportBtn">Importieren</button></div></div></div></div>`;
    }
    
    function setupImportDragDrop() { const dropZone = document.getElementById('importDropZone'); if (dropZone) { dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); }); dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('dragover'); }); dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); const file = e.dataTransfer.files[0]; if (file) processImportFile(file, state.showImportModal); }); } }

    let pendingImportData = null, pendingImportType = null;
    function handleImportFile(input, type) { const file = input.files[0]; if (file) processImportFile(file, type); }
    function processImportFile(file, type) { const reader = new FileReader(); if (file.name.endsWith('.csv')) { reader.onload = (e) => { const rows = parseCSV(e.target.result); showImportPreview(rows, type); }; reader.readAsText(file); } else { reader.onload = (e) => { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, { type: 'array' }); const firstSheet = workbook.Sheets[workbook.SheetNames[0]]; const rows = XLSX.utils.sheet_to_json(firstSheet, { defval: '' }); showImportPreview(rows, type); }; reader.readAsArrayBuffer(file); } }
    function parseCSV(text) { text = text.replace(/^\uFEFF/, ''); const lines = text.split(/\r?\n/).filter(l => l.trim()); if (lines.length < 2) return []; const firstLine = lines[0]; const delimiter = (firstLine.match(/;/g) || []).length > (firstLine.match(/,/g) || []).length ? ';' : ','; const parseRow = (line) => { const result = []; let current = ''; let inQuotes = false; for (let i = 0; i < line.length; i++) { const char = line[i]; if (char === '"') { if (inQuotes && line[i + 1] === '"') { current += '"'; i++; } else { inQuotes = !inQuotes; } } else if (char === delimiter && !inQuotes) { result.push(current.trim()); current = ''; } else { current += char; } } result.push(current.trim()); return result; }; const headers = parseRow(lines[0]).map(h => h.toLowerCase().replace(/[^a-z0-9_√§√∂√º√ü]/g, '')); const rows = []; for (let i = 1; i < lines.length; i++) { const values = parseRow(lines[i]); const row = {}; headers.forEach((h, idx) => { row[h] = values[idx] || ''; }); rows.push(row); } return rows; }
    function showImportPreview(rows, type) { if (rows.length === 0) { alert('Keine Daten!'); return; } const normalizedRows = rows.map(row => { const normalized = {}; Object.keys(row).forEach(key => { const normKey = key.toLowerCase().replace(/^\uFEFF/, '').replace(/[^a-z0-9_√§√∂√º√ü]/g, ''); normalized[normKey] = row[key]; }); return normalized; }); pendingImportData = normalizedRows; pendingImportType = type; const headers = Object.keys(normalizedRows[0]); const preview = document.getElementById('importPreview'); const table = document.getElementById('importPreviewTable'); table.innerHTML = `<table class="text-xs"><thead><tr>${headers.slice(0, 6).map(h => `<th class="p-2">${escapeHtml(h)}</th>`).join('')}</tr></thead><tbody>${normalizedRows.slice(0, 5).map(row => `<tr>${headers.slice(0, 6).map(h => `<td class="p-2">${escapeHtml(String(row[h] || '').substring(0, 30))}</td>`).join('')}</tr>`).join('')}</tbody></table>`; document.getElementById('confirmImportBtn').textContent = `${normalizedRows.length} Eintr√§ge importieren`; preview.classList.remove('hidden'); }
    async function confirmImport() { 
      if (!pendingImportData || !pendingImportType || !state.projekt) return; 
      const keyMap = { probedaten: KEYS.probedaten, ensemble: KEYS.ensemble, team: KEYS.kuenstlerischesTeam, teamVerfuegbarkeit: KEYS.teamVerfuegbarkeit, figuren: KEYS.figuren, zuordnungen: KEYS.zuordnungen, szenen: KEYS.szenen, absenzen: KEYS.absenzen }; 
      const keyFn = keyMap[pendingImportType];
      if (!keyFn) { alert('Unbekannter Import-Typ!'); return; }
      
      const existingData = load(keyFn(state.projekt.id), []); 
      const newData = pendingImportData.map(row => { 
        const item = { id: row.id || genId() }; 
        Object.keys(row).forEach(key => { if (key !== 'id') item[key] = row[key]; }); 
        if (pendingImportType === 'szenen' && row.szene && !row.name) item.name = row.szene; 
        if (pendingImportType === 'figuren' && !row.figur && row.name) item.figur = row.name; 
        return item; 
      }); 
      const keyField = { ensemble: 'name', team: 'name', figuren: 'figur', zuordnungen: 'figur', szenen: 'name' }[pendingImportType]; 
      let merged, toAdd; 
      if (keyField) { 
        const existingKeys = new Set(existingData.map(d => (d[keyField] || '').toLowerCase())); 
        toAdd = newData.filter(d => !existingKeys.has((d[keyField] || '').toLowerCase())); 
        merged = [...existingData, ...toAdd]; 
      } else { 
        toAdd = newData;
        merged = [...existingData, ...newData]; 
      } 
      save(keyFn(state.projekt.id), merged); 
      
      // Cloud Sync f√ºr importierte Daten
      if (isCloudMode && currentCloudProjectId && toAdd.length > 0) {
        showToast('‚òÅÔ∏è Lade in Cloud hoch...', 'info');
        let successCount = 0;
        try {
          for (let i = 0; i < toAdd.length; i++) {
            const item = toAdd[i];
            let cloudData = null;
            let error = null;
            
            switch (pendingImportType) {
              case 'figuren':
                const figResult = await db.from('figures').insert({
                  project_id: currentCloudProjectId,
                  name: item.figur || item.name || '',
                  description: item.kurzbeschreibung || '',
                  sort_order: existingData.length + i,
                  color: '#3b82f6'
                }).select().single();
                cloudData = figResult.data;
                error = figResult.error;
                break;
                
              case 'szenen':
                const szResult = await db.from('scenes').insert({
                  project_id: currentCloudProjectId,
                  name: item.name || item.szene || '',
                  number: item.nummer || '',
                  description: item.beschreibung || '',
                  sort_order: existingData.length + i
                }).select().single();
                cloudData = szResult.data;
                error = szResult.error;
                break;
                
              case 'ensemble':
                const ensResult = await db.from('persons').insert({
                  project_id: currentCloudProjectId,
                  name: item.name,
                  category: 'ensemble',
                  function_title: item.funktion || 'Schauspiel',
                  email: item.email || '',
                  phone: item.telefon || '',
                  address_street: item.strasse || '',
                  address_number: item.hausnummer || '',
                  address_zip: item.plz || '',
                  address_city: item.ort || '',
                  address_country: item.land || 'Schweiz',
                  notes: item.bemerkungen || ''
                }).select().single();
                cloudData = ensResult.data;
                error = ensResult.error;
                break;
                
              case 'team':
                const teamResult = await db.from('persons').insert({
                  project_id: currentCloudProjectId,
                  name: item.name,
                  category: 'artistic_team',
                  function_title: item.funktion || '',
                  email: item.email || '',
                  phone: item.telefon || '',
                  address_street: item.strasse || '',
                  address_number: item.hausnummer || '',
                  address_zip: item.plz || '',
                  address_city: item.ort || '',
                  address_country: item.land || 'Schweiz',
                  notes: item.bemerkungen || ''
                }).select().single();
                cloudData = teamResult.data;
                error = teamResult.error;
                break;
                
              case 'probedaten':
                const probeResult = await db.from('rehearsals').insert({
                  project_id: currentCloudProjectId,
                  date: toISODate(item.datum),
                  start_time: item.anfangszeit || '10:00',
                  end_time: item.endzeit || '13:00',
                  location: item.ort || '',
                  notes: item.artDerProbe || item.anmerkungen || '',
                  rehearsal_type: 'regular'
                }).select().single();
                cloudData = probeResult.data;
                error = probeResult.error;
                break;
                
              case 'absenzen':
                // Find person ID
                const ensemble = load(KEYS.ensemble(state.projekt.id), []);
                const person = ensemble.find(e => e.name?.toLowerCase() === (item.schauspieler || '').toLowerCase());
                if (person?.id) {
                  const absResult = await db.from('person_absences').insert({
                    person_id: person.id,
                    date: toISODate(item.datum),
                    start_time: item.anfangszeit || null,
                    end_time: item.endzeit || null,
                    reason: item.bemerkungen || ''
                  }).select().single();
                  cloudData = absResult.data;
                  error = absResult.error;
                }
                break;
                
              case 'teamVerfuegbarkeit':
                // Find team person ID
                const teamMembers = load(KEYS.kuenstlerischesTeam(state.projekt.id), []);
                const teamPerson = teamMembers.find(t => t.name?.toLowerCase() === (item.teammitglied || '').toLowerCase());
                if (teamPerson?.id) {
                  const tvResult = await db.from('team_availability').insert({
                    project_id: currentCloudProjectId,
                    person_id: teamPerson.id,
                    date: toISODate(item.datum),
                    start_time: item.anfangszeit || null,
                    end_time: item.endzeit || null,
                    notes: item.bemerkungen || ''
                  }).select().single();
                  cloudData = tvResult.data;
                  error = tvResult.error;
                }
                break;
                
              case 'zuordnungen':
                // Find figure and person IDs from cloud
                const { data: cloudFigs } = await db.from('figures').select('id, name').eq('project_id', currentCloudProjectId);
                const { data: cloudPers } = await db.from('persons').select('id, name').eq('project_id', currentCloudProjectId).eq('category', 'ensemble');
                
                const fig = cloudFigs?.find(f => f.name?.toLowerCase() === (item.figur || '').toLowerCase());
                const pers = cloudPers?.find(p => p.name?.toLowerCase() === (item.schauspieler || '').toLowerCase());
                
                if (fig?.id && pers?.id) {
                  // Delete existing casting for this figure first
                  await db.from('castings').delete().eq('project_id', currentCloudProjectId).eq('figure_id', fig.id);
                  
                  const zuResult = await db.from('castings').insert({
                    project_id: currentCloudProjectId,
                    figure_id: fig.id,
                    person_id: pers.id,
                    casting_type: 'primary'
                  }).select().single();
                  cloudData = zuResult.data;
                  error = zuResult.error;
                }
                break;
            }
            
            // Update local ID with cloud ID
            if (cloudData && !error) {
              const idx = merged.findIndex(d => d.id === item.id);
              if (idx >= 0) { merged[idx].id = cloudData.id; }
              successCount++;
            }
            if (error) console.error('Cloud insert error:', error);
          }
          save(keyFn(state.projekt.id), merged);
          if (successCount > 0) {
            showToast(`‚úÖ ${successCount} Eintr√§ge in Cloud geladen!`, 'success');
          }
        } catch (e) { 
          console.error('Cloud import error:', e); 
          showToast('‚ö†Ô∏è Cloud-Sync teilweise fehlgeschlagen', 'error');
        }
      }
      
      alert(`‚úì ${toAdd.length} neue Eintr√§ge importiert!`); 
      pendingImportData = null; 
      pendingImportType = null; 
      closeModal(); 
      render(); 
    }
    function closeModal() { state.showImportModal = null; state.editingItem = null; state.editingType = null; pendingImportData = null; pendingImportType = null; render(); }
    function showImportModal(type) { state.showImportModal = type; render(); }
    function editItem(id, type) { const keyMap = { probedaten: KEYS.probedaten, ensemble: KEYS.ensemble, kuenstlerischesTeam: KEYS.kuenstlerischesTeam, teamVerfuegbarkeit: KEYS.teamVerfuegbarkeit, figuren: KEYS.figuren, zuordnungen: KEYS.zuordnungen, szenen: KEYS.szenen, absenzen: KEYS.absenzen }; const data = getData(keyMap[type]); const item = data.find(d => d.id === id); if (item) { if (item._readOnly) { alert('üîí Dieses Element wurde aus ' + (item._source || 'einer anderen App') + ' importiert und kann in Propla nicht bearbeitet werden.'); return; } state.editingItem = { ...item }; state.editingType = type; render(); } }
    async function saveEdit() { 
      if (!state.editingItem || !state.editingType) return; 
      const keyMap = { probedaten: KEYS.probedaten, ensemble: KEYS.ensemble, kuenstlerischesTeam: KEYS.kuenstlerischesTeam, teamVerfuegbarkeit: KEYS.teamVerfuegbarkeit, figuren: KEYS.figuren, zuordnungen: KEYS.zuordnungen, szenen: KEYS.szenen, absenzen: KEYS.absenzen }; 
      const data = getData(keyMap[state.editingType]); 
      const idx = data.findIndex(d => d.id === state.editingItem.id); 
      if (idx !== -1) { 
        document.querySelectorAll('[id^="edit_"]').forEach(el => { 
          const key = el.id.replace('edit_', ''); 
          data[idx][key] = el.value; 
        }); 
        if (state.editingType === 'probedaten' && data[idx].datum) { 
          data[idx].wochentag = getWochentag(data[idx].datum); 
        } 
        setData(keyMap[state.editingType], data); 
        
        // Cloud Sync - Update
        if (isCloudMode && currentCloudProjectId && data[idx].id) {
          try {
            const item = data[idx];
            switch (state.editingType) {
              case 'figuren':
                await db.from('figures').update({
                  name: item.figur || item.name || '',
                  description: item.kurzbeschreibung || ''
                }).eq('id', item.id);
                break;
              case 'szenen':
                await db.from('scenes').update({
                  name: item.name || item.szene || '',
                  number: item.nummer || '',
                  description: item.beschreibung || ''
                }).eq('id', item.id);
                break;
              case 'ensemble':
                await db.from('persons').update({
                  name: item.name,
                  function_title: item.funktion || 'Schauspiel',
                  email: item.email || '',
                  phone: item.telefon || '',
                  address_street: item.strasse || '',
                  address_number: item.hausnummer || '',
                  address_zip: item.plz || '',
                  address_city: item.ort || '',
                  address_country: item.land || 'Schweiz',
                  notes: item.bemerkungen || ''
                }).eq('id', item.id);
                break;
              case 'kuenstlerischesTeam':
                await db.from('persons').update({
                  name: item.name,
                  function_title: item.funktion || '',
                  email: item.email || '',
                  phone: item.telefon || '',
                  address_street: item.strasse || '',
                  address_number: item.hausnummer || '',
                  address_zip: item.plz || '',
                  address_city: item.ort || '',
                  address_country: item.land || 'Schweiz',
                  notes: item.bemerkungen || ''
                }).eq('id', item.id);
                break;
              case 'probedaten':
                await db.from('rehearsals').update({
                  date: toISODate(item.datum),
                  start_time: item.anfangszeit || '10:00',
                  end_time: item.endzeit || '13:00',
                  location: item.ort || '',
                  notes: item.artDerProbe || item.anmerkungen || ''
                }).eq('id', item.id);
                break;
              case 'absenzen':
                await db.from('person_absences').update({
                  date: toISODate(item.datum),
                  start_time: item.anfangszeit || null,
                  end_time: item.endzeit || null,
                  reason: item.bemerkungen || ''
                }).eq('id', item.id);
                break;
              case 'teamVerfuegbarkeit':
                await db.from('team_availability').update({
                  date: toISODate(item.datum),
                  start_time: item.anfangszeit || null,
                  end_time: item.endzeit || null,
                  notes: item.bemerkungen || ''
                }).eq('id', item.id);
                break;
            }
          } catch (e) { console.error('Cloud update error:', e); }
        }
      } 
      closeModal(); 
    }

    // ============================================
    // DASHBOARD (ohne Logo!)
    // ============================================
    function renderDashboard() {
      // Wenn kein Projekt, zeige Projekt-Auswahl
      if (!state.projekt) {
        return renderProjektAuswahl();
      }
      
      const probedaten = sortByDatum(getData(KEYS.probedaten));
      const ensemble = getData(KEYS.ensemble);
      const figuren = getData(KEYS.figuren);
      const szenen = getData(KEYS.szenen);
      const heute = new Date(); heute.setHours(0, 0, 0, 0);
      const naechsteProben = probedaten.filter(p => { const d = parseDatum(p.datum); return d && d >= heute; }).slice(0, 5);
      let premiereCountdown = null;
      if (state.projekt.premiere) { const days = daysUntil(state.projekt.premiere); if (days !== null && days >= 0) premiereCountdown = days; }
      
      return `
        <div class="fade-in">
          <div class="card p-6 mb-6 bg-gradient-to-r from-teal-600 to-teal-800 text-white">
            <div class="flex justify-between items-start">
              <div>
                <h2 class="text-2xl font-bold mb-1">${escapeHtml(state.projekt.name)}</h2>
                <div class="text-teal-200 text-sm">${state.projekt.regie ? `Regie: ${escapeHtml(state.projekt.regie)}` : ''}</div>
              </div>
              ${premiereCountdown !== null ? `<div class="text-right"><div class="text-4xl font-bold">${premiereCountdown}</div><div class="text-sm text-teal-200">Tage bis Premiere</div></div>` : ''}
            </div>
          </div>

          <div class="grid grid-cols-4 gap-4 mb-6">
            <div class="stat-card stat-card-teal"><div class="text-3xl font-bold">${probedaten.length}</div><div class="text-sm opacity-80">Probetermine</div></div>
            <div class="stat-card stat-card-green"><div class="text-3xl font-bold">${ensemble.length}</div><div class="text-sm opacity-80">Ensemble</div></div>
            <div class="stat-card stat-card-orange"><div class="text-3xl font-bold">${figuren.length}</div><div class="text-sm opacity-80">Figuren</div></div>
            <div class="stat-card stat-card-purple"><div class="text-3xl font-bold">${szenen.length}</div><div class="text-sm opacity-80">Szenen</div></div>
          </div>

          <div class="grid grid-cols-2 gap-6">
            <div class="card p-5">
              <div class="flex justify-between items-center mb-4">
                <h3 class="font-semibold text-gray-800">üìÖ N√§chste Proben</h3>
                <button onclick="navigate('probedaten')" class="btn btn-outline btn-sm">Alle</button>
              </div>
              ${naechsteProben.length === 0 ? `<div class="text-center text-gray-400 py-6"><div class="text-3xl mb-2">üìÖ</div><p>Keine Proben</p></div>` : `
                <div class="space-y-2">
                  ${naechsteProben.map(p => { 
                    const days = daysUntil(p.datum); 
                    const isToday = days === 0; 
                    return `<div class="flex items-center justify-between p-3 rounded-lg ${isToday ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'}"><div><div class="font-medium ${isToday ? 'text-blue-700' : ''}">${formatDatum(p.datum)}</div><div class="text-sm text-gray-500">${p.anfangszeit || ''} - ${p.endzeit || ''} ‚Ä¢ ${escapeHtml(p.artDerProbe || '')}</div></div>${isToday ? '<span class="tag tag-blue">Heute</span>' : days === 1 ? '<span class="tag tag-green">Morgen</span>' : `<span class="text-sm text-gray-400">in ${days} T.</span>`}</div>`; 
                  }).join('')}
                </div>
              `}
            </div>

            <div class="card p-5">
              <h3 class="font-semibold text-gray-800 mb-4">‚ö° Schnellzugriff</h3>
              <div class="grid grid-cols-2 gap-3">
                <button onclick="navigate('szenenvorschlag')" class="p-4 bg-yellow-50 rounded-lg hover:bg-yellow-100 transition text-left"><div class="text-2xl mb-1">üìã</div><div class="font-medium text-gray-800">Probeplan</div></button>
                <button onclick="navigate('absenzen')" class="p-4 bg-red-50 rounded-lg hover:bg-red-100 transition text-left"><div class="text-2xl mb-1">üö´</div><div class="font-medium text-gray-800">Absenzen</div></button>
                <button onclick="navigate('teamverfuegbarkeit')" class="p-4 bg-purple-50 rounded-lg hover:bg-purple-100 transition text-left"><div class="text-2xl mb-1">üìÜ</div><div class="font-medium text-gray-800">Team-Verf√ºgbarkeit</div></button>
                <button onclick="navigate('listen')" class="p-4 bg-green-50 rounded-lg hover:bg-green-100 transition text-left"><div class="text-2xl mb-1">üìã</div><div class="font-medium text-gray-800">Listen-Export</div></button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // ============================================
    // DATA PAGES
    // ============================================
    function renderProbedaten() {
      const data = sortByDatum(getData(KEYS.probedaten));
      return `<div class="fade-in"><div class="card p-4 mb-4"><div class="grid grid-cols-7 gap-3"><div><label class="input-label">Datum *</label><input type="date" id="probe_datum"></div><div><label class="input-label">Von</label><input type="time" id="probe_anfang" value="19:00"></div><div><label class="input-label">Bis</label><input type="time" id="probe_ende" value="22:00"></div><div><label class="input-label">Art der Probe</label><select id="probe_art"><option value="">--</option>${PROBENARTEN.map(a => `<option value="${a}">${a}</option>`).join('')}</select></div><div><label class="input-label">Ort</label><input type="text" id="probe_ort"></div><div><label class="input-label">Anmerkungen</label><input type="text" id="probe_anmerkungen"></div><div class="flex items-end"><button onclick="addProbe()" class="btn btn-primary w-full">‚ûï</button></div></div></div><div class="flex justify-between items-center mb-3"><span class="text-sm text-gray-500">${data.length} Probetermine</span><div class="flex gap-2"><button onclick="showImportModal('probedaten')" class="btn btn-outline btn-sm">üì• Import</button><button onclick="exportStyledExcel('probedaten')" class="btn btn-outline btn-sm">üì§ Export</button></div></div><div class="card"><div class="table-wrap"><table><thead><tr><th>Datum</th><th>Tag</th><th>Zeit</th><th>Art</th><th>Ort</th><th>Anmerkungen</th><th>Aktionen</th></tr></thead><tbody>${data.length === 0 ? '<tr><td colspan="7" class="text-center text-gray-400 py-8">Keine Probetermine</td></tr>' : data.map(row => `<tr><td class="font-medium">${formatDatum(row.datum)}</td><td><span class="tag tag-blue">${getWochentagKurz(row.datum)}</span></td><td>${row.anfangszeit || ''} - ${row.endzeit || ''}</td><td>${escapeHtml(row.artDerProbe || '')}</td><td>${escapeHtml(row.ort || '')}</td><td class="text-sm text-gray-500 max-w-xs truncate">${escapeHtml(row.anmerkungen || '')}</td><td><span class="edit-btn" onclick="editItem('${row.id}', 'probedaten')">‚úèÔ∏è</span><span class="delete-btn" onclick="deleteRow('${row.id}', 'probedaten')">üóëÔ∏è</span></td></tr>`).join('')}</tbody></table></div></div></div>`;
    }
    async function addProbe() { 
      const datum = document.getElementById('probe_datum')?.value; 
      if (!datum) return alert('Datum!'); 
      const newItem = { 
        id: genId(), 
        datum, 
        wochentag: getWochentag(datum), 
        anfangszeit: document.getElementById('probe_anfang')?.value || '', 
        endzeit: document.getElementById('probe_ende')?.value || '', 
        artDerProbe: document.getElementById('probe_art')?.value || '', 
        ort: document.getElementById('probe_ort')?.value || '', 
        anmerkungen: document.getElementById('probe_anmerkungen')?.value || '' 
      };
      const data = getData(KEYS.probedaten); 
      data.push(newItem); 
      setData(KEYS.probedaten, data); 
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          const { data: cloudData, error } = await db.from('rehearsals').insert({
            project_id: currentCloudProjectId,
            date: toISODate(datum),
            start_time: newItem.anfangszeit || '10:00',
            end_time: newItem.endzeit || '13:00',
            location: newItem.ort || '',
            notes: newItem.artDerProbe || '',
            rehearsal_type: 'regular'
          }).select().single();
          if (cloudData) {
            // Update local ID with cloud ID
            const idx = data.findIndex(d => d.id === newItem.id);
            if (idx >= 0) { data[idx].id = cloudData.id; setData(KEYS.probedaten, data); }
          }
          if (error) console.error('Cloud sync error:', error);
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      render(); 
    }

    function renderEnsemble() {
      const data = getData(KEYS.ensemble);
      return `<div class="fade-in"><div class="card p-4 mb-4"><div class="grid grid-cols-6 gap-3 mb-3"><div><label class="input-label">Name *</label><input type="text" id="ens_name"></div><div><label class="input-label">Funktion</label><input type="text" id="ens_funktion" value="Schauspiel"></div><div><label class="input-label">E-Mail</label><input type="email" id="ens_email"></div><div><label class="input-label">Telefon</label><input type="tel" id="ens_telefon"></div><div><label class="input-label">Bemerkungen</label><input type="text" id="ens_bemerkungen"></div><div class="flex items-end"><button onclick="toggleEnsembleAddress()" class="btn btn-outline btn-sm w-full">üìç Adresse</button></div></div><div id="ensembleAddressFields" class="hidden grid grid-cols-6 gap-3 mb-3 pt-3 border-t"><div><label class="input-label">Strasse</label><input type="text" id="ens_strasse"></div><div><label class="input-label">Nr.</label><input type="text" id="ens_hausnummer"></div><div><label class="input-label">PLZ</label><input type="text" id="ens_plz"></div><div><label class="input-label">Ort</label><input type="text" id="ens_ort_addr"></div><div><label class="input-label">Land</label><input type="text" id="ens_land" value="Schweiz"></div><div></div></div><button onclick="addEnsemble()" class="btn btn-primary">‚ûï Hinzuf√ºgen</button></div><div class="flex justify-between items-center mb-3"><span class="text-sm text-gray-500">${data.length} Ensemble-Mitglieder</span><div class="flex gap-2"><button onclick="showImportModal('ensemble')" class="btn btn-outline btn-sm">üì• Import</button><button onclick="exportStyledExcel('ensemble')" class="btn btn-outline btn-sm">üì§ Export</button></div></div><div class="card"><div class="table-wrap"><table><thead><tr><th>Name</th><th>Funktion</th><th>E-Mail</th><th>Telefon</th><th>Ort</th><th>Aktionen</th></tr></thead><tbody>${data.length === 0 ? '<tr><td colspan="6" class="text-center text-gray-400 py-8">Kein Ensemble</td></tr>' : data.map(row => `<tr><td class="font-medium">${escapeHtml(row.name)}</td><td>${escapeHtml(row.funktion || '')}</td><td class="text-sm">${escapeHtml(row.email || '')}</td><td class="text-sm">${escapeHtml(row.telefon || '')}</td><td class="text-sm">${row.plz ? `${row.plz} ${row.ort || ''}` : ''}</td><td><span class="edit-btn" onclick="editItem('${row.id}', 'ensemble')">‚úèÔ∏è</span><span class="delete-btn" onclick="deleteRow('${row.id}', 'ensemble')">üóëÔ∏è</span></td></tr>`).join('')}</tbody></table></div></div></div>`;
    }
    function toggleEnsembleAddress() { document.getElementById('ensembleAddressFields')?.classList.toggle('hidden'); }
    async function addEnsemble() { 
      const name = document.getElementById('ens_name')?.value?.trim(); 
      if (!name) return alert('Name!'); 
      const newItem = { 
        id: genId(), 
        name, 
        email: document.getElementById('ens_email')?.value || '', 
        telefon: document.getElementById('ens_telefon')?.value || '', 
        funktion: document.getElementById('ens_funktion')?.value || 'Schauspiel', 
        bemerkungen: document.getElementById('ens_bemerkungen')?.value || '', 
        strasse: document.getElementById('ens_strasse')?.value || '', 
        hausnummer: document.getElementById('ens_hausnummer')?.value || '', 
        plz: document.getElementById('ens_plz')?.value || '', 
        ort: document.getElementById('ens_ort_addr')?.value || '', 
        land: document.getElementById('ens_land')?.value || 'Schweiz' 
      };
      const data = getData(KEYS.ensemble); 
      data.push(newItem); 
      setData(KEYS.ensemble, data); 
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          const { data: cloudData, error } = await db.from('persons').insert({
            project_id: currentCloudProjectId,
            name: newItem.name,
            category: 'ensemble',
            function_title: newItem.funktion,
            email: newItem.email,
            phone: newItem.telefon,
            address_street: newItem.strasse,
            address_number: newItem.hausnummer,
            address_zip: newItem.plz,
            address_city: newItem.ort,
            address_country: newItem.land,
            notes: newItem.bemerkungen
          }).select().single();
          if (cloudData) {
            const idx = data.findIndex(d => d.id === newItem.id);
            if (idx >= 0) { data[idx].id = cloudData.id; setData(KEYS.ensemble, data); }
          }
          if (error) console.error('Cloud sync error:', error);
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      render(); 
    }

    function renderTeam() {
      const data = getData(KEYS.kuenstlerischesTeam);
      return `<div class="fade-in"><div class="card p-4 mb-4"><div class="grid grid-cols-6 gap-3 mb-3"><div><label class="input-label">Name *</label><input type="text" id="team_name"></div><div><label class="input-label">Funktion</label><select id="team_funktion"><option value="">--</option>${TEAM_FUNKTIONEN.map(f => `<option value="${f}">${f}</option>`).join('')}</select></div><div><label class="input-label">E-Mail</label><input type="email" id="team_email"></div><div><label class="input-label">Telefon</label><input type="tel" id="team_telefon"></div><div><label class="input-label">Bemerkungen</label><input type="text" id="team_bemerkungen"></div><div class="flex items-end"><button onclick="toggleTeamAddress()" class="btn btn-outline btn-sm w-full">üìç Adresse</button></div></div><div id="teamAddressFields" class="hidden grid grid-cols-6 gap-3 mb-3 pt-3 border-t"><div><label class="input-label">Strasse</label><input type="text" id="team_strasse"></div><div><label class="input-label">Nr.</label><input type="text" id="team_hausnummer"></div><div><label class="input-label">PLZ</label><input type="text" id="team_plz"></div><div><label class="input-label">Ort</label><input type="text" id="team_ort_addr"></div><div><label class="input-label">Land</label><input type="text" id="team_land" value="Schweiz"></div><div></div></div><button onclick="addTeam()" class="btn btn-primary">‚ûï Hinzuf√ºgen</button></div><div class="flex justify-between items-center mb-3"><span class="text-sm text-gray-500">${data.length} Team-Mitglieder</span><div class="flex gap-2"><button onclick="showImportModal('team')" class="btn btn-outline btn-sm">üì• Import</button><button onclick="exportStyledExcel('team')" class="btn btn-outline btn-sm">üì§ Export</button></div></div><div class="card"><div class="table-wrap"><table><thead><tr><th>Name</th><th>Funktion</th><th>E-Mail</th><th>Telefon</th><th>Ort</th><th>Aktionen</th></tr></thead><tbody>${data.length === 0 ? '<tr><td colspan="6" class="text-center text-gray-400 py-8">Kein Team</td></tr>' : data.map(row => `<tr><td class="font-medium">${escapeHtml(row.name)}</td><td><span class="tag tag-purple">${escapeHtml(row.funktion || '')}</span></td><td class="text-sm">${escapeHtml(row.email || '')}</td><td class="text-sm">${escapeHtml(row.telefon || '')}</td><td class="text-sm">${row.plz ? `${row.plz} ${row.ort || ''}` : ''}</td><td><span class="edit-btn" onclick="editItem('${row.id}', 'kuenstlerischesTeam')">‚úèÔ∏è</span><span class="delete-btn" onclick="deleteRow('${row.id}', 'kuenstlerischesTeam')">üóëÔ∏è</span></td></tr>`).join('')}</tbody></table></div></div></div>`;
    }
    function toggleTeamAddress() { document.getElementById('teamAddressFields')?.classList.toggle('hidden'); }
    async function addTeam() { 
      const name = document.getElementById('team_name')?.value?.trim(); 
      if (!name) return alert('Name!'); 
      const newItem = { 
        id: genId(), 
        name, 
        funktion: document.getElementById('team_funktion')?.value || '', 
        email: document.getElementById('team_email')?.value || '', 
        telefon: document.getElementById('team_telefon')?.value || '', 
        bemerkungen: document.getElementById('team_bemerkungen')?.value || '', 
        strasse: document.getElementById('team_strasse')?.value || '', 
        hausnummer: document.getElementById('team_hausnummer')?.value || '', 
        plz: document.getElementById('team_plz')?.value || '', 
        ort: document.getElementById('team_ort_addr')?.value || '', 
        land: document.getElementById('team_land')?.value || 'Schweiz' 
      };
      const data = getData(KEYS.kuenstlerischesTeam); 
      data.push(newItem); 
      setData(KEYS.kuenstlerischesTeam, data); 
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          const { data: cloudData, error } = await db.from('persons').insert({
            project_id: currentCloudProjectId,
            name: newItem.name,
            category: 'artistic_team',
            function_title: newItem.funktion,
            email: newItem.email,
            phone: newItem.telefon,
            address_street: newItem.strasse,
            address_number: newItem.hausnummer,
            address_zip: newItem.plz,
            address_city: newItem.ort,
            address_country: newItem.land,
            notes: newItem.bemerkungen
          }).select().single();
          if (cloudData) {
            const idx = data.findIndex(d => d.id === newItem.id);
            if (idx >= 0) { data[idx].id = cloudData.id; setData(KEYS.kuenstlerischesTeam, data); }
          }
          if (error) console.error('Cloud sync error:', error);
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      render(); 
    }

    function renderTeamVerfuegbarkeit() {
      const team = getData(KEYS.kuenstlerischesTeam);
      const data = sortByDatum(getData(KEYS.teamVerfuegbarkeit));
      return `<div class="fade-in"><div class="card p-4 mb-4"><h3 class="font-semibold mb-3">Team-Verf√ºgbarkeit eintragen</h3><p class="text-sm text-gray-500 mb-4">Wann kann das k√ºnstlerische Team anwesend sein?</p><div class="grid grid-cols-6 gap-3"><div><label class="input-label">Teammitglied *</label><select id="tv_person"><option value="">-- w√§hlen --</option>${team.map(t => `<option value="${t.name}">${t.name} (${t.funktion || ''})</option>`).join('')}</select></div><div><label class="input-label">Datum *</label><input type="date" id="tv_datum"></div><div><label class="input-label">Von</label><input type="time" id="tv_anfang"></div><div><label class="input-label">Bis</label><input type="time" id="tv_ende"></div><div><label class="input-label">Bemerkungen</label><input type="text" id="tv_bemerkungen"></div><div class="flex items-end"><button onclick="addTeamVerfuegbarkeit()" class="btn btn-success w-full">‚úì Speichern</button></div></div></div><div class="flex justify-between items-center mb-3"><span class="text-sm text-gray-500">${data.length} Eintr√§ge</span><div class="flex gap-2"><button onclick="showImportModal('teamVerfuegbarkeit')" class="btn btn-outline btn-sm">üì• Import</button><button onclick="exportStyledExcel('teamVerfuegbarkeit')" class="btn btn-outline btn-sm">üì§ Export</button></div></div><div class="card"><div class="table-wrap"><table><thead><tr><th>Teammitglied</th><th>Datum ‚Üë</th><th>Von</th><th>Bis</th><th>Bemerkungen</th><th>Aktionen</th></tr></thead><tbody>${data.length === 0 ? '<tr><td colspan="6" class="text-center text-gray-400 py-8">Keine Verf√ºgbarkeiten</td></tr>' : data.map(row => `<tr><td class="font-medium">${escapeHtml(row.teammitglied || '')}</td><td>${formatDatum(row.datum)}</td><td>${escapeHtml(row.anfangszeit || '')}</td><td>${escapeHtml(row.endzeit || '')}</td><td class="text-sm text-gray-500">${escapeHtml(row.bemerkungen || '')}</td><td><span class="edit-btn" onclick="editItem('${row.id}', 'teamVerfuegbarkeit')">‚úèÔ∏è</span><span class="delete-btn" onclick="deleteRow('${row.id}', 'teamVerfuegbarkeit')">üóëÔ∏è</span></td></tr>`).join('')}</tbody></table></div></div></div>`;
    }
    async function addTeamVerfuegbarkeit() { 
      const teammitglied = document.getElementById('tv_person')?.value; 
      const datum = document.getElementById('tv_datum')?.value; 
      if (!teammitglied || !datum) return alert('Teammitglied und Datum!'); 
      const newItem = { 
        id: genId(), 
        teammitglied, 
        datum, 
        anfangszeit: document.getElementById('tv_anfang')?.value || '', 
        endzeit: document.getElementById('tv_ende')?.value || '', 
        bemerkungen: document.getElementById('tv_bemerkungen')?.value || '' 
      };
      const data = getData(KEYS.teamVerfuegbarkeit); 
      data.push(newItem); 
      setData(KEYS.teamVerfuegbarkeit, data); 
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          // Find team member ID
          const team = getData(KEYS.kuenstlerischesTeam);
          const person = team.find(t => t.name === teammitglied);
          if (person?.id) {
            const { data: cloudData, error } = await db.from('team_availability').insert({
              project_id: currentCloudProjectId,
              person_id: person.id,
              date: toISODate(datum),
              start_time: newItem.anfangszeit || null,
              end_time: newItem.endzeit || null,
              notes: newItem.bemerkungen || ''
            }).select().single();
            if (cloudData) {
              const idx = data.findIndex(d => d.id === newItem.id);
              if (idx >= 0) { data[idx].id = cloudData.id; setData(KEYS.teamVerfuegbarkeit, data); }
            }
            if (error) console.error('Cloud sync error:', error);
          }
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      render(); 
    }

    function renderFiguren() {
      const data = getData(KEYS.figuren);
      const hasReadOnly = data.some(f => f._readOnly);
      return `<div class="fade-in"><div class="card p-4 mb-4"><div class="grid grid-cols-4 gap-3"><div><label class="input-label">Figur *</label><input type="text" id="fig_name"></div><div class="col-span-2"><label class="input-label">Kurzbeschreibung</label><input type="text" id="fig_beschreibung"></div><div class="flex items-end"><button onclick="addFigur()" class="btn btn-primary w-full">‚ûï</button></div></div></div>${hasReadOnly ? '<div class="text-xs text-amber-600 mb-2">üîí = importiert aus Rebu/Werkbank (read-only in Propla)</div>' : ''}<div class="flex justify-between items-center mb-3"><span class="text-sm text-gray-500">${data.length} Figuren</span><div class="flex gap-2"><button onclick="showImportModal('figuren')" class="btn btn-outline btn-sm">üì• Import</button><button onclick="exportStyledExcel('figuren')" class="btn btn-outline btn-sm">üì§ Export</button></div></div><div class="card"><div class="table-wrap"><table><thead><tr><th>Figur</th><th>Kurzbeschreibung</th><th>Aktionen</th></tr></thead><tbody>${data.length === 0 ? '<tr><td colspan="3" class="text-center text-gray-400 py-8">Keine Figuren</td></tr>' : data.map(row => `<tr${row._readOnly ? ' style="background:#fffbeb;"' : ''}><td class="font-bold text-blue-800">${row._readOnly ? 'üîí ' : ''}${escapeHtml(row.figur || row.name || '')}${row._source && row._source !== 'propla' ? ` <span style="font-size:10px;color:#92400e;background:#fef3c7;padding:1px 5px;border-radius:3px;">${row._source}</span>` : ''}</td><td class="text-sm text-gray-600">${escapeHtml(row.kurzbeschreibung || '')}</td><td>${row._readOnly ? '<span class="text-xs text-gray-400">gesch√ºtzt</span>' : `<span class="edit-btn" onclick="editItem('${row.id}', 'figuren')">‚úèÔ∏è</span><span class="delete-btn" onclick="deleteRow('${row.id}', 'figuren')">üóëÔ∏è</span>`}</td></tr>`).join('')}</tbody></table></div></div></div>`;
    }
    async function addFigur() { 
      const name = document.getElementById('fig_name')?.value?.trim(); 
      if (!name) return alert('Name!'); 
      const newItem = { 
        id: genId(), 
        figur: name, 
        kurzbeschreibung: document.getElementById('fig_beschreibung')?.value || '' 
      };
      const data = getData(KEYS.figuren); 
      data.push(newItem); 
      setData(KEYS.figuren, data); 
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          const { data: cloudData, error } = await db.from('figures').insert({
            project_id: currentCloudProjectId,
            name: newItem.figur,
            description: newItem.kurzbeschreibung,
            sort_order: data.length - 1,
            color: '#3b82f6'
          }).select().single();
          if (cloudData) {
            const idx = data.findIndex(d => d.id === newItem.id);
            if (idx >= 0) { data[idx].id = cloudData.id; setData(KEYS.figuren, data); }
          }
          if (error) console.error('Cloud sync error:', error);
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      render(); 
    }

    function renderZuordnung() {
      const figuren = getData(KEYS.figuren);
      const ensemble = getData(KEYS.ensemble);
      const data = getData(KEYS.zuordnungen);
      return `<div class="fade-in"><div class="card p-4 mb-4"><div class="grid grid-cols-3 gap-3"><div><label class="input-label">Figur</label><select id="zu_figur"><option value="">--</option>${figuren.map(f => `<option value="${f.figur || f.name}">${f.figur || f.name}</option>`).join('')}</select></div><div><label class="input-label">Schauspieler:in</label><select id="zu_schauspieler"><option value="">--</option>${ensemble.map(e => `<option value="${e.name}">${e.name}</option>`).join('')}</select></div><div class="flex items-end"><button onclick="addZuordnung()" class="btn btn-primary w-full">‚ûï Zuordnen</button></div></div></div><div class="flex justify-between items-center mb-3"><span class="text-sm text-gray-500">${data.length} Zuordnungen</span><div class="flex gap-2"><button onclick="showImportModal('zuordnungen')" class="btn btn-outline btn-sm">üì• Import</button><button onclick="exportStyledExcel('zuordnungen')" class="btn btn-outline btn-sm">üì§ Export</button></div></div><div class="card"><div class="table-wrap"><table><thead><tr><th>Figur</th><th>Schauspieler:in</th><th>Aktionen</th></tr></thead><tbody>${data.length === 0 ? '<tr><td colspan="3" class="text-center text-gray-400 py-8">Keine Zuordnungen</td></tr>' : data.map(row => `<tr><td class="font-bold text-blue-800">${escapeHtml(row.figur || '')}</td><td>${escapeHtml(row.schauspieler || '')}</td><td><span class="edit-btn" onclick="editItem('${row.id}', 'zuordnungen')">‚úèÔ∏è</span><span class="delete-btn" onclick="deleteRow('${row.id}', 'zuordnungen')">üóëÔ∏è</span></td></tr>`).join('')}</tbody></table></div></div></div>`;
    }
    async function addZuordnung() { 
      const figur = document.getElementById('zu_figur')?.value; 
      const schauspieler = document.getElementById('zu_schauspieler')?.value; 
      if (!figur || !schauspieler) return alert('Beides!'); 
      
      // Remove existing assignment for this figure
      let data = getData(KEYS.zuordnungen).filter(z => z.figur !== figur); 
      const newItem = { id: genId(), figur, schauspieler };
      data.push(newItem); 
      setData(KEYS.zuordnungen, data); 
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          // Find figure and person IDs
          const figuren = getData(KEYS.figuren);
          const ensemble = getData(KEYS.ensemble);
          const figurObj = figuren.find(f => (f.figur || f.name) === figur);
          const personObj = ensemble.find(e => e.name === schauspieler);
          
          if (figurObj?.id && personObj?.id) {
            // Delete existing casting for this figure
            await db.from('castings').delete().eq('project_id', currentCloudProjectId).eq('figure_id', figurObj.id);
            
            // Insert new casting
            const { data: cloudData, error } = await db.from('castings').insert({
              project_id: currentCloudProjectId,
              figure_id: figurObj.id,
              person_id: personObj.id,
              casting_type: 'primary'
            }).select().single();
            if (cloudData) {
              const idx = data.findIndex(d => d.id === newItem.id);
              if (idx >= 0) { data[idx].id = cloudData.id; setData(KEYS.zuordnungen, data); }
            }
            if (error) console.error('Cloud sync error:', error);
          }
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      render(); 
    }

    function renderSzenen() {
      const data = getData(KEYS.szenen);
      const hasReadOnly = data.some(s => s._readOnly);
      return `<div class="fade-in"><div class="card p-4 mb-4"><div class="grid grid-cols-6 gap-3"><div><label class="input-label">Nr.</label><input type="text" id="sz_nummer" placeholder="1.1"></div><div class="col-span-2"><label class="input-label">Szene *</label><input type="text" id="sz_name"></div><div><label class="input-label">Hauptfiguren</label><input type="text" id="sz_haupt"></div><div><label class="input-label">Nebenfiguren</label><input type="text" id="sz_neben"></div><div class="flex items-end"><button onclick="addSzene()" class="btn btn-primary w-full">‚ûï</button></div></div><div class="mt-3"><label class="input-label">Beschreibung</label><input type="text" id="sz_beschreibung"></div></div>${hasReadOnly ? '<div class="text-xs text-amber-600 mb-2">üîí = importiert aus Rebu/Werkbank (read-only in Propla)</div>' : ''}<div class="flex justify-between items-center mb-3"><span class="text-sm text-gray-500">${data.length} Szenen</span><div class="flex gap-2"><button onclick="showImportModal('szenen')" class="btn btn-outline btn-sm">üì• Import</button><button onclick="exportStyledExcel('szenen')" class="btn btn-outline btn-sm">üì§ Export</button></div></div><div class="card"><div class="table-wrap"><table><thead><tr><th style="width:60px">Nr.</th><th>Szene</th><th>Beschreibung</th><th>Hauptfiguren</th><th>Nebenfiguren</th><th>Aktionen</th></tr></thead><tbody>${data.length === 0 ? '<tr><td colspan="6" class="text-center text-gray-400 py-8">Keine Szenen</td></tr>' : data.map(row => `<tr${row._readOnly ? ' style="background:#fffbeb;"' : ''}><td>${escapeHtml(row.nummer || '')}</td><td class="font-medium">${row._readOnly ? 'üîí ' : ''}${escapeHtml(row.name || row.szene || '')}${row._source && row._source !== 'propla' ? ` <span style="font-size:10px;color:#92400e;background:#fef3c7;padding:1px 5px;border-radius:3px;">${row._source}</span>` : ''}</td><td class="text-sm text-gray-500 max-w-xs truncate">${escapeHtml(row.beschreibung || '')}</td><td class="text-xs">${escapeHtml(row.hauptfiguren || '')}</td><td class="text-xs text-gray-400">${escapeHtml(row.nebenfiguren || '')}</td><td>${row._readOnly ? '<span class="text-xs text-gray-400">gesch√ºtzt</span>' : `<span class="edit-btn" onclick="editItem('${row.id}', 'szenen')">‚úèÔ∏è</span><span class="delete-btn" onclick="deleteRow('${row.id}', 'szenen')">üóëÔ∏è</span>`}</td></tr>`).join('')}</tbody></table></div></div></div>`;
    }
    async function addSzene() { 
      const name = document.getElementById('sz_name')?.value?.trim(); 
      if (!name) return alert('Name!'); 
      const newItem = { 
        id: genId(), 
        nummer: document.getElementById('sz_nummer')?.value || '', 
        name, 
        szene: name, 
        beschreibung: document.getElementById('sz_beschreibung')?.value || '', 
        hauptfiguren: document.getElementById('sz_haupt')?.value || '', 
        nebenfiguren: document.getElementById('sz_neben')?.value || '' 
      };
      const data = getData(KEYS.szenen); 
      data.push(newItem); 
      setData(KEYS.szenen, data); 
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          const { data: cloudData, error } = await db.from('scenes').insert({
            project_id: currentCloudProjectId,
            name: newItem.name,
            number: newItem.nummer,
            description: newItem.beschreibung,
            sort_order: data.length - 1
          }).select().single();
          if (cloudData) {
            const idx = data.findIndex(d => d.id === newItem.id);
            if (idx >= 0) { data[idx].id = cloudData.id; setData(KEYS.szenen, data); }
          }
          if (error) console.error('Cloud sync error:', error);
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      render(); 
    }

    function renderAbsenzen() {
      const data = sortByDatum(getData(KEYS.absenzen));
      const ensemble = getData(KEYS.ensemble);
      return `<div class="fade-in"><div class="card p-4 mb-4"><div class="grid grid-cols-6 gap-3"><div><label class="input-label">Person *</label><select id="abs_person"><option value="">--</option>${ensemble.map(e => `<option value="${e.name}">${e.name}</option>`).join('')}</select></div><div><label class="input-label">Datum *</label><input type="date" id="abs_datum"></div><div><label class="input-label">Von</label><input type="time" id="abs_anfang"></div><div><label class="input-label">Bis</label><input type="time" id="abs_ende"></div><div><label class="input-label">Bemerkungen</label><input type="text" id="abs_bemerkungen"></div><div class="flex items-end"><button onclick="addAbsenz()" class="btn btn-danger w-full">üö´ Eintragen</button></div></div></div><div class="flex justify-between items-center mb-3"><span class="text-sm text-gray-500">${data.length} Absenzen</span><div class="flex gap-2"><button onclick="showImportModal('absenzen')" class="btn btn-outline btn-sm">üì• Import</button><button onclick="exportStyledExcel('absenzen')" class="btn btn-outline btn-sm">üì§ Export</button></div></div><div class="card"><div class="table-wrap"><table><thead><tr><th>Person</th><th>Datum</th><th>Tag</th><th>Zeit</th><th>Bemerkungen</th><th>Aktionen</th></tr></thead><tbody>${data.length === 0 ? '<tr><td colspan="6" class="text-center text-gray-400 py-8">Keine Absenzen</td></tr>' : data.map(row => `<tr><td class="font-medium">${escapeHtml(row.schauspieler || '')}</td><td>${formatDatum(row.datum)}</td><td><span class="tag tag-red">${getWochentagKurz(row.datum)}</span></td><td>${row.anfangszeit && row.endzeit ? `${row.anfangszeit} - ${row.endzeit}` : 'Ganztags'}</td><td class="text-sm text-gray-500">${escapeHtml(row.bemerkungen || '')}</td><td><span class="edit-btn" onclick="editItem('${row.id}', 'absenzen')">‚úèÔ∏è</span><span class="delete-btn" onclick="deleteRow('${row.id}', 'absenzen')">üóëÔ∏è</span></td></tr>`).join('')}</tbody></table></div></div></div>`;
    }
    async function addAbsenz() { 
      const schauspieler = document.getElementById('abs_person')?.value; 
      const datum = document.getElementById('abs_datum')?.value; 
      if (!schauspieler || !datum) return alert('Person und Datum!'); 
      const newItem = { 
        id: genId(), 
        schauspieler, 
        datum, 
        anfangszeit: document.getElementById('abs_anfang')?.value || '', 
        endzeit: document.getElementById('abs_ende')?.value || '', 
        bemerkungen: document.getElementById('abs_bemerkungen')?.value || '' 
      };
      const data = getData(KEYS.absenzen); 
      data.push(newItem); 
      setData(KEYS.absenzen, data); 
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          // Find person ID in cloud
          const ensemble = getData(KEYS.ensemble);
          const person = ensemble.find(e => e.name === schauspieler);
          if (person && person.id) {
            const { data: cloudData, error } = await db.from('person_absences').insert({
              person_id: person.id,
              date: toISODate(datum),
              start_time: newItem.anfangszeit || null,
              end_time: newItem.endzeit || null,
              reason: newItem.bemerkungen
            }).select().single();
            if (cloudData) {
              const idx = data.findIndex(d => d.id === newItem.id);
              if (idx >= 0) { data[idx].id = cloudData.id; setData(KEYS.absenzen, data); }
            }
            if (error) console.error('Cloud sync error:', error);
          }
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      render(); 
    }

    // ============================================
    // PROBEPLAN (ehemals Szenenvorschlag)
    // ============================================
    function renderSzenenvorschlag() {
      const probedaten = sortByDatum(getData(KEYS.probedaten));
      const szenen = getData(KEYS.szenen);
      const zuordnungen = getData(KEYS.zuordnungen);
      const absenzen = getData(KEYS.absenzen);
      const teamVerfuegbarkeit = getData(KEYS.teamVerfuegbarkeit);
      const team = getData(KEYS.kuenstlerischesTeam);
      const probenplanung = getData(KEYS.probenplanung);
      const heute = new Date(); heute.setHours(0, 0, 0, 0);
      const zukunftigeProben = probedaten.filter(p => { const d = parseDatum(p.datum); return d && d >= heute; });
      
      // Szenen-Status f√ºr aktuell gew√§hlte Probe
      let szenenStatus = [], selectedProbeInfo = null, verfuegbaresTeam = [];
      const currentProbeSzenen = getProbenplanungForProbe(state.selectedProbe);
      
      if (state.selectedProbe) {
        const probe = probedaten.find(p => String(p.id) === String(state.selectedProbe));
        if (probe) {
          selectedProbeInfo = probe;
          const probeDatum = toISODate(probe.datum);
          verfuegbaresTeam = teamVerfuegbarkeit.filter(tv => { 
            if (toISODate(tv.datum) !== probeDatum) return false; 
            if (probe.anfangszeit && probe.endzeit && tv.anfangszeit && tv.endzeit) { 
              return timeOverlaps(probe.anfangszeit, probe.endzeit, tv.anfangszeit, tv.endzeit); 
            } 
            return true; 
          }).map(tv => { 
            const teamMember = team.find(t => t.name === tv.teammitglied); 
            return { ...tv, funktion: teamMember?.funktion || '' }; 
          });
          const abwesende = absenzen.filter(a => toISODate(a.datum) === probeDatum).map(a => a.schauspieler);
          szenenStatus = szenen.map(s => { 
            const alleFiguren = [...(s.hauptfiguren || '').split(','), ...(s.nebenfiguren || '').split(',')].map(f => f.trim()).filter(f => f); 
            const schauspieler = alleFiguren.map(f => { 
              const z = zuordnungen.find(z => (z.figur || '').toLowerCase() === f.toLowerCase()); 
              return z?.schauspieler; 
            }).filter(s => s); 
            const fehlend = schauspieler.filter(s => abwesende.includes(s)); 
            let status = 'gruen'; 
            if (fehlend.length > 0) status = fehlend.length === schauspieler.length && schauspieler.length > 0 ? 'rot' : 'orange'; 
            const istGeplant = currentProbeSzenen.includes(s.id); 
            return { ...s, status, fehlend, alleFiguren, schauspieler, istGeplant }; 
          });
        }
      }
      
      // GESAMTER Probeplan: Alle Proben mit Szenen sammeln
      const gesamtPlan = [];
      probenplanung.forEach(pl => {
        if (pl.szenen && pl.szenen.length > 0) {
          const probe = probedaten.find(p => String(p.id) === String(pl.probeId));
          if (probe) {
            gesamtPlan.push({
              probe: probe,
              szenen: pl.szenen.map(szId => szenen.find(s => s.id === szId)).filter(s => s)
            });
          }
        }
      });
      // Sortiere nach Datum
      gesamtPlan.sort((a, b) => toISODate(a.probe.datum).localeCompare(toISODate(b.probe.datum)));
      
      // Beteiligte f√ºr eine Szene ermitteln
      const getBeteiligte = (sz) => {
        const figuren = [...(sz.hauptfiguren || '').split(','), ...(sz.nebenfiguren || '').split(',')].map(f => f.trim()).filter(f => f);
        return figuren.map(f => { 
          const z = zuordnungen.find(zu => (zu.figur || '').toLowerCase() === f.toLowerCase()); 
          return z?.schauspieler; 
        }).filter(s => s);
      };
      
      return `
        <div class="fade-in">
          <div class="grid grid-cols-3 gap-6">
            <!-- LINKE SPALTE: Probetermin w√§hlen -->
            <div class="card p-5">
              <h3 class="font-semibold text-gray-800 mb-4">üìÖ Probetermin w√§hlen</h3>
              ${zukunftigeProben.length === 0 ? `
                <div class="text-center text-gray-400 py-8">
                  <div class="text-4xl mb-2">üìÖ</div>
                  <p>Keine Proben</p>
                </div>
              ` : `
                <select onchange="selectProbe(this.value)" class="mb-4">
                  <option value="">-- Probe w√§hlen --</option>
                  ${zukunftigeProben.map(p => `
                    <option value="${p.id}" ${String(state.selectedProbe) === String(p.id) ? 'selected' : ''}>
                      ${formatDatumKurz(p.datum)} (${getWochentagKurz(p.datum)}) ${p.anfangszeit || ''} ‚Äì ${escapeHtml(p.artDerProbe || '')}
                    </option>
                  `).join('')}
                </select>
                ${selectedProbeInfo ? `
                  <div class="bg-teal-50 border border-teal-200 rounded-lg p-4 mb-4">
                    <div class="font-semibold text-teal-800">${formatDatum(selectedProbeInfo.datum)}</div>
                    <div class="text-sm text-teal-600">
                      ${selectedProbeInfo.anfangszeit || ''} - ${selectedProbeInfo.endzeit || ''}<br>
                      ${escapeHtml(selectedProbeInfo.artDerProbe || '')}
                    </div>
                  </div>
                  ${(() => { 
                    const abwesendeHeute = absenzen.filter(a => toISODate(a.datum) === toISODate(selectedProbeInfo.datum)).map(a => a.schauspieler); 
                    return abwesendeHeute.length > 0 ? `
                      <div class="bg-red-50 border border-red-200 rounded-lg p-3 mb-3">
                        <div class="text-sm font-medium text-red-800 mb-1">üö´ Abwesend:</div>
                        <div class="text-sm text-red-700">${abwesendeHeute.join(', ')}</div>
                      </div>
                    ` : `
                      <div class="bg-green-50 border border-green-200 rounded-lg p-3 mb-3">
                        <div class="text-sm text-green-700">‚úì Alle anwesend</div>
                      </div>
                    `; 
                  })()}
                  <div class="bg-purple-50 border border-purple-200 rounded-lg p-3">
                    <div class="text-sm font-medium text-purple-800 mb-1">üìÜ Team verf√ºgbar:</div>
                    ${verfuegbaresTeam.length > 0 ? `
                      <div class="text-sm text-purple-700">
                        ${verfuegbaresTeam.map(tv => `<div>‚Ä¢ ${tv.teammitglied}${tv.funktion ? ` (${tv.funktion})` : ''}</div>`).join('')}
                      </div>
                    ` : `
                      <div class="text-sm text-purple-600 italic">Keine Eintr√§ge</div>
                    `}
                  </div>
                ` : ''}
              `}
            </div>
            
            <!-- MITTLERE SPALTE: Verf√ºgbare Szenen -->
            <div class="card p-5">
              <h3 class="font-semibold text-gray-800 mb-4">üí° Verf√ºgbare Szenen</h3>
              ${!state.selectedProbe ? `
                <div class="text-center text-gray-400 py-8">
                  <div class="text-4xl mb-2">üëà</div>
                  <p>Probe w√§hlen</p>
                </div>
              ` : szenen.length === 0 ? `
                <div class="text-center text-gray-400 py-8">
                  <div class="text-4xl mb-2">üìë</div>
                  <p>Keine Szenen</p>
                </div>
              ` : `
                <div class="flex gap-2 mb-3 text-xs">
                  <div class="flex items-center gap-1"><div class="w-3 h-3 rounded bg-green-200 border border-green-400"></div>Probbar</div>
                  <div class="flex items-center gap-1"><div class="w-3 h-3 rounded bg-yellow-200 border border-yellow-400"></div>Eingeschr√§nkt</div>
                  <div class="flex items-center gap-1"><div class="w-3 h-3 rounded bg-red-200 border border-red-400"></div>Nicht probbar</div>
                </div>
                <div class="space-y-2 max-h-96 overflow-y-auto">
                  ${szenenStatus.map(s => `
                    <div class="szene-item szene-${s.status} ${s.istGeplant ? 'selected-for-probe' : ''}" onclick="toggleSzeneForProbe('${s.id}')">
                      <div class="flex justify-between items-start">
                        <div class="flex-1">
                          <div class="font-medium text-sm">${s.nummer ? `${escapeHtml(s.nummer)} ‚Äì ` : ''}${escapeHtml(s.name || s.szene || '')}</div>
                          <div class="text-xs text-gray-500 mt-1">${s.alleFiguren.length > 0 ? s.alleFiguren.slice(0, 4).join(', ') + (s.alleFiguren.length > 4 ? '...' : '') : '<em>keine Figuren</em>'}</div>
                        </div>
                        <div class="flex items-center gap-2">
                          ${s.istGeplant ? '<span class="text-teal-600 font-bold">‚úì</span>' : ''}
                          ${s.status === 'gruen' ? '<span class="tag tag-green text-xs">‚úì</span>' : s.status === 'orange' ? '<span class="tag tag-orange text-xs">‚ö†Ô∏è</span>' : '<span class="tag tag-red text-xs">‚úï</span>'}
                        </div>
                      </div>
                      ${s.fehlend.length > 0 ? `<div class="text-xs text-red-600 mt-1">Fehlt: ${s.fehlend.join(', ')}</div>` : ''}
                    </div>
                  `).join('')}
                </div>
              `}
            </div>
            
            <!-- RECHTE SPALTE: GESAMTER Probeplan -->
            <div class="card p-5">
              <h3 class="font-semibold text-gray-800 mb-4">üìã Probeplan</h3>
              ${gesamtPlan.length === 0 ? `
                <div class="text-center text-gray-400 py-8">
                  <div class="text-4xl mb-2">üëÜ</div>
                  <p>Szenen ausw√§hlen um<br>den Probeplan zu erstellen</p>
                </div>
              ` : `
                <div class="space-y-4 max-h-96 overflow-y-auto mb-4">
                  ${gesamtPlan.map(item => `
                    <div class="border-b border-gray-200 pb-3">
                      <div class="font-semibold text-sm text-teal-800 mb-2">
                        ${getWochentagKurz(item.probe.datum)}, ${formatDatumKurz(item.probe.datum)} 
                        <span class="font-normal text-gray-500">${item.probe.anfangszeit || ''} - ${item.probe.endzeit || ''}</span>
                      </div>
                      <div class="space-y-1">
                        ${item.szenen.map(sz => {
                          const beteiligte = getBeteiligte(sz);
                          return `
                            <div class="flex items-start justify-between text-sm bg-gray-50 rounded p-2">
                              <div class="flex-1">
                                <div class="font-medium">${sz.nummer ? sz.nummer + ': ' : ''}${escapeHtml(sz.name || sz.szene || '')}</div>
                                <div class="text-xs text-gray-500">${beteiligte.length > 0 ? beteiligte.join(', ') : 'Alle'}</div>
                              </div>
                              <button onclick="event.stopPropagation(); removeSzeneFromProbeById('${item.probe.id}', '${sz.id}')" class="text-red-400 hover:text-red-600 ml-2">‚úï</button>
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `).join('')}
                </div>
                <div class="flex gap-2 mb-3">
                  <button onclick="clearGesamtPlan()" class="btn btn-outline btn-sm flex-1">üóëÔ∏è Plan leeren</button>
                  <button onclick="exportProbenplanFormatted()" class="btn btn-success btn-sm flex-1">üì§ Exportieren</button>
                </div>
                <div class="pt-3 border-t">
                  <div class="text-xs text-gray-500 mb-1">Zusammenfassung:</div>
                  <div class="text-sm">
                    <strong>${gesamtPlan.length}</strong> Probetermine, 
                    <strong>${gesamtPlan.reduce((sum, item) => sum + item.szenen.length, 0)}</strong> Szenen
                  </div>
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }

    function selectProbe(probeId) { 
      state.selectedProbe = probeId ? String(probeId) : null; 
      render(); 
    }
    
    function getProbenplanungForProbe(probeId) {
      if (!probeId) return [];
      const probenplanung = getData(KEYS.probenplanung);
      const planung = probenplanung.find(p => String(p.probeId) === String(probeId));
      return planung?.szenen || [];
    }
    
    async function saveProbenplanungForProbe(probeId, szenen, addedSzeneId = null, removedSzeneId = null) {
      if (!probeId) return;
      const probenplanung = getData(KEYS.probenplanung);
      const idx = probenplanung.findIndex(p => String(p.probeId) === String(probeId));
      if (idx !== -1) {
        if (szenen.length === 0) {
          // Entferne leere Eintr√§ge
          probenplanung.splice(idx, 1);
        } else {
          probenplanung[idx].szenen = szenen;
        }
      } else if (szenen.length > 0) {
        probenplanung.push({ id: genId(), probeId: String(probeId), szenen: szenen });
      }
      setData(KEYS.probenplanung, probenplanung);
      
      // Cloud Sync
      if (isCloudMode && currentCloudProjectId) {
        try {
          if (addedSzeneId) {
            // Szene zur Probe hinzugef√ºgt
            await db.from('rehearsal_scenes').insert({
              project_id: currentCloudProjectId,
              rehearsal_id: probeId,
              scene_id: addedSzeneId
            });
          }
          if (removedSzeneId) {
            // Szene von Probe entfernt
            await db.from('rehearsal_scenes')
              .delete()
              .eq('project_id', currentCloudProjectId)
              .eq('rehearsal_id', probeId)
              .eq('scene_id', removedSzeneId);
          }
        } catch (e) { console.error('Cloud sync error (probenplanung):', e); }
      }
    }
    
    async function toggleSzeneForProbe(szeneId) { 
      if (!state.selectedProbe) return; 
      const currentSzenen = getProbenplanungForProbe(state.selectedProbe);
      const idx = currentSzenen.indexOf(szeneId);
      let addedSzeneId = null, removedSzeneId = null;
      if (idx === -1) {
        currentSzenen.push(szeneId);
        addedSzeneId = szeneId;
      } else {
        currentSzenen.splice(idx, 1);
        removedSzeneId = szeneId;
      }
      await saveProbenplanungForProbe(state.selectedProbe, currentSzenen, addedSzeneId, removedSzeneId);
      render(); 
    }
    
    async function removeSzeneFromProbeById(probeId, szeneId) {
      const currentSzenen = getProbenplanungForProbe(probeId);
      const filtered = currentSzenen.filter(id => id !== szeneId);
      await saveProbenplanungForProbe(probeId, filtered, null, szeneId);
      render();
    }
    
    function removeSzeneFromProbe(szeneId) { 
      if (!state.selectedProbe) return; 
      removeSzeneFromProbeById(state.selectedProbe, szeneId);
    }
    
    async function clearProbenplanung() { 
      if (!state.selectedProbe) return; 
      if (!confirm('Szenen f√ºr diesen Tag leeren?')) return; 
      
      // Cloud Sync - alle Szenen f√ºr diese Probe l√∂schen
      if (isCloudMode && currentCloudProjectId) {
        try {
          await db.from('rehearsal_scenes')
            .delete()
            .eq('project_id', currentCloudProjectId)
            .eq('rehearsal_id', state.selectedProbe);
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      
      await saveProbenplanungForProbe(state.selectedProbe, []);
      render(); 
    }
    
    async function clearGesamtPlan() {
      if (!confirm('Den GESAMTEN Probeplan leeren?')) return;
      
      // Cloud Sync - alle Probenplanung l√∂schen
      if (isCloudMode && currentCloudProjectId) {
        try {
          await db.from('rehearsal_scenes')
            .delete()
            .eq('project_id', currentCloudProjectId);
        } catch (e) { console.error('Cloud sync error:', e); }
      }
      
      setData(KEYS.probenplanung, []);
      render();
    }

    // ============================================
    // EXPORTS
    // ============================================
    function exportProbenplanFormatted() {
      const probedaten = sortByDatum(getData(KEYS.probedaten));
      const szenen = getData(KEYS.szenen);
      const probenplanung = getData(KEYS.probenplanung);
      const zuordnungen = getData(KEYS.zuordnungen);
      
      // Sammle alle Proben mit Szenen
      const probenMitPlanung = [];
      probenplanung.forEach(pl => {
        if (pl.szenen && pl.szenen.length > 0) {
          const probe = probedaten.find(p => String(p.id) === String(pl.probeId));
          if (probe) {
            probenMitPlanung.push({
              probe: probe,
              szenen: pl.szenen.map(szId => szenen.find(s => s.id === szId)).filter(s => s)
            });
          }
        }
      });
      
      // Sortiere nach Datum
      probenMitPlanung.sort((a, b) => toISODate(a.probe.datum).localeCompare(toISODate(b.probe.datum)));
      
      if (probenMitPlanung.length === 0) { 
        alert('Keine Proben im Plan!'); 
        return; 
      }
      
      // Beteiligte f√ºr eine Szene ermitteln
      const getBeteiligte = (sz) => {
        const figuren = [...(sz.hauptfiguren || '').split(','), ...(sz.nebenfiguren || '').split(',')].map(f => f.trim()).filter(f => f);
        const beteiligte = figuren.map(f => { 
          const z = zuordnungen.find(zu => (zu.figur || '').toLowerCase() === f.toLowerCase()); 
          return z?.schauspieler; 
        }).filter(s => s);
        return beteiligte.length > 0 ? beteiligte.join(', ') : 'Alle';
      };
      
      // Ermittle Zeitraum
      const ersteDatum = parseDatum(probenMitPlanung[0].probe.datum);
      const letzteDatum = parseDatum(probenMitPlanung[probenMitPlanung.length - 1].probe.datum);
      if (!ersteDatum || isNaN(ersteDatum.getTime()) || !letzteDatum || isNaN(letzteDatum.getTime())) {
        alert('Export nicht m√∂glich: Mindestens ein Probetermin hat ein ung√ºltiges Datum.');
        return;
      }
      const titel = `${state.projekt?.name || 'Projekt'} - Probeplan vom ${ersteDatum.getDate()}. - ${letzteDatum.getDate()}. ${MONATE[letzteDatum.getMonth()]}`;
      
      // Excel-Daten aufbauen
      const wsData = [];
      
      // Titel
      wsData.push([titel]);
      wsData.push([]);
      
      // Header
      wsData.push(['Zeit', 'Szene', 'Beteiligte']);
      
      // Daten gruppiert nach Datum
      let currentDatum = null;
      probenMitPlanung.forEach(item => {
        const probeDatum = toISODate(item.probe.datum);
        
        // Neue Datums√ºberschrift wenn Datum wechselt
        if (probeDatum !== currentDatum) {
          currentDatum = probeDatum;
          const d = parseDatum(probeDatum);
          // Leere Zeile vor neuem Tag (ausser beim ersten)
          if (wsData.length > 3) {
            wsData.push(['', '', '']);
          }
          // Datums√ºberschrift
          wsData.push([`${WOCHENTAGE[d.getDay()]}, ${d.getDate()}. ${MONATE[d.getMonth()]}`, '', '']);
        }
        
        // Szenen f√ºr diese Probe
        item.szenen.forEach(sz => {
          const zeit = `${item.probe.anfangszeit || ''} - ${item.probe.endzeit || ''} Uhr`;
          const szenenName = `${sz.nummer ? sz.nummer + ': ' : ''}${sz.name || sz.szene || ''}`;
          const beteiligte = getBeteiligte(sz);
          wsData.push([zeit, szenenName, beteiligte]);
        });
      });
      
      // Excel erstellen
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      
      // Spaltenbreiten
      ws['!cols'] = [
        { wch: 20 },  // Zeit
        { wch: 50 },  // Szene
        { wch: 30 }   // Beteiligte
      ];
      
      // Styling (wenn xlsx-js-style verf√ºgbar)
      try {
        // Titel-Zeile
        if (ws['A1']) {
          ws['A1'].s = { font: { bold: true, sz: 14 } };
        }
        // Header-Zeile
        ['A3', 'B3', 'C3'].forEach(cell => {
          if (ws[cell]) {
            ws[cell].s = { font: { bold: true }, fill: { fgColor: { rgb: 'EEEEEE' } } };
          }
        });
        // Datumszeilen fett
        wsData.forEach((row, idx) => {
          if (idx >= 3 && row[0] && row[0].includes(',') && !row[0].includes('Uhr')) {
            const cell = `A${idx + 1}`;
            if (ws[cell]) {
              ws[cell].s = { font: { bold: true } };
            }
          }
        });
      } catch (e) {
        // Styling optional
      }
      
      // Merge f√ºr Titel
      ws['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 2 } }];
      
      XLSX.utils.book_append_sheet(wb, ws, 'Probeplan');
      XLSX.writeFile(wb, `Probeplan_${state.projekt?.name?.replace(/\s+/g, '_') || 'Export'}_${new Date().toISOString().split('T')[0]}.xlsx`);
    }

    // ============================================
    // SYSTEM PAGES
    // ============================================
    function renderListen() {
      const counts = { probedaten: getData(KEYS.probedaten).length, ensemble: getData(KEYS.ensemble).length, team: getData(KEYS.kuenstlerischesTeam).length, teamVerfuegbarkeit: getData(KEYS.teamVerfuegbarkeit).length, figuren: getData(KEYS.figuren).length, zuordnungen: getData(KEYS.zuordnungen).length, szenen: getData(KEYS.szenen).length, absenzen: getData(KEYS.absenzen).length };
      const labels = { probedaten: { icon: 'üìÖ', name: 'Probetermine' }, ensemble: { icon: 'üë•', name: 'Ensemble' }, team: { icon: 'üé¨', name: 'K√ºnstl. Team' }, teamVerfuegbarkeit: { icon: 'üìÜ', name: 'Team-Verf√ºgbarkeit' }, figuren: { icon: 'üé≠', name: 'Figuren' }, zuordnungen: { icon: 'üîó', name: 'Besetzung' }, szenen: { icon: 'üìë', name: 'Szenen' }, absenzen: { icon: 'üö´', name: 'Absenzen' } };
      return `<div class="fade-in max-w-3xl mx-auto"><div class="text-center mb-6"><div class="text-5xl mb-3">üìã</div><h2 class="text-xl font-semibold">Listen exportieren</h2></div><div class="grid grid-cols-2 gap-4">${Object.entries(counts).map(([key, count]) => { const l = labels[key]; return `<div class="card p-5 cursor-pointer hover:shadow-lg transition ${count === 0 ? 'opacity-50' : ''}" onclick="${count > 0 ? `exportStyledExcel('${key}')` : ''}"><div class="flex items-center gap-4"><div class="text-3xl">${l.icon}</div><div class="flex-1"><div class="font-semibold">${l.name}</div><div class="text-sm text-gray-500">${count} Eintr√§ge</div></div>${count > 0 ? '<div class="text-teal-500">üì§</div>' : ''}</div></div>`; }).join('')}</div><div class="card p-5 mt-6 bg-yellow-50 border-yellow-200"><div class="flex items-center gap-3"><div class="text-2xl">üìã</div><div class="flex-1"><div class="font-semibold text-yellow-800">Formatierter Probeplan</div><div class="text-sm text-yellow-600">Export wie Referenz-Bild</div></div><button onclick="exportProbenplanFormatted()" class="btn btn-orange btn-sm">Exportieren</button></div></div></div>`;
    }

    function renderImportExport() {
      const hasProject = !!state.projekt;
      const projektName = hasProject ? (state.projekt.name || 'Projekt') : 'Projekt';
      const disabledStyle = !hasProject ? 'opacity: 0.4; pointer-events: none;' : '';
      const disabledNote = !hasProject ? '<p class="text-xs text-orange-500 mt-2">‚ö†Ô∏è Bitte zuerst ein Projekt ausw√§hlen, um Daten exportieren zu k√∂nnen.</p>' : '';
      
      return `<div class="fade-in max-w-2xl mx-auto">
        
        <!-- IMPORT -->
        <div class="card p-6 mb-6">
          <h3 class="text-lg font-semibold mb-4">üì• Importieren</h3>
          
          <div class="space-y-3">
            <!-- Austausch-Datei Import -->
            <div class="p-4 rounded-lg border" style="background: linear-gradient(135deg, rgba(139,92,246,0.08), rgba(20,184,166,0.08)); border-color: #8b5cf6;">
              <div class="flex items-center justify-between">
                <div>
                  <p class="font-medium text-sm" style="color: #5b21b6;">üîÑ Austausch-Datei laden</p>
                  <p class="text-xs text-gray-500 mt-1">Lade eine Austausch-Datei, die jemand aus dem Rebu oder der Werkbank exportiert hat. Figuren, Szenen und weitere Daten werden in dein Projekt √ºbernommen.</p>
                </div>
                <label class="btn btn-sm cursor-pointer ml-4" style="background: linear-gradient(135deg, #8b5cf6, #14b8a6); color: white; white-space: nowrap;">
                  üìÇ Datei w√§hlen
                  <input type="file" accept=".json" onchange="importNinaExchange(this)" class="hidden">
                </label>
              </div>
            </div>
            
            <!-- Backup Import -->
            <div class="p-4 rounded-lg border border-green-300 bg-green-50">
              <div class="flex items-center justify-between">
                <div>
                  <p class="font-medium text-sm text-green-800">üíæ Backup wiederherstellen</p>
                  <p class="text-xs text-gray-500 mt-1">Lade ein fr√ºheres Propla-Backup. Es wird als neues Projekt angelegt, damit nichts √ºberschrieben wird.</p>
                </div>
                <label class="btn btn-sm btn-success cursor-pointer ml-4" style="white-space: nowrap;">
                  üìÇ Datei w√§hlen
                  <input type="file" accept=".json" onchange="importBackup(this)" class="hidden">
                </label>
              </div>
            </div>
          </div>
        </div>
        
        <!-- EXPORT -->
        <div class="card p-6 mb-6">
          <h3 class="text-lg font-semibold mb-4">üì§ Exportieren</h3>
          ${disabledNote}
          
          <div class="space-y-3" style="${disabledStyle}">
            <!-- Backup Export -->
            <div class="p-4 rounded-lg border border-green-300 bg-green-50 hover:bg-green-100 cursor-pointer" onclick="exportBackup('${state.projekt?.id}')">
              <div class="flex items-center gap-3">
                <div class="flex-1">
                  <p class="font-medium text-sm text-green-800">üíæ Backup auf dieses Ger√§t</p>
                  <p class="text-xs text-gray-500 mt-1">Speichert dein ganzes Projekt als Datei auf deinem Computer. Damit kannst du es jederzeit wiederherstellen.</p>
                </div>
                <span class="px-2 py-0.5 bg-green-600 text-white text-xs font-bold rounded">SICHER</span>
              </div>
            </div>
            
            <!-- Exchange Export -->
            <div class="p-4 rounded-lg border hover:opacity-90 cursor-pointer" style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(20,184,166,0.1)); border-color: #8b5cf6;" onclick="exportNinaExchange()">
              <div class="flex-1">
                <p class="font-medium text-sm" style="color: #5b21b6;">üîÑ F√ºr Rebu / Werkbank</p>
                <p class="text-xs text-gray-500 mt-1">Erstellt eine Austausch-Datei, die dein Team im Rebu oder der Werkbank √∂ffnen kann. Ensemble, Proben, Besetzung und weitere Daten werden geteilt.</p>
              </div>
            </div>
          </div>
        </div>
        
        <!-- GOOGLE DRIVE -->
        <div class="card p-6 mb-6" style="background: linear-gradient(135deg, rgba(66,133,244,0.05), rgba(52,168,83,0.05));">
          <h3 class="text-lg font-semibold mb-2">‚òÅÔ∏è Google Drive ‚Äì Im Team teilen</h3>
          ${gdriveIsConnected() ? `
            <div class="flex items-center gap-2 mb-3 text-sm">
              <span class="text-green-600">‚úÖ ${gdriveUser?.email || 'Verbunden'}</span>
              ${gdriveFolderName ? `<span class="text-gray-400">¬∑</span> <span class="text-gray-600">üìÅ ${gdriveFolderName}</span>` : ''}
              <span class="ml-auto text-xs text-gray-400 cursor-pointer hover:text-red-500" onclick="gdriveSignOut()">Abmelden</span>
            </div>
            ${gdriveFolderId ? `
              <p class="text-xs text-gray-500 mb-3">Speichert direkt in euren geteilten Projektordner auf Google Drive ‚Äì dein Team kann die Dateien dort sofort √∂ffnen.</p>
              ${hasProject ? `
              <div class="grid grid-cols-2 gap-3 mb-3">
                <button class="btn btn-sm w-full" style="background: #4285f4; color: white; border: none;" onclick="gdriveSaveExchangePropla()" ${gdriveSaving ? 'disabled' : ''}>
                  ${gdriveSaving ? '‚è≥ ...' : 'üîÑ Austausch-Datei'}
                </button>
                <button class="btn btn-sm btn-outline w-full" onclick="gdriveSaveBackupPropla()" ${gdriveSaving ? 'disabled' : ''}>
                  ${gdriveSaving ? '‚è≥ ...' : 'üíæ Backup'}
                </button>
              </div>
              ` : `<p class="text-xs text-orange-500 mb-3">‚ö†Ô∏è Projekt ausw√§hlen, um Dateien in Drive zu speichern.</p>`}
              <div class="border-t pt-3 mt-3">
                <div class="flex items-center justify-between mb-2">
                  <span class="text-sm font-medium">üì• Aus Drive laden</span>
                  <div class="flex gap-2">
                    <button class="btn btn-xs btn-outline" onclick="gdriveShowFolderPicker()">üìÅ Ordner wechseln</button>
                    <button class="btn btn-xs btn-outline" onclick="gdriveRefreshFilesPropla()">üîÑ Aktualisieren</button>
                  </div>
                </div>
                <div id="gdriveFileListPropla"><p class="text-xs text-gray-400">Klicke ¬´Aktualisieren¬ª um Dateien zu laden.</p></div>
              </div>
            ` : `
              <button class="btn btn-sm btn-outline w-full" onclick="gdriveShowFolderPicker()">üìÅ Ordner w√§hlen</button>
            `}
          ` : `
            <p class="text-sm text-gray-500 mb-3">Verbinde dich mit Google Drive, um Dateien direkt in einen geteilten Projektordner zu speichern ‚Äì ohne Dateien per Mail hin und her schicken.</p>
            <button class="btn btn-sm w-full" style="background: #4285f4; color: white; border: none;" onclick="gdriveShowFolderPicker()">
              üîë Mit Google verbinden
            </button>
          `}
        </div>
        
      </div>`;
    }
    
    // Google Drive: Exchange speichern (Propla)
    async function gdriveSaveExchangePropla() {
      if (!gdriveIsConnected()) { gdriveSignIn(); return; }
      if (!gdriveFolderId) { gdriveShowFolderPicker(); return; }
      if (!state.projekt) { alert('Bitte zuerst ein Projekt ausw√§hlen.'); return; }
      gdriveSaving = true; render();
      try {
        // Exchange-Daten manuell erzeugen (exportNinaExchange macht Download, wir brauchen nur die Daten)
        const exchangeData = buildPropExchangeData();
        const safeName = (state.projekt.name || 'Projekt').replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü]/g, '_');
        const now = new Date(); const ts = now.toISOString().slice(0, 10) + '_' + now.toTimeString().slice(0, 5).replace(':', '-');
        const fileName = safeName + '_Propla_Exchange_' + ts + '.json';
        await gdriveSaveFile(fileName, exchangeData);
        alert('‚úÖ Austausch-Datei gespeichert!\n\nüìÅ ' + gdriveFolderName + '\nüìÑ ' + fileName);
      } catch(err) { alert('‚ùå Speichern fehlgeschlagen: ' + err.message); }
      gdriveSaving = false; render();
    }
    
    // Google Drive: Backup speichern (Propla)
    async function gdriveSaveBackupPropla() {
      if (!gdriveIsConnected()) { gdriveSignIn(); return; }
      if (!gdriveFolderId) { gdriveShowFolderPicker(); return; }
      if (!state.projekt) { alert('Bitte zuerst ein Projekt ausw√§hlen.'); return; }
      gdriveSaving = true; render();
      try {
        const projektId = state.projekt.id;
        const p = state.projekte.find(pr => pr.id === projektId);
        const backupData = { exportedAt: new Date().toISOString(), exportedFrom: 'N!NA-Propla v3.0', projectInfo: p, probedaten: load(KEYS.probedaten(projektId), []), ensemble: load(KEYS.ensemble(projektId), []), kuenstlerischesTeam: load(KEYS.kuenstlerischesTeam(projektId), []), teamVerfuegbarkeit: load(KEYS.teamVerfuegbarkeit(projektId), []), figuren: load(KEYS.figuren(projektId), []), zuordnungen: load(KEYS.zuordnungen(projektId), []), szenen: load(KEYS.szenen(projektId), []), absenzen: load(KEYS.absenzen(projektId), []), probenplanung: load(KEYS.probenplanung(projektId), []) };
        const safeName = (p?.name || 'Projekt').replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü]/g, '_');
        const now = new Date(); const ts = now.toISOString().slice(0, 10) + '_' + now.toTimeString().slice(0, 5).replace(':', '-');
        const fileName = safeName + '_Propla_Backup_' + ts + '.json';
        await gdriveSaveFile(fileName, backupData);
        alert('‚úÖ Backup gespeichert!\n\nüìÅ ' + gdriveFolderName + '\nüìÑ ' + fileName);
      } catch(err) { alert('‚ùå Speichern fehlgeschlagen: ' + err.message); }
      gdriveSaving = false; render();
    }
    
    // Google Drive: Dateien auflisten
    async function gdriveRefreshFilesPropla() {
      const container = document.getElementById('gdriveFileListPropla');
      if (!container) return;
      container.innerHTML = '<p class="text-xs text-gray-400">‚è≥ Laden...</p>';
      try {
        const files = await gdriveListFiles();
        if (files.length === 0) { container.innerHTML = '<p class="text-xs text-gray-400">Keine Dateien in diesem Ordner.</p>'; return; }
        container.innerHTML = files.map(f => {
          const isExchange = f.name.toLowerCase().includes('exchange');
          const isBackup = f.name.toLowerCase().includes('backup');
          const label = isExchange ? 'Exchange' : isBackup ? 'Backup' : 'Datei';
          const color = isExchange ? 'color:#8b5cf6' : isBackup ? 'color:#10b981' : 'color:#666';
          const date = new Date(f.modifiedTime).toLocaleString('de-CH', { day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit' });
          return `<div style="padding:8px 10px;border:1px solid #e5e7eb;border-radius:6px;margin-bottom:4px;display:flex;align-items:center;gap:8px;cursor:pointer;font-size:13px;" onclick="gdriveImportFilePropla('${f.id}','${f.name.replace(/'/g,"\\'")}')"><span style="flex:1;"><strong>${f.name}</strong><br><span style="font-size:11px;color:#999;">${date}</span></span><span style="font-size:11px;font-weight:600;${color}">${label}</span></div>`;
        }).join('');
      } catch(e) { container.innerHTML = '<p class="text-xs text-red-500">Fehler: ' + e.message + '</p>'; }
    }
    
    // Google Drive: Datei importieren
    async function gdriveImportFilePropla(fileId, fileName) {
      try {
        const data = await gdriveLoadFile(fileId);
        
        if (data.format === 'nina-exchange') {
          // Exchange-Import
          const details = [];
          if (data.figures?.length) details.push(data.figures.length + ' Figuren');
          if (data.scenes?.length) details.push(data.scenes.length + ' Szenen');
          if (data.persons?.length) details.push(data.persons.length + ' Personen');
          if (data.rehearsals?.length) details.push(data.rehearsals.length + ' Proben');
          const summary = details.join(', ');
          
          if (!state.projekt) {
            if (!confirm('Kein Projekt ausgew√§hlt. Soll ein neues Projekt erstellt werden?\n\nProjekt: ' + (data.project?.name || 'Import'))) return;
            const newProjekt = { id: genId(), name: data.project?.name || 'Import', premiere: data.project?.premiere_date || '', regie: data.project?.director || '', spielstaette: data.project?.venue || '', createdAt: new Date().toISOString() };
            state.projekte.push(newProjekt); save(KEYS.projekte, state.projekte); selectProjekt(newProjekt.id);
          }
          
          const version = data.version || '3.0';
          const source = data.exportedFrom === 'werkbank' ? 'Werkbank' : data.exportedFrom === 'rebu' ? 'Rebu' : data.exportedFrom === 'propla' ? 'Propla' : 'unbekannt';
          showNinaImportPreview(data, version, source);
          
        } else if (data.projectInfo || data.exportedFrom) {
          // Backup-Import
          if (confirm('üíæ Backup wiederherstellen?\\n\\nüìÑ ' + fileName + '\\n\\nWird als neues Projekt angelegt.')) {
            // Reuse importBackup logic manually
            const p = { id: genId(), name: data.projectInfo?.name || 'Import', premiere: data.projectInfo?.premiere || '', regie: data.projectInfo?.regie || '', spielstaette: data.projectInfo?.spielstaette || '', createdAt: new Date().toISOString() };
            state.projekte.push(p); save(KEYS.projekte, state.projekte);
            const imp = (key, arr) => { if (arr?.length) save(key(p.id), arr.map(i => ({ ...i, id: i.id || genId() }))); };
            imp(KEYS.probedaten, data.probedaten); imp(KEYS.ensemble, data.ensemble); imp(KEYS.kuenstlerischesTeam, data.kuenstlerischesTeam || data.team); imp(KEYS.teamVerfuegbarkeit, data.teamVerfuegbarkeit); imp(KEYS.figuren, data.figuren); imp(KEYS.zuordnungen, data.zuordnungen); imp(KEYS.szenen, data.szenen); imp(KEYS.absenzen, data.absenzen); imp(KEYS.probenplanung, data.probenplanung);
            selectProjekt(p.id);
            alert('‚úÖ Backup wiederhergestellt als Projekt "' + p.name + '"!');
          }
        } else {
          alert('‚ö†Ô∏è Dateiformat nicht erkannt.\\n\\nüìÑ ' + fileName);
        }
      } catch(err) { alert('‚ùå Fehler beim Laden: ' + err.message); }
    }

    function renderEinstellungen() {
      return `<div class="fade-in max-w-2xl mx-auto"><div class="card p-6 mb-6"><div class="flex items-center gap-4 mb-4"><div class="text-4xl">‚ÑπÔ∏è</div><div><h3 class="text-lg font-semibold">N!NA-Propla v3.0</h3><p class="text-sm text-gray-500">Probeplaner mit Team-Verf√ºgbarkeit</p></div></div></div>${state.projekt ? `<div class="card p-6 mb-6"><h3 class="text-lg font-semibold mb-4">‚öôÔ∏è Projekteinstellungen</h3><div class="space-y-4"><div><label class="input-label">Projektname</label><input type="text" value="${escapeHtml(state.projekt.name)}" onchange="updateProjekt('name', this.value)"></div><div class="grid grid-cols-2 gap-4"><div><label class="input-label">Regie</label><input type="text" value="${escapeHtml(state.projekt.regie || '')}" onchange="updateProjekt('regie', this.value)"></div><div><label class="input-label">Premiere</label><input type="date" value="${state.projekt.premiere || ''}" onchange="updateProjekt('premiere', this.value)"></div></div></div></div>` : ''}<div class="card p-6 border-red-200 bg-red-50"><h3 class="text-lg font-semibold text-red-800 mb-4">üóëÔ∏è Gefahrenzone</h3><button onclick="clearAllData()" class="btn btn-danger">Alle Daten l√∂schen</button></div></div>`;
    }
    function updateProjekt(field, value) { if (!state.projekt) return; state.projekt[field] = value; const idx = state.projekte.findIndex(p => p.id === state.projekt.id); if (idx !== -1) { state.projekte[idx] = { ...state.projekt }; save(KEYS.projekte, state.projekte); } save(KEYS.aktuellesProjekt, state.projekt); render(); }
    function clearAllData() { if (!confirm('‚ö†Ô∏è Alle Daten l√∂schen?')) return; Object.keys(localStorage).forEach(key => { if (key.startsWith('nina_')) localStorage.removeItem(key); }); state.projekte = []; state.projekt = null; render(); }

    // ============================================
    // HELPERS
    // ============================================
    function navigate(page) { state.page = page; state.showProjektAuswahl = false; render(); }
    function createProjekt() { 
      const name = document.getElementById('neuesProjektName')?.value?.trim(); 
      if (!name) return alert('Name!'); 
      const p = { id: genId(), name, premiere: document.getElementById('neuesProjektPremiere')?.value || '', regie: document.getElementById('neuesProjektRegie')?.value || '', spielstaette: document.getElementById('neuesProjektSpielstaette')?.value || '', createdAt: new Date().toISOString() }; 
      state.projekte.push(p); 
      save(KEYS.projekte, state.projekte); 
      selectProjekt(p.id); 
    }
    function selectProjekt(id) { 
      state.projekt = state.projekte.find(p => p.id === id); 
      save(KEYS.aktuellesProjekt, state.projekt); 
      state.selectedProbe = null; 
      state.showProjektAuswahl = false;
      
      // Cloud-ID setzen wenn das Projekt mit Cloud verkn√ºpft ist
      if (state.projekt?.cloudId) {
        currentCloudProjectId = state.projekt.cloudId;
      } else if (state.projekt?.id?.startsWith('cloud_')) {
        currentCloudProjectId = state.projekt.id.replace('cloud_', '');
      } else {
        currentCloudProjectId = null;
      }
      
      // Migrate probenplanung data
      migrateProbenplanung();
      render(); 
    }
    function deleteProjekt(id) { if (!confirm('L√∂schen?')) return; state.projekte = state.projekte.filter(p => p.id !== id); save(KEYS.projekte, state.projekte); if (state.projekt?.id === id) { state.projekt = null; save(KEYS.aktuellesProjekt, null); } Object.keys(localStorage).forEach(key => { if (key.includes(id)) localStorage.removeItem(key); }); render(); }
    async function deleteRow(id, type) { 
      const keyMap = { probedaten: KEYS.probedaten, kuenstlerischesTeam: KEYS.kuenstlerischesTeam, teamVerfuegbarkeit: KEYS.teamVerfuegbarkeit, ensemble: KEYS.ensemble, figuren: KEYS.figuren, zuordnungen: KEYS.zuordnungen, szenen: KEYS.szenen, absenzen: KEYS.absenzen }; 
      // Read-only-Schutz
      const checkData = getData(keyMap[type]);
      const checkItem = checkData.find(d => d.id === id);
      if (checkItem && checkItem._readOnly) { alert('üîí Dieses Element ist gesch√ºtzt und kann in Propla nicht gel√∂scht werden.'); return; }
      if (!confirm('Eintrag wirklich l√∂schen?')) return;
      // Item VOR dem L√∂schen holen f√ºr Bereinigung
      const allData = getData(keyMap[type]);
      const deletedItem = allData.find(d => d.id === id);
      let data = allData.filter(d => d.id !== id); 
      setData(keyMap[type], data);
      
      // Cloud Sync - L√∂schen
      if (isCloudMode && currentCloudProjectId && deletedItem) {
        try {
          const cloudTableMap = {
            probedaten: 'rehearsals',
            ensemble: 'persons',
            kuenstlerischesTeam: 'persons',
            figuren: 'figures',
            szenen: 'scenes',
            zuordnungen: 'castings',
            absenzen: 'person_absences',
            teamVerfuegbarkeit: 'team_availability'
          };
          const cloudTable = cloudTableMap[type];
          if (cloudTable && deletedItem.id) {
            await db.from(cloudTable).delete().eq('id', deletedItem.id);
          }
        } catch (e) { console.error('Cloud delete error:', e); }
      }
      
      // Verwaiste Daten bereinigen
      if (type === 'figuren' && deletedItem) {
        // Zuordnungen f√ºr gel√∂schte Figur entfernen
        let zuordnungen = getData(KEYS.zuordnungen).filter(z => z.figur !== (deletedItem.figur || deletedItem.name));
        setData(KEYS.zuordnungen, zuordnungen);
        // Cloud: Castings l√∂schen
        if (isCloudMode && currentCloudProjectId && deletedItem.id) {
          try { await db.from('castings').delete().eq('figure_id', deletedItem.id); } catch (e) {}
        }
      }
      if (type === 'ensemble' && deletedItem) {
        // Absenzen und Zuordnungen f√ºr gel√∂schtes Ensemble-Mitglied entfernen
        let absenzen = getData(KEYS.absenzen).filter(a => a.schauspieler !== deletedItem.name);
        setData(KEYS.absenzen, absenzen);
        let zuordnungen = getData(KEYS.zuordnungen).filter(z => z.schauspieler !== deletedItem.name);
        setData(KEYS.zuordnungen, zuordnungen);
        // Cloud: Absenzen und Castings l√∂schen
        if (isCloudMode && currentCloudProjectId && deletedItem.id) {
          try { 
            await db.from('person_absences').delete().eq('person_id', deletedItem.id); 
            await db.from('castings').delete().eq('person_id', deletedItem.id);
          } catch (e) {}
        }
      }
      if (type === 'probedaten') {
        // Probenplanung f√ºr gel√∂schte Probe entfernen
        let probenplanung = getData(KEYS.probenplanung).filter(p => p.probeId !== id);
        setData(KEYS.probenplanung, probenplanung);
      }
      render(); 
    }
    function importBackup(input) { const file = input.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const data = JSON.parse(e.target.result); const p = { id: genId(), name: data.projectInfo?.name || 'Import', premiere: data.projectInfo?.premiere || '', regie: data.projectInfo?.regie || '', spielstaette: data.projectInfo?.spielstaette || '', createdAt: new Date().toISOString() }; state.projekte.push(p); save(KEYS.projekte, state.projekte); const imp = (key, arr) => { if (arr?.length) save(key(p.id), arr.map(i => ({ ...i, id: i.id || genId() }))); }; imp(KEYS.probedaten, data.probedaten); imp(KEYS.ensemble, data.ensemble); imp(KEYS.kuenstlerischesTeam, data.kuenstlerischesTeam || data.team); imp(KEYS.teamVerfuegbarkeit, data.teamVerfuegbarkeit); imp(KEYS.figuren, data.figuren); imp(KEYS.zuordnungen, data.zuordnungen); imp(KEYS.szenen, data.szenen); imp(KEYS.absenzen, data.absenzen); imp(KEYS.probenplanung, data.probenplanung); selectProjekt(p.id); alert('‚úì Import OK!'); } catch (err) { alert('Fehler: ' + err.message); } }; reader.readAsText(file); }
    
    // ============================================
    // NINA-EXCHANGE IMPORT (von Dramera/Rebu)
    // ============================================
    // ============================================
    // NINA-EXCHANGE IMPORT v2.0
    // ============================================
    function importNinaExchange(input) {
      const file = input.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          
          // Pr√ºfen ob es ein NINA-Exchange Format ist
          if (data.format !== 'nina-exchange') {
            alert('‚ùå Diese Datei ist kein NINA-Exchange Format.\n\nBitte exportiere das Projekt zuerst aus Werkbank oder Rebu.');
            return;
          }
          
          const version = data.version || '1.0';
          const source = data.exportedFrom === 'werkbank' ? 'Werkbank' : 
                        data.exportedFrom === 'rebu' ? 'Rebu' : 
                        data.exportedFrom === 'propla' ? 'Propla' : 'unbekannt';
          
          // Pr√ºfen ob Projekt ausgew√§hlt, sonst neues erstellen
          if (!state.projekt) {
            const createNew = confirm(
              `üîÑ NINA-Exchange v${version} Import\n\n` +
              `Quelle: ${source}\n` +
              `Projekt: ${data.project?.name || 'Unbenannt'}\n\n` +
              `Kein Projekt ausgew√§hlt. Soll ein neues Projekt erstellt werden?`
            );
            if (!createNew) return;
            
            const newProjekt = {
              id: genId(),
              name: data.project?.name || 'Import aus ' + source,
              autor: data.project?.author || '',
              premiere: data.project?.premiere_date || '',
              regie: data.project?.director || '',
              spielstaette: data.project?.venue || '',
              untertitel: data.project?.subtitle || '',
              tagline: data.project?.tagline || '',
              logline: data.project?.logline || '',
              copyright: data.project?.copyright || '',
              createdAt: new Date().toISOString()
            };
            state.projekte.push(newProjekt);
            save(KEYS.projekte, state.projekte);
            selectProjekt(newProjekt.id);
          }
          
          // Preview generieren
          showNinaImportPreview(data, version, source);
          
        } catch (err) {
          console.error('NINA-Exchange Import Fehler:', err);
          alert('‚ùå Import fehlgeschlagen: ' + err.message);
        }
      };
      reader.readAsText(file);
      input.value = '';
    }
    
    // ============================================
    // NINA-EXCHANGE v3.0 IMPORT PREVIEW
    // ============================================
    let pendingNinaImport = null;
    
    function showNinaImportPreview(data, version, source) {
      pendingNinaImport = data;
      const projektId = state.projekt.id;
      
      // Bestehende Daten laden
      const existingFiguren = load(KEYS.figuren(projektId), []);
      const existingSzenen = load(KEYS.szenen(projektId), []);
      const existingEnsemble = load(KEYS.ensemble(projektId), []);
      const existingTeam = load(KEYS.kuenstlerischesTeam(projektId), []);
      
      // Analyse: Was ist neu, was existiert, was hat Konflikte?
      const analysis = {
        figuren: { neu: [], aktualisiert: [], uebersprungen: [] },
        szenen: { neu: [], aktualisiert: [], uebersprungen: [] },
        ensemble: { neu: [], aktualisiert: [], uebersprungen: [] },
        team: { neu: [], aktualisiert: [], uebersprungen: [] },
        castings: { neu: 0 },
        rehearsals: { neu: 0 },
        absences: { neu: 0 },
        team_availability: { neu: 0 }
      };
      
      // Figuren analysieren (v3.1: mit ID-Match f√ºr Rename-Erkennung)
      for (const fig of (data.figures || [])) {
        const name = (fig.name || '').toLowerCase();
        // 1. Zuerst nach _exchangeId matchen
        let existing = existingFiguren.find(f => f._exchangeId && f._exchangeId === fig.id);
        // 2. Fallback: nach Name
        if (!existing) existing = existingFiguren.find(f => (f.figur || f.name || '').toLowerCase() === name);
        
        if (!existing) {
          analysis.figuren.neu.push(fig.name);
        } else {
          const oldName = (existing.figur || existing.name || '').toLowerCase();
          if (oldName !== name) {
            // Umbenennung erkannt!
            if (!analysis.figuren.umbenannt) analysis.figuren.umbenannt = [];
            analysis.figuren.umbenannt.push({ von: existing.figur || existing.name, zu: fig.name });
          } else {
            const hasNewData = (!existing.kurzbeschreibung && fig.description) || (!existing.color && fig.color);
            if (hasNewData) {
              analysis.figuren.aktualisiert.push(fig.name);
            } else {
              analysis.figuren.uebersprungen.push(fig.name);
            }
          }
        }
      }
      
      // Szenen analysieren (v3.1: mit ID-Match f√ºr Rename-Erkennung)
      for (const scene of (data.scenes || [])) {
        const name = (scene.name || '').toLowerCase();
        // 1. Zuerst nach _exchangeId matchen
        let existing = existingSzenen.find(s => s._exchangeId && s._exchangeId === scene.id);
        // 2. Fallback: nach Name
        if (!existing) existing = existingSzenen.find(s => (s.name || s.szene || '').toLowerCase() === name);
        
        if (!existing) {
          analysis.szenen.neu.push(scene.name);
        } else {
          const oldName = (existing.name || existing.szene || '').toLowerCase();
          if (oldName !== name) {
            if (!analysis.szenen.umbenannt) analysis.szenen.umbenannt = [];
            analysis.szenen.umbenannt.push({ von: existing.name || existing.szene, zu: scene.name });
          } else {
            const hasNewData = (!existing.beschreibung && (scene.description || scene.summary)) || (!existing.ort && scene.location);
            if (hasNewData) {
              analysis.szenen.aktualisiert.push(scene.name);
            } else {
              analysis.szenen.uebersprungen.push(scene.name);
            }
          }
        }
      }
      
      // Ensemble analysieren
      const ensemblePersons = (data.persons || []).filter(p => p.category === 'ensemble' || !p.category);
      for (const person of ensemblePersons) {
        const name = (person.name || '').toLowerCase();
        const existing = existingEnsemble.find(e => (e.name || '').toLowerCase() === name);
        if (!existing) {
          analysis.ensemble.neu.push(person.name);
        } else {
          analysis.ensemble.uebersprungen.push(person.name);
        }
      }
      
      // Team analysieren
      const teamPersons = (data.persons || []).filter(p => p.category === 'artistic_team');
      for (const person of teamPersons) {
        const name = (person.name || '').toLowerCase();
        const existing = existingTeam.find(t => (t.name || '').toLowerCase() === name);
        if (!existing) {
          analysis.team.neu.push(person.name);
        } else {
          analysis.team.uebersprungen.push(person.name);
        }
      }
      
      analysis.castings.neu = (data.castings || []).length;
      analysis.rehearsals.neu = (data.rehearsals || []).length;
      analysis.absences.neu = (data.absences || []).length;
      analysis.team_availability.neu = (data.team_availability || []).length;
      
      // Bestimmen welche Daten read-only sind (Figuren+Szenen wenn von Rebu/Werkbank)
      const figurenReadOnly = source === 'Rebu' || source === 'Werkbank';
      
      // Preview Modal erstellen
      const makeList = (items, max) => items.length <= max ? items.join(', ') : items.slice(0, max).join(', ') + ` (+${items.length - max})`;
      
      let html = `<div class="modal" onclick="if(event.target===this) closeNinaPreview()" style="z-index:9999">
        <div class="modal-content p-6" style="max-width: 650px; max-height: 85vh; overflow-y: auto;">
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-lg font-semibold" style="color: #5b21b6;">üì• NINA-Exchange v${version} Import-Vorschau</h3>
            <button onclick="closeNinaPreview()" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button>
          </div>
          <div class="text-sm text-gray-500 mb-4">
            Quelle: <strong>${source}</strong> ¬∑ Projekt: <strong>${data.project?.name || '‚Äî'}</strong> ¬∑ Exportiert: ${new Date(data.exportedAt).toLocaleDateString('de-CH')}
          </div>`;
      
      // Figuren
      if ((data.figures || []).length > 0) {
        html += `<div class="card p-4 mb-3" style="border-left: 4px solid #3b82f6;">
          <div class="flex items-center gap-2 mb-2"><span class="text-lg">üë§</span><strong>Figuren</strong>
          ${figurenReadOnly ? '<span style="background:#fef3c7;color:#92400e;padding:2px 8px;border-radius:4px;font-size:11px;">üîí read-only in Propla</span>' : ''}</div>`;
        if (analysis.figuren.neu.length > 0)
          html += `<div class="text-sm text-green-700">‚úÖ <strong>${analysis.figuren.neu.length} neu:</strong> ${makeList(analysis.figuren.neu, 5)}</div>`;
        if (analysis.figuren.aktualisiert.length > 0)
          html += `<div class="text-sm text-blue-700">üîÑ <strong>${analysis.figuren.aktualisiert.length} erg√§nzt:</strong> ${makeList(analysis.figuren.aktualisiert, 5)}</div>`;
        if (analysis.figuren.umbenannt && analysis.figuren.umbenannt.length > 0)
          html += `<div class="text-sm text-orange-700">‚úèÔ∏è <strong>${analysis.figuren.umbenannt.length} umbenannt:</strong> ${analysis.figuren.umbenannt.map(r => r.von + ' ‚Üí ' + r.zu).join(', ')}</div>
          <div class="text-xs text-orange-500 mt-1">‚ö° Wird automatisch in Besetzung + Szenen kaskadiert</div>`;
        if (analysis.figuren.uebersprungen.length > 0)
          html += `<div class="text-sm text-gray-400">‚è≠Ô∏è ${analysis.figuren.uebersprungen.length} bereits vorhanden</div>`;
        html += `</div>`;
      }
      
      // Szenen
      if ((data.scenes || []).length > 0) {
        html += `<div class="card p-4 mb-3" style="border-left: 4px solid #8b5cf6;">
          <div class="flex items-center gap-2 mb-2"><span class="text-lg">üé¨</span><strong>Szenen</strong>
          ${figurenReadOnly ? '<span style="background:#fef3c7;color:#92400e;padding:2px 8px;border-radius:4px;font-size:11px;">üîí read-only in Propla</span>' : ''}</div>`;
        if (analysis.szenen.neu.length > 0)
          html += `<div class="text-sm text-green-700">‚úÖ <strong>${analysis.szenen.neu.length} neu:</strong> ${makeList(analysis.szenen.neu, 5)}</div>`;
        if (analysis.szenen.aktualisiert.length > 0)
          html += `<div class="text-sm text-blue-700">üîÑ <strong>${analysis.szenen.aktualisiert.length} erg√§nzt:</strong> ${makeList(analysis.szenen.aktualisiert, 5)}</div>`;
        if (analysis.szenen.umbenannt && analysis.szenen.umbenannt.length > 0)
          html += `<div class="text-sm text-orange-700">‚úèÔ∏è <strong>${analysis.szenen.umbenannt.length} umbenannt:</strong> ${analysis.szenen.umbenannt.map(r => r.von + ' ‚Üí ' + r.zu).join(', ')}</div>`;
        if (analysis.szenen.uebersprungen.length > 0)
          html += `<div class="text-sm text-gray-400">‚è≠Ô∏è ${analysis.szenen.uebersprungen.length} bereits vorhanden</div>`;
        html += `</div>`;
      }
      
      // Ensemble
      if (ensemblePersons.length > 0) {
        html += `<div class="card p-4 mb-3" style="border-left: 4px solid #10b981;">
          <div class="flex items-center gap-2 mb-2"><span class="text-lg">üë•</span><strong>Ensemble</strong></div>`;
        if (analysis.ensemble.neu.length > 0)
          html += `<div class="text-sm text-green-700">‚úÖ <strong>${analysis.ensemble.neu.length} neu:</strong> ${makeList(analysis.ensemble.neu, 5)}</div>`;
        if (analysis.ensemble.uebersprungen.length > 0)
          html += `<div class="text-sm text-gray-400">‚è≠Ô∏è ${analysis.ensemble.uebersprungen.length} bereits vorhanden</div>`;
        html += `</div>`;
      }
      
      // Team
      if (teamPersons.length > 0) {
        html += `<div class="card p-4 mb-3" style="border-left: 4px solid #f97316;">
          <div class="flex items-center gap-2 mb-2"><span class="text-lg">üé®</span><strong>K√ºnstlerisches Team</strong></div>`;
        if (analysis.team.neu.length > 0)
          html += `<div class="text-sm text-green-700">‚úÖ <strong>${analysis.team.neu.length} neu:</strong> ${makeList(analysis.team.neu, 5)}</div>`;
        if (analysis.team.uebersprungen.length > 0)
          html += `<div class="text-sm text-gray-400">‚è≠Ô∏è ${analysis.team.uebersprungen.length} bereits vorhanden</div>`;
        html += `</div>`;
      }
      
      // Zus√§tzliche Daten
      const extras = [];
      if (analysis.castings.neu > 0) extras.push(`üé≠ ${analysis.castings.neu} Zuordnungen`);
      if (analysis.rehearsals.neu > 0) extras.push(`üìÖ ${analysis.rehearsals.neu} Proben`);
      if (analysis.absences.neu > 0) extras.push(`üö´ ${analysis.absences.neu} Absenzen`);
      if (analysis.team_availability.neu > 0) extras.push(`üìã ${analysis.team_availability.neu} Team-Verf√ºgbarkeiten`);
      
      if (extras.length > 0) {
        html += `<div class="card p-4 mb-3" style="border-left: 4px solid #6366f1;">
          <div class="flex items-center gap-2 mb-2"><span class="text-lg">üì¶</span><strong>Weitere Daten</strong></div>
          <div class="text-sm text-gray-600">${extras.join(' ¬∑ ')}</div>
        </div>`;
      }
      
      // Info-Box Souver√§nit√§t
      if (figurenReadOnly) {
        html += `<div class="card p-3 mb-4" style="background: #eff6ff; border-color: #93c5fd;">
          <div class="text-sm text-blue-800">‚ÑπÔ∏è <strong>Souver√§nit√§tsprinzip:</strong> Figuren und Szenen aus ${source} werden als read-only importiert. Propla kann sie anzeigen und f√ºr die Planung verwenden, aber nicht √§ndern.</div>
        </div>`;
      }
      
      html += `<div class="flex justify-end gap-3 mt-4">
            <button onclick="closeNinaPreview()" class="btn btn-outline">Abbrechen</button>
            <button onclick="executeNinaImport()" class="btn" style="background: linear-gradient(135deg, #8b5cf6, #14b8a6); color: white;">
              ‚úÖ Importieren
            </button>
          </div>
        </div>
      </div>`;
      
      // Modal anzeigen
      const modal = document.createElement('div');
      modal.id = 'ninaImportPreviewModal';
      modal.innerHTML = html;
      document.body.appendChild(modal);
    }
    
    function closeNinaPreview() {
      const modal = document.getElementById('ninaImportPreviewModal');
      if (modal) modal.remove();
      pendingNinaImport = null;
    }
    
    function executeNinaImport() {
      const data = pendingNinaImport;
      if (!data || !state.projekt) return;
      
      const projektId = state.projekt.id;
      const source = data.exportedFrom || 'unknown';
      const figurenReadOnly = source === 'werkbank' || source === 'rebu';
      
      let importedFiguren = 0, skippedFiguren = 0, updatedFiguren = 0, renamedFigurenCount = 0;
      let importedSzenen = 0, skippedSzenen = 0, updatedSzenen = 0, renamedSzenenCount = 0;
      let importedEnsemble = 0, importedTeam = 0;
      let importedCastings = 0, importedRehearsals = 0;
      let importedAbsences = 0, importedTeamAvail = 0;
      const renamedFiguren = []; // Track renames for cascade
      const renamedSzenen = [];
      
      // Projekt-Meta aktualisieren (nur leere Felder auff√ºllen)
      if (data.project) {
        const p = data.project;
        if (!state.projekt.autor && p.author) state.projekt.autor = p.author;
        if (!state.projekt.regie && p.director) state.projekt.regie = p.director;
        if (!state.projekt.premiere && p.premiere_date) state.projekt.premiere = p.premiere_date;
        if (!state.projekt.spielstaette && p.venue) state.projekt.spielstaette = p.venue;
        if (!state.projekt.untertitel && p.subtitle) state.projekt.untertitel = p.subtitle;
        if (!state.projekt.tagline && p.tagline) state.projekt.tagline = p.tagline;
        if (!state.projekt.logline && p.logline) state.projekt.logline = p.logline;
        if (!state.projekt.copyright && p.copyright) state.projekt.copyright = p.copyright;
        
        const idx = state.projekte.findIndex(pr => pr.id === state.projekt.id);
        if (idx !== -1) { state.projekte[idx] = state.projekt; save(KEYS.projekte, state.projekte); }
      }
      
      // === FIGUREN (v3.1: ID-Match + Rename-Kaskade) ===
      const existingFiguren = load(KEYS.figuren(projektId), []);
      const newFiguren = [...existingFiguren];
      const figurenIdMap = {};
      
      for (const fig of (data.figures || [])) {
        const name = fig.name || '';
        
        // 1. Zuerst nach _exchangeId matchen (erkennt Umbenennungen!)
        let existIdx = newFiguren.findIndex(f => f._exchangeId && f._exchangeId === fig.id);
        
        // 2. Fallback: nach Name matchen
        if (existIdx === -1) {
          existIdx = newFiguren.findIndex(f => (f.figur || f.name || '').toLowerCase() === name.toLowerCase());
        }
        
        if (existIdx === -1) {
          // Neue Figur
          const newId = genId();
          figurenIdMap[fig.id] = newId;
          newFiguren.push({
            id: newId, figur: name, name: name,
            kurzbeschreibung: fig.description || fig.biography || '',
            kuerzel: fig.short_name || '',
            color: fig.color || '',
            figure_type: fig.figure_type || 'main',
            _exchangeId: fig.id, // Persistente ID aus Quell-App
            _source: figurenReadOnly ? source : 'propla',
            _readOnly: figurenReadOnly
          });
          importedFiguren++;
        } else {
          figurenIdMap[fig.id] = newFiguren[existIdx].id;
          const existing = newFiguren[existIdx];
          let updated = false;
          
          // Exchange-ID nachtr√§glich setzen (f√ºr √§ltere Eintr√§ge ohne ID)
          if (!existing._exchangeId) { existing._exchangeId = fig.id; updated = true; }
          
          // Umbenennung erkennen: ID stimmt, aber Name hat sich ge√§ndert
          const oldName = (existing.figur || existing.name || '');
          if (oldName.toLowerCase() !== name.toLowerCase()) {
            renamedFiguren.push({ oldName: oldName, newName: name, id: existing.id });
            existing.figur = name;
            existing.name = name;
            // K√ºrzel aktualisieren wenn es vom alten Namen abgeleitet war
            if (fig.short_name) existing.kuerzel = fig.short_name;
            renamedFigurenCount++;
            updated = true;
          }
          
          // Leere Felder additiv auff√ºllen
          if (!existing.kurzbeschreibung && fig.description) { existing.kurzbeschreibung = fig.description; updated = true; }
          if (!existing.color && fig.color) { existing.color = fig.color; updated = true; }
          if (!existing.kuerzel && fig.short_name) { existing.kuerzel = fig.short_name; updated = true; }
          // Source-Markierung setzen wenn von Rebu/Werkbank
          if (figurenReadOnly && !existing._source) { existing._source = source; existing._readOnly = true; updated = true; }
          if (updated) updatedFiguren++; else skippedFiguren++;
        }
      }
      
      // === KASKADE: Figurenumbenennungen in Zuordnungen + Szenen propagieren ===
      const existingZuordnungen = load(KEYS.zuordnungen(projektId), []);
      if (renamedFiguren.length > 0) {
        for (const rename of renamedFiguren) {
          // Zuordnungen aktualisieren
          existingZuordnungen.forEach(z => {
            if ((z.figur || '').toLowerCase() === rename.oldName.toLowerCase()) {
              z.figur = rename.newName;
            }
          });
          // Szenen hauptfiguren + nebenfiguren aktualisieren
          newFiguren; // (Szenen werden unten separat behandelt, aber bestehende Szenen hier schon korrigieren)
        }
        save(KEYS.zuordnungen(projektId), existingZuordnungen);
      }
      
      save(KEYS.figuren(projektId), newFiguren);
      
      // === SZENEN (v3.1: ID-Match + Rename + hauptfiguren-Update) ===
      const existingSzenen = load(KEYS.szenen(projektId), []);
      const newSzenen = [...existingSzenen];
      const szenenIdMap = {};
      
      // Hilfsfunktion: Figurenliste aus Import-IDs erzeugen
      const buildHauptfiguren = (figureIds) => {
        if (!figureIds || !Array.isArray(figureIds)) return '';
        return figureIds
          .map(fId => {
            const mappedId = figurenIdMap[fId] || fId;
            const fig = newFiguren.find(f => f.id === mappedId || f.id === fId || f._exchangeId === fId);
            return fig ? (fig.figur || fig.name) : '';
          })
          .filter(Boolean).join(', ');
      };
      
      for (const scene of (data.scenes || [])) {
        const name = scene.name || '';
        
        // 1. Zuerst nach _exchangeId matchen
        let existIdx = newSzenen.findIndex(s => s._exchangeId && s._exchangeId === scene.id);
        
        // 2. Fallback: nach Name matchen
        if (existIdx === -1) {
          existIdx = newSzenen.findIndex(s => (s.name || s.szene || '').toLowerCase() === name.toLowerCase());
        }
        
        // 3. Fallback: nach Nummer matchen (wenn eindeutig)
        if (existIdx === -1 && scene.number) {
          const numMatch = newSzenen.findIndex(s => (s.nummer || '').toString().trim() === scene.number.toString().trim());
          if (numMatch !== -1) existIdx = numMatch;
        }
        
        if (existIdx === -1) {
          // Neue Szene
          const newId = genId();
          szenenIdMap[scene.id] = newId;
          
          newSzenen.push({
            id: newId, name: name, szene: name,
            nummer: scene.number || String(newSzenen.length + 1),
            beschreibung: scene.description || scene.summary || '',
            hauptfiguren: buildHauptfiguren(scene.figures),
            nebenfiguren: '',
            ort: scene.location || '', zeit: scene.time || '',
            _exchangeId: scene.id,
            _source: figurenReadOnly ? source : 'propla',
            _readOnly: figurenReadOnly
          });
          importedSzenen++;
        } else {
          szenenIdMap[scene.id] = newSzenen[existIdx].id;
          const existing = newSzenen[existIdx];
          let updated = false;
          
          // Exchange-ID nachtr√§glich setzen
          if (!existing._exchangeId) { existing._exchangeId = scene.id; updated = true; }
          
          // Umbenennung erkennen
          const oldName = (existing.name || existing.szene || '');
          if (oldName.toLowerCase() !== name.toLowerCase()) {
            renamedSzenen.push({ oldName: oldName, newName: name });
            existing.name = name;
            existing.szene = name;
            renamedSzenenCount++;
            updated = true;
          }
          
          // Leere Felder auff√ºllen
          if (!existing.beschreibung && (scene.description || scene.summary)) { existing.beschreibung = scene.description || scene.summary; updated = true; }
          if (!existing.ort && scene.location) { existing.ort = scene.location; updated = true; }
          if (!existing.zeit && scene.time) { existing.zeit = scene.time; updated = true; }
          if (!existing.nummer && scene.number) { existing.nummer = scene.number; updated = true; }
          if (figurenReadOnly && !existing._source) { existing._source = source; existing._readOnly = true; updated = true; }
          
          // KRITISCH: hauptfiguren IMMER aus Import aktualisieren wenn Figuren-IDs vorhanden
          // (weil in Rebu/Werkbank sich die Figurenliste einer Szene ge√§ndert haben kann)
          if (scene.figures && Array.isArray(scene.figures) && scene.figures.length > 0) {
            const newHauptfiguren = buildHauptfiguren(scene.figures);
            if (newHauptfiguren && existing.hauptfiguren !== newHauptfiguren) {
              existing.hauptfiguren = newHauptfiguren;
              updated = true;
            }
          }
          
          if (updated) updatedSzenen++; else skippedSzenen++;
        }
      }
      
      // Figurenumbenennungen auch in Szenen kaskadieren (f√ºr Szenen die NICHT im Import waren)
      if (renamedFiguren.length > 0) {
        for (const sz of newSzenen) {
          for (const rename of renamedFiguren) {
            if (sz.hauptfiguren) {
              sz.hauptfiguren = sz.hauptfiguren.split(',').map(f => {
                return f.trim().toLowerCase() === rename.oldName.toLowerCase() ? rename.newName : f.trim();
              }).filter(Boolean).join(', ');
            }
            if (sz.nebenfiguren) {
              sz.nebenfiguren = sz.nebenfiguren.split(',').map(f => {
                return f.trim().toLowerCase() === rename.oldName.toLowerCase() ? rename.newName : f.trim();
              }).filter(Boolean).join(', ');
            }
          }
        }
      }
      
      save(KEYS.szenen(projektId), newSzenen);
      
      // === ENSEMBLE ===
      const existingEnsemble = load(KEYS.ensemble(projektId), []);
      const newEnsemble = [...existingEnsemble];
      const personIdMap = {};
      
      const ensemblePersons = (data.persons || []).filter(p => p.category === 'ensemble' || !p.category);
      for (const person of ensemblePersons) {
        const name = (person.name || '').toLowerCase();
        const existing = existingEnsemble.find(e => (e.name || '').toLowerCase() === name);
        if (existing) { personIdMap[person.id] = existing.id; continue; }
        
        const newId = genId();
        personIdMap[person.id] = newId;
        newEnsemble.push({
          id: newId, name: person.name || '',
          email: person.email || '', telefon: person.phone || '',
          funktion: person.function || person.role || 'Schauspiel',
          bemerkungen: person.notes || '',
          strasse: person.address?.street || '',
          hausnummer: person.address?.number || '',
          plz: person.address?.zip || '',
          ort: person.address?.city || ''
        });
        importedEnsemble++;
      }
      if (importedEnsemble > 0) save(KEYS.ensemble(projektId), newEnsemble);
      
      // === K√úNSTLERISCHES TEAM ===
      const existingTeam = load(KEYS.kuenstlerischesTeam(projektId), []);
      const newTeam = [...existingTeam];
      
      const teamPersons = (data.persons || []).filter(p => p.category === 'artistic_team');
      for (const person of teamPersons) {
        const name = (person.name || '').toLowerCase();
        const existing = existingTeam.find(t => (t.name || '').toLowerCase() === name);
        if (existing) { personIdMap[person.id] = existing.id; continue; }
        
        const newId = genId();
        personIdMap[person.id] = newId;
        newTeam.push({
          id: newId, name: person.name || '',
          email: person.email || '', telefon: person.phone || '',
          funktion: person.function || person.role || '',
          bemerkungen: person.notes || '',
          strasse: person.address?.street || '',
          hausnummer: person.address?.number || '',
          plz: person.address?.zip || '',
          ort: person.address?.city || ''
        });
        importedTeam++;
      }
      if (importedTeam > 0) save(KEYS.kuenstlerischesTeam(projektId), newTeam);
      
      // === CASTINGS/ZUORDNUNGEN (nutzt bereits geladene + kaskadierte existingZuordnungen) ===
      const newZuordnungen = [...existingZuordnungen];
      
      for (const casting of (data.castings || [])) {
        const personId = personIdMap[casting.person_id] || casting.person_id;
        const figurId = figurenIdMap[casting.figure_id] || casting.figure_id;
        const person = newEnsemble.find(e => e.id === personId);
        const figur = newFiguren.find(f => f.id === figurId);
        
        if (person && figur) {
          const exists = newZuordnungen.some(z => z.schauspieler === person.name && z.figur === (figur.figur || figur.name));
          if (!exists) {
            newZuordnungen.push({ id: genId(), figur: figur.figur || figur.name, schauspieler: person.name });
            importedCastings++;
          }
        }
      }
      if (importedCastings > 0 || renamedFiguren.length > 0) save(KEYS.zuordnungen(projektId), newZuordnungen);
      
      // === PROBEN ===
      const existingProben = load(KEYS.probedaten(projektId), []);
      const newProben = [...existingProben];
      
      for (const rehearsal of (data.rehearsals || [])) {
        newProben.push({
          id: genId(), datum: rehearsal.date || '',
          anfangszeit: rehearsal.start_time || '', endzeit: rehearsal.end_time || '',
          ort: rehearsal.location || '', artDerProbe: rehearsal.rehearsal_type || '',
          anmerkungen: rehearsal.notes || ''
        });
        importedRehearsals++;
      }
      if (importedRehearsals > 0) save(KEYS.probedaten(projektId), newProben);
      
      // === ABSENZEN ===
      const existingAbsenzen = load(KEYS.absenzen(projektId), []);
      const newAbsenzen = [...existingAbsenzen];
      
      for (const abs of (data.absences || [])) {
        const personName = abs.person_name || '';
        if (!personName) continue;
        // Duplikat-Check
        const exists = newAbsenzen.some(a => a.schauspieler === personName && a.datum === abs.date);
        if (!exists) {
          newAbsenzen.push({
            id: genId(), schauspieler: personName,
            datum: abs.date || '', anfangszeit: abs.start_time || '',
            endzeit: abs.end_time || '', bemerkungen: abs.notes || ''
          });
          importedAbsences++;
        }
      }
      if (importedAbsences > 0) save(KEYS.absenzen(projektId), newAbsenzen);
      
      // === TEAM-VERF√úGBARKEIT ===
      const existingTeamV = load(KEYS.teamVerfuegbarkeit(projektId), []);
      const newTeamV = [...existingTeamV];
      
      for (const avail of (data.team_availability || [])) {
        const personName = avail.person_name || '';
        if (!personName) continue;
        const exists = newTeamV.some(a => a.teammitglied === personName && a.datum === avail.date);
        if (!exists) {
          newTeamV.push({
            id: genId(), teammitglied: personName,
            datum: avail.date || '', anfangszeit: avail.start_time || '',
            endzeit: avail.end_time || '', bemerkungen: avail.notes || ''
          });
          importedTeamAvail++;
        }
      }
      if (importedTeamAvail > 0) save(KEYS.teamVerfuegbarkeit(projektId), newTeamV);
      
      // Cloud-Sync (f√ºr Figuren und Szenen)
      if (isCloudMode && currentCloudProjectId) {
        newFiguren.forEach(async (fig) => {
          if (!existingFiguren.find(ef => ef.id === fig.id)) {
            try {
              await db.from('figures').upsert({ id: fig.id, project_id: currentCloudProjectId, name: fig.figur || fig.name, description: fig.kurzbeschreibung || '' });
            } catch (err) { console.error('Cloud sync error:', err); }
          }
        });
        newSzenen.forEach(async (sz) => {
          if (!existingSzenen.find(es => es.id === sz.id)) {
            try {
              await db.from('scenes').upsert({ id: sz.id, project_id: currentCloudProjectId, number: sz.nummer, name: sz.name || sz.szene, description: sz.beschreibung, location: sz.ort, time_of_day: sz.zeit });
            } catch (err) { console.error('Cloud sync error:', err); }
          }
        });
      }
      
      // Preview schliessen
      closeNinaPreview();
      render();
      
      // Erfolgsmeldung
      let msg = '‚úÖ NINA-Exchange Import erfolgreich!\n\n';
      if (importedFiguren > 0 || updatedFiguren > 0 || renamedFigurenCount > 0) {
        msg += `üë§ Figuren: ${importedFiguren} neu, ${updatedFiguren} erg√§nzt, ${skippedFiguren} unver√§ndert`;
        if (renamedFigurenCount > 0) msg += `, ${renamedFigurenCount} umbenannt`;
        msg += '\n';
      }
      if (importedSzenen > 0 || updatedSzenen > 0 || renamedSzenenCount > 0) {
        msg += `üé¨ Szenen: ${importedSzenen} neu, ${updatedSzenen} erg√§nzt, ${skippedSzenen} unver√§ndert`;
        if (renamedSzenenCount > 0) msg += `, ${renamedSzenenCount} umbenannt`;
        msg += '\n';
      }
      if (importedEnsemble > 0) msg += `üë• Ensemble: ${importedEnsemble} neu\n`;
      if (importedTeam > 0) msg += `üé® K√ºnstl. Team: ${importedTeam} neu\n`;
      if (importedCastings > 0) msg += `üé≠ Zuordnungen: ${importedCastings} neu\n`;
      if (importedRehearsals > 0) msg += `üìÖ Proben: ${importedRehearsals} neu\n`;
      if (importedAbsences > 0) msg += `üö´ Absenzen: ${importedAbsences} neu\n`;
      if (importedTeamAvail > 0) msg += `üìã Team-Verf√ºgbarkeit: ${importedTeamAvail} neu\n`;
      
      // Umbenennungs-Details anzeigen
      if (renamedFiguren.length > 0) {
        msg += '\nüîÑ Umbenennungen (kaskadiert zu Besetzung + Szenen):\n';
        renamedFiguren.forEach(r => { msg += `   ${r.oldName} ‚Üí ${r.newName}\n`; });
      }
      if (renamedSzenen.length > 0) {
        msg += '\nüîÑ Szenen umbenannt:\n';
        renamedSzenen.forEach(r => { msg += `   ${r.oldName} ‚Üí ${r.newName}\n`; });
      }
      
      if (figurenReadOnly) msg += '\nüîí Figuren und Szenen sind read-only (Quelle: ' + source + ').';
      if (isCloudMode) msg += '\n‚òÅÔ∏è Daten wurden auch in die Cloud synchronisiert.';
      
      alert(msg);
    }
    
    // ============================================
    // NINA-EXCHANGE EXPORT v2.0
    // ============================================
    // Build exchange data without downloading (used by Drive export)
    function buildPropExchangeData(includeContacts = true) {
      if (!state.projekt) return null;
      const projektId = state.projekt.id;
      const p = state.projekt;
      const figuren = load(KEYS.figuren(projektId), []);
      const szenen = load(KEYS.szenen(projektId), []);
      const ensemble = load(KEYS.ensemble(projektId), []);
      const team = load(KEYS.kuenstlerischesTeam(projektId), []);
      const zuordnungen = load(KEYS.zuordnungen(projektId), []);
      const proben = load(KEYS.probedaten(projektId), []);
      const absenzen = load(KEYS.absenzen(projektId), []);
      const teamVerfueg = load(KEYS.teamVerfuegbarkeit(projektId), []);
      const probenplanung = load(KEYS.probenplanung(projektId), []);
      const exportPerson = (person, category) => {
        const base = { id: person.id, name: person.name || '', role: person.funktion || '', function: person.funktion || '', category, notes: person.bemerkungen || '' };
        if (includeContacts) { base.email = person.email || ''; base.phone = person.telefon || ''; base.address = { street: person.strasse || '', number: person.hausnummer || '', zip: person.plz || '', city: person.ort || '' }; }
        return base;
      };
      return {
        format: 'nina-exchange', version: '3.0', exportedFrom: 'propla', exportedAt: new Date().toISOString(), includes_contacts: includeContacts,
        project: { name: p.name || 'Unbenannt', subtitle: p.untertitel || '', author: p.autor || '', director: p.regie || '', description: p.logline || '', tagline: p.tagline || '', logline: p.logline || '', copyright: p.copyright || '', premiere_date: p.premiere || null, venue: p.spielstaette || '', version_name: 'Arbeitsfassung', version_date: new Date().toISOString(), status: 'active' },
        figures: figuren.map((f, idx) => ({ id: f._exchangeId || f.id, name: f.figur || f.name || '', short_name: f.kuerzel || (f.figur || f.name || '').substring(0, 3).toUpperCase(), description: f.kurzbeschreibung || '', color: f.color || '', figure_type: f.figure_type || 'main', sort_order: idx, _source: f._source || 'propla' })),
        scenes: szenen.map((s, idx) => { const figurenIds = (s.hauptfiguren || '').split(',').map(n => n.trim()).filter(Boolean).map(n => { const fig = figuren.find(f => (f.figur || f.name || '').toLowerCase() === n.toLowerCase()); return fig ? (fig._exchangeId || fig.id) : undefined; }).filter(Boolean); return { id: s._exchangeId || s.id, number: s.nummer || String(idx + 1), name: s.name || s.szene || 'Szene ' + (idx + 1), description: s.beschreibung || '', summary: s.beschreibung || '', location: s.ort || '', time: s.zeit || '', figures: figurenIds, status: 'planned', sort_order: idx, _source: s._source || 'propla' }; }),
        persons: [...ensemble.map(person => exportPerson(person, 'ensemble')), ...team.map(person => exportPerson(person, 'artistic_team'))],
        castings: zuordnungen.map(z => { const person = ensemble.find(e => e.name === z.schauspieler); const figur = figuren.find(f => (f.figur || f.name) === z.figur); return { person_id: person?.id || '', figure_id: figur?.id || '', casting_type: 'main', notes: '' }; }).filter(c => c.person_id && c.figure_id),
        rehearsals: proben.map(r => { const planEntry = probenplanung.find(pp => pp.probeId === r.id); return { id: r.id, date: r.datum || '', start_time: r.anfangszeit || '', end_time: r.endzeit || '', location: r.ort || '', rehearsal_type: r.artDerProbe || '', notes: r.anmerkungen || '', scene_ids: planEntry?.szenen || [] }; }),
        absences: absenzen.map(a => { const person = ensemble.find(e => e.name === a.schauspieler); return { id: a.id, person_id: person?.id || '', person_name: a.schauspieler || '', date: a.datum || '', start_time: a.anfangszeit || '', end_time: a.endzeit || '', notes: a.bemerkungen || '' }; }),
        team_availability: teamVerfueg.map(a => { const person = team.find(t => t.name === a.teammitglied); return { id: a.id, person_id: person?.id || '', person_name: a.teammitglied || '', date: a.datum || '', start_time: a.anfangszeit || '', end_time: a.endzeit || '', notes: a.bemerkungen || '' }; })
      };
    }
    
    function exportNinaExchange() {
      if (!state.projekt) {
        alert('‚ùå Bitte zuerst ein Projekt ausw√§hlen!');
        return;
      }
      
      const projektId = state.projekt.id;
      const p = state.projekt;
      
      // Daten laden
      const figuren = load(KEYS.figuren(projektId), []);
      const szenen = load(KEYS.szenen(projektId), []);
      const ensemble = load(KEYS.ensemble(projektId), []);
      const team = load(KEYS.kuenstlerischesTeam(projektId), []);
      const zuordnungen = load(KEYS.zuordnungen(projektId), []);
      const proben = load(KEYS.probedaten(projektId), []);
      const absenzen = load(KEYS.absenzen(projektId), []);
      const teamVerfueg = load(KEYS.teamVerfuegbarkeit(projektId), []);
      const probenplanung = load(KEYS.probenplanung(projektId), []);
      
      // Datenschutz-Dialog
      const hasPersonalData = ensemble.length > 0 || team.length > 0;
      let includeContacts = true;
      if (hasPersonalData) {
        const choice = confirm(
          '‚ö†Ô∏è Datenschutz-Hinweis\n\n' +
          'Diese Export-Datei enth√§lt pers√∂nliche Kontaktdaten\n' +
          '(E-Mail, Telefon, Adresse) von Ensemble und Team.\n\n' +
          'OK = Mit Kontaktdaten exportieren\n' +
          'Abbrechen = Ohne Kontaktdaten (nur Namen + Funktionen)'
        );
        includeContacts = choice;
      }
      
      // Personen-Export-Funktion (mit/ohne Kontaktdaten)
      const exportPerson = (person, category) => {
        const base = {
          id: person.id,
          name: person.name || '',
          role: person.funktion || '',
          function: person.funktion || '',
          category: category,
          notes: person.bemerkungen || ''
        };
        if (includeContacts) {
          base.email = person.email || '';
          base.phone = person.telefon || '';
          base.address = {
            street: person.strasse || '',
            number: person.hausnummer || '',
            zip: person.plz || '',
            city: person.ort || ''
          };
        }
        return base;
      };
      
      // NINA-Exchange v3.0 Format erstellen
      const ninaExport = {
        format: 'nina-exchange',
        version: '3.0',
        exportedFrom: 'propla',
        exportedAt: new Date().toISOString(),
        includes_contacts: includeContacts,
        
        // === PROJEKT ===
        project: {
          name: p.name || 'Unbenannt',
          subtitle: p.untertitel || '',
          author: p.autor || '',
          director: p.regie || '',
          description: p.logline || '',
          tagline: p.tagline || '',
          logline: p.logline || '',
          copyright: p.copyright || '',
          premiere_date: p.premiere || null,
          venue: p.spielstaette || '',
          version_name: 'Arbeitsfassung',
          version_date: new Date().toISOString(),
          status: 'active'
        },
        
        // === FIGUREN (read-only Durchreichung) ===
        figures: figuren.map((f, idx) => ({
          id: f._exchangeId || f.id,
          name: f.figur || f.name || '',
          short_name: f.kuerzel || (f.figur || f.name || '').substring(0, 3).toUpperCase(),
          description: f.kurzbeschreibung || '',
          color: f.color || '',
          figure_type: f.figure_type || 'main',
          sort_order: idx,
          _source: f._source || 'propla'
        })),
        
        // === SZENEN (read-only Durchreichung) ===
        scenes: szenen.map((s, idx) => {
          const figurenIds = (s.hauptfiguren || '').split(',')
            .map(name => name.trim())
            .filter(Boolean)
            .map(name => {
              const fig = figuren.find(f => (f.figur || f.name || '').toLowerCase() === name.toLowerCase());
              return fig ? (fig._exchangeId || fig.id) : undefined;
            })
            .filter(Boolean);
          
          return {
            id: s._exchangeId || s.id,
            number: s.nummer || String(idx + 1),
            name: s.name || s.szene || 'Szene ' + (idx + 1),
            description: s.beschreibung || '',
            summary: s.beschreibung || '',
            location: s.ort || '',
            time: s.zeit || '',
            figures: figurenIds,
            status: 'planned',
            sort_order: idx,
            _source: s._source || 'propla'
          };
        }),
        
        // === ENSEMBLE (Propla-Dom√§ne) ===
        persons: [
          ...ensemble.map(person => exportPerson(person, 'ensemble')),
          ...team.map(person => exportPerson(person, 'artistic_team'))
        ],
        
        // === CASTINGS/ZUORDNUNGEN (Propla-Dom√§ne) ===
        castings: zuordnungen.map(z => {
          const person = ensemble.find(e => e.name === z.schauspieler);
          const figur = figuren.find(f => (f.figur || f.name) === z.figur);
          return {
            person_id: person?.id || '',
            figure_id: figur ? (figur._exchangeId || figur.id) : '',
            casting_type: 'main',
            notes: ''
          };
        }).filter(c => c.person_id && c.figure_id),
        
        // === PROBEN (Propla-Dom√§ne) ===
        rehearsals: proben.map(r => {
          // Szenen-Zuordnungen aus Probenplanung holen
          const planEntry = probenplanung.find(pp => pp.probeId === r.id);
          return {
            id: r.id,
            date: r.datum || '',
            start_time: r.anfangszeit || '',
            end_time: r.endzeit || '',
            location: r.ort || '',
            rehearsal_type: r.artDerProbe || '',
            notes: r.anmerkungen || '',
            scene_ids: planEntry?.szenen || []
          };
        }),
        
        // === ABSENZEN (Propla-Dom√§ne) ===
        absences: absenzen.map(a => {
          const person = ensemble.find(e => e.name === a.schauspieler);
          return {
            id: a.id,
            person_id: person?.id || '',
            person_name: a.schauspieler || '',
            date: a.datum || '',
            start_time: a.anfangszeit || '',
            end_time: a.endzeit || '',
            notes: a.bemerkungen || ''
          };
        }),
        
        // === TEAM-VERF√úGBARKEIT (Propla-Dom√§ne) ===
        team_availability: teamVerfueg.map(a => {
          const person = team.find(t => t.name === a.teammitglied);
          return {
            id: a.id,
            person_id: person?.id || '',
            person_name: a.teammitglied || '',
            date: a.datum || '',
            start_time: a.anfangszeit || '',
            end_time: a.endzeit || '',
            notes: a.bemerkungen || ''
          };
        })
      };
      
      // Als JSON-Datei herunterladen
      const safeName = (p.name || 'projekt').replace(/[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü]/g, '_');
      const now = new Date();
      const ts = now.toISOString().slice(0, 10) + '_' + now.toTimeString().slice(0, 5).replace(':', '-');
      const fileName = safeName + '_Propla_Exchange_' + ts + '.json';
      const content = JSON.stringify(ninaExport, null, 2);
      
      const blob = new Blob([content], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      
      // Feedback
      let msg = '‚úÖ NINA-Exchange v3.0 Export erstellt!\n\n';
      msg += 'üìÅ Datei: ' + fileName + '\n\n';
      msg += 'üìã Projekt: ' + (p.name || 'Unbenannt') + '\n';
      msg += 'üë§ ' + ninaExport.figures.length + ' Figuren\n';
      msg += 'üé¨ ' + ninaExport.scenes.length + ' Szenen\n';
      msg += 'üë• ' + ensemble.length + ' Ensemble + ' + team.length + ' Team\n';
      msg += 'üé≠ ' + ninaExport.castings.length + ' Zuordnungen\n';
      msg += 'üìÖ ' + ninaExport.rehearsals.length + ' Proben\n';
      msg += 'üö´ ' + ninaExport.absences.length + ' Absenzen\n';
      if (!includeContacts) msg += '\nüîí Ohne Kontaktdaten exportiert.';
      msg += '\n\nDiese Datei kann in Werkbank, Rebu und Propla importiert werden.';
      
      alert(msg);
    }

    function exportBackup(projektId) { if (!projektId) return; const p = state.projekte.find(pr => pr.id === projektId); const data = { exportedAt: new Date().toISOString(), exportedFrom: 'N!NA-Propla v3.0', projectInfo: p, probedaten: load(KEYS.probedaten(projektId), []), ensemble: load(KEYS.ensemble(projektId), []), kuenstlerischesTeam: load(KEYS.kuenstlerischesTeam(projektId), []), teamVerfuegbarkeit: load(KEYS.teamVerfuegbarkeit(projektId), []), figuren: load(KEYS.figuren(projektId), []), zuordnungen: load(KEYS.zuordnungen(projektId), []), szenen: load(KEYS.szenen(projektId), []), absenzen: load(KEYS.absenzen(projektId), []), probenplanung: load(KEYS.probenplanung(projektId), []) }; const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); const safeName = (p?.name || 'backup').replace(/[\\/:*?"<>|]+/g, '_').replace(/\s+/g, '_').trim(); const now = new Date(); const ts = now.toISOString().slice(0, 10) + '_' + now.toTimeString().slice(0, 5).replace(':', '-'); a.download = `${safeName}_Propla_Backup_${ts}.json`; a.click(); }
    function exportStyledExcel(type) {
      const keyMap = { probedaten: KEYS.probedaten, ensemble: KEYS.ensemble, team: KEYS.kuenstlerischesTeam, teamVerfuegbarkeit: KEYS.teamVerfuegbarkeit, figuren: KEYS.figuren, zuordnungen: KEYS.zuordnungen, szenen: KEYS.szenen, absenzen: KEYS.absenzen };
      const data = getData(keyMap[type]);
      if (!data?.length) return alert('Keine Daten!');
      const wb = XLSX.utils.book_new();
      let wsData = [], headers = [];
      switch (type) {
        case 'probedaten': headers = ['Datum', 'Wochentag', 'Von', 'Bis', 'Art', 'Ort', 'Anmerkungen']; wsData = [headers, ...data.map(d => [formatDatum(d.datum), getWochentag(d.datum), d.anfangszeit || '', d.endzeit || '', d.artDerProbe || '', d.ort || '', d.anmerkungen || ''])]; break;
        case 'ensemble': case 'team': headers = ['Name', 'Funktion', 'E-Mail', 'Telefon', 'Strasse', 'Nr.', 'PLZ', 'Ort', 'Land', 'Bemerkungen']; wsData = [headers, ...data.map(d => [d.name || '', d.funktion || '', d.email || '', d.telefon || '', d.strasse || '', d.hausnummer || '', d.plz || '', d.ort || '', d.land || '', d.bemerkungen || ''])]; break;
        case 'teamVerfuegbarkeit': headers = ['Teammitglied', 'Datum', 'Von', 'Bis', 'Bemerkungen']; wsData = [headers, ...data.map(d => [d.teammitglied || '', formatDatum(d.datum), d.anfangszeit || '', d.endzeit || '', d.bemerkungen || ''])]; break;
        case 'figuren': headers = ['Figur', 'Kurzbeschreibung']; wsData = [headers, ...data.map(d => [d.figur || d.name || '', d.kurzbeschreibung || ''])]; break;
        case 'zuordnungen': headers = ['Figur', 'Schauspieler:in']; wsData = [headers, ...data.map(d => [d.figur || '', d.schauspieler || ''])]; break;
        case 'szenen': headers = ['Nr.', 'Szene', 'Beschreibung', 'Hauptfiguren', 'Nebenfiguren']; wsData = [headers, ...data.map(d => [d.nummer || '', d.name || d.szene || '', d.beschreibung || '', d.hauptfiguren || '', d.nebenfiguren || ''])]; break;
        case 'absenzen': headers = ['Person', 'Datum', 'Wochentag', 'Von', 'Bis', 'Bemerkungen']; wsData = [headers, ...data.map(d => [d.schauspieler || '', formatDatum(d.datum), getWochentag(d.datum), d.anfangszeit || '', d.endzeit || '', d.bemerkungen || ''])]; break;
      }
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      ws['!cols'] = headers.map(() => ({ wch: 18 }));
      XLSX.utils.book_append_sheet(wb, ws, type);
      XLSX.writeFile(wb, `nina_${type}_${new Date().toISOString().split('T')[0]}.xlsx`);
    }

    // ============================================
    // INIT
    // ============================================
    
    // Migration: Konvertiere alle probeIds zu Strings
    function migrateProbenplanung() {
      if (!state.projekt) return;
      const key = KEYS.probenplanung(state.projekt.id);
      const data = load(key, []);
      if (data.length > 0) {
        const migrated = data.map(p => ({
          ...p,
          probeId: String(p.probeId)
        }));
        save(key, migrated);
        console.log('Migrated probenplanung:', migrated);
      }
    }
    
    // Initial migration
    if (state.projekt) {
      migrateProbenplanung();
      
      // Cloud-ID initialisieren wenn Projekt mit Cloud verkn√ºpft ist
      if (state.projekt.cloudId) {
        currentCloudProjectId = state.projekt.cloudId;
      } else if (state.projekt.id?.startsWith('cloud_')) {
        currentCloudProjectId = state.projekt.id.replace('cloud_', '');
      }
    }
    
    // Cloud-Auth pr√ºfen beim Start
    checkCloudAuth();
  </script>
</body>
</html>
